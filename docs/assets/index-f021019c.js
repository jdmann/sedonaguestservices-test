function ij(t, r) {
  for (var a = 0; a < r.length; a++) {
    const o = r[a]
    if (typeof o != 'string' && !Array.isArray(o)) {
      for (const l in o)
        if (l !== 'default' && !(l in t)) {
          const f = Object.getOwnPropertyDescriptor(o, l)
          f && Object.defineProperty(t, l, f.get ? f : { enumerable: !0, get: () => o[l] })
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }))
}
;(function () {
  const r = document.createElement('link').relList
  if (r && r.supports && r.supports('modulepreload')) return
  for (const l of document.querySelectorAll('link[rel="modulepreload"]')) o(l)
  new MutationObserver((l) => {
    for (const f of l)
      if (f.type === 'childList')
        for (const c of f.addedNodes) c.tagName === 'LINK' && c.rel === 'modulepreload' && o(c)
  }).observe(document, { childList: !0, subtree: !0 })
  function a(l) {
    const f = {}
    return (
      l.integrity && (f.integrity = l.integrity),
      l.referrerPolicy && (f.referrerPolicy = l.referrerPolicy),
      l.crossOrigin === 'use-credentials'
        ? (f.credentials = 'include')
        : l.crossOrigin === 'anonymous'
        ? (f.credentials = 'omit')
        : (f.credentials = 'same-origin'),
      f
    )
  }
  function o(l) {
    if (l.ep) return
    l.ep = !0
    const f = a(l)
    fetch(l.href, f)
  }
})()
var lm =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
function oj(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t
}
var Ed = {},
  sj = {
    get exports() {
      return Ed
    },
    set exports(t) {
      Ed = t
    },
  },
  Em = {},
  R = {},
  lj = {
    get exports() {
      return R
    },
    set exports(t) {
      R = t
    },
  },
  Fm = {},
  uj = {
    get exports() {
      return Fm
    },
    set exports(t) {
      Fm = t
    },
  }
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (t, r) {
  ;(function () {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == 'function' &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
    var a = '18.2.0',
      o = Symbol.for('react.element'),
      l = Symbol.for('react.portal'),
      f = Symbol.for('react.fragment'),
      c = Symbol.for('react.strict_mode'),
      p = Symbol.for('react.profiler'),
      h = Symbol.for('react.provider'),
      m = Symbol.for('react.context'),
      g = Symbol.for('react.forward_ref'),
      b = Symbol.for('react.suspense'),
      C = Symbol.for('react.suspense_list'),
      w = Symbol.for('react.memo'),
      k = Symbol.for('react.lazy'),
      D = Symbol.for('react.offscreen'),
      E = Symbol.iterator,
      M = '@@iterator'
    function z(S) {
      if (S === null || typeof S != 'object') return null
      var O = (E && S[E]) || S[M]
      return typeof O == 'function' ? O : null
    }
    var P = { current: null },
      B = { transition: null },
      j = { current: null, isBatchingLegacy: !1, didScheduleLegacyUpdate: !1 },
      Q = { current: null },
      Y = {},
      ne = null
    function he(S) {
      ne = S
    }
    ;(Y.setExtraStackFrame = function (S) {
      ne = S
    }),
      (Y.getCurrentStack = null),
      (Y.getStackAddendum = function () {
        var S = ''
        ne && (S += ne)
        var O = Y.getCurrentStack
        return O && (S += O() || ''), S
      })
    var le = !1,
      pe = !1,
      Ne = !1,
      me = !1,
      ge = !1,
      Oe = { ReactCurrentDispatcher: P, ReactCurrentBatchConfig: B, ReactCurrentOwner: Q }
    ;(Oe.ReactDebugCurrentFrame = Y), (Oe.ReactCurrentActQueue = j)
    function ze(S) {
      {
        for (var O = arguments.length, G = new Array(O > 1 ? O - 1 : 0), Z = 1; Z < O; Z++)
          G[Z - 1] = arguments[Z]
        ut('warn', S, G)
      }
    }
    function ee(S) {
      {
        for (var O = arguments.length, G = new Array(O > 1 ? O - 1 : 0), Z = 1; Z < O; Z++)
          G[Z - 1] = arguments[Z]
        ut('error', S, G)
      }
    }
    function ut(S, O, G) {
      {
        var Z = Oe.ReactDebugCurrentFrame,
          de = Z.getStackAddendum()
        de !== '' && ((O += '%s'), (G = G.concat([de])))
        var Ue = G.map(function (Me) {
          return String(Me)
        })
        Ue.unshift('Warning: ' + O), Function.prototype.apply.call(console[S], console, Ue)
      }
    }
    var Bt = {}
    function rt(S, O) {
      {
        var G = S.constructor,
          Z = (G && (G.displayName || G.name)) || 'ReactClass',
          de = Z + '.' + O
        if (Bt[de]) return
        ee(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          O,
          Z
        ),
          (Bt[de] = !0)
      }
    }
    var qe = {
        isMounted: function (S) {
          return !1
        },
        enqueueForceUpdate: function (S, O, G) {
          rt(S, 'forceUpdate')
        },
        enqueueReplaceState: function (S, O, G, Z) {
          rt(S, 'replaceState')
        },
        enqueueSetState: function (S, O, G, Z) {
          rt(S, 'setState')
        },
      },
      vt = Object.assign,
      Pe = {}
    Object.freeze(Pe)
    function Ke(S, O, G) {
      ;(this.props = S), (this.context = O), (this.refs = Pe), (this.updater = G || qe)
    }
    ;(Ke.prototype.isReactComponent = {}),
      (Ke.prototype.setState = function (S, O) {
        if (typeof S != 'object' && typeof S != 'function' && S != null)
          throw new Error(
            'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
          )
        this.updater.enqueueSetState(this, S, O, 'setState')
      }),
      (Ke.prototype.forceUpdate = function (S) {
        this.updater.enqueueForceUpdate(this, S, 'forceUpdate')
      })
    {
      var Mt = {
          isMounted: [
            'isMounted',
            'Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.',
          ],
          replaceState: [
            'replaceState',
            'Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).',
          ],
        },
        Rt = function (S, O) {
          Object.defineProperty(Ke.prototype, S, {
            get: function () {
              ze('%s(...) is deprecated in plain JavaScript React classes. %s', O[0], O[1])
            },
          })
        }
      for (var an in Mt) Mt.hasOwnProperty(an) && Rt(an, Mt[an])
    }
    function _t() {}
    _t.prototype = Ke.prototype
    function zt(S, O, G) {
      ;(this.props = S), (this.context = O), (this.refs = Pe), (this.updater = G || qe)
    }
    var Qt = (zt.prototype = new _t())
    ;(Qt.constructor = zt), vt(Qt, Ke.prototype), (Qt.isPureReactComponent = !0)
    function Ct() {
      var S = { current: null }
      return Object.seal(S), S
    }
    var xe = Array.isArray
    function wt(S) {
      return xe(S)
    }
    function Zt(S) {
      {
        var O = typeof Symbol == 'function' && Symbol.toStringTag,
          G = (O && S[Symbol.toStringTag]) || S.constructor.name || 'Object'
        return G
      }
    }
    function Jt(S) {
      try {
        return on(S), !1
      } catch {
        return !0
      }
    }
    function on(S) {
      return '' + S
    }
    function sn(S) {
      if (Jt(S))
        return (
          ee(
            'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
            Zt(S)
          ),
          on(S)
        )
    }
    function Kn(S, O, G) {
      var Z = S.displayName
      if (Z) return Z
      var de = O.displayName || O.name || ''
      return de !== '' ? G + '(' + de + ')' : G
    }
    function Xn(S) {
      return S.displayName || 'Context'
    }
    function en(S) {
      if (S == null) return null
      if (
        (typeof S.tag == 'number' &&
          ee(
            'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
          ),
        typeof S == 'function')
      )
        return S.displayName || S.name || null
      if (typeof S == 'string') return S
      switch (S) {
        case f:
          return 'Fragment'
        case l:
          return 'Portal'
        case p:
          return 'Profiler'
        case c:
          return 'StrictMode'
        case b:
          return 'Suspense'
        case C:
          return 'SuspenseList'
      }
      if (typeof S == 'object')
        switch (S.$$typeof) {
          case m:
            var O = S
            return Xn(O) + '.Consumer'
          case h:
            var G = S
            return Xn(G._context) + '.Provider'
          case g:
            return Kn(S, S.render, 'ForwardRef')
          case w:
            var Z = S.displayName || null
            return Z !== null ? Z : en(S.type) || 'Memo'
          case k: {
            var de = S,
              Ue = de._payload,
              Me = de._init
            try {
              return en(Me(Ue))
            } catch {
              return null
            }
          }
        }
      return null
    }
    var hn = Object.prototype.hasOwnProperty,
      gn = { key: !0, ref: !0, __self: !0, __source: !0 },
      jt,
      kn,
      wn
    wn = {}
    function jn(S) {
      if (hn.call(S, 'ref')) {
        var O = Object.getOwnPropertyDescriptor(S, 'ref').get
        if (O && O.isReactWarning) return !1
      }
      return S.ref !== void 0
    }
    function tn(S) {
      if (hn.call(S, 'key')) {
        var O = Object.getOwnPropertyDescriptor(S, 'key').get
        if (O && O.isReactWarning) return !1
      }
      return S.key !== void 0
    }
    function On(S, O) {
      var G = function () {
        jt ||
          ((jt = !0),
          ee(
            '%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            O
          ))
      }
      ;(G.isReactWarning = !0), Object.defineProperty(S, 'key', { get: G, configurable: !0 })
    }
    function J(S, O) {
      var G = function () {
        kn ||
          ((kn = !0),
          ee(
            '%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            O
          ))
      }
      ;(G.isReactWarning = !0), Object.defineProperty(S, 'ref', { get: G, configurable: !0 })
    }
    function te(S) {
      if (typeof S.ref == 'string' && Q.current && S.__self && Q.current.stateNode !== S.__self) {
        var O = en(Q.current.type)
        wn[O] ||
          (ee(
            'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
            O,
            S.ref
          ),
          (wn[O] = !0))
      }
    }
    var I = function (S, O, G, Z, de, Ue, Me) {
      var We = { $$typeof: o, type: S, key: O, ref: G, props: Me, _owner: Ue }
      return (
        (We._store = {}),
        Object.defineProperty(We._store, 'validated', {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1,
        }),
        Object.defineProperty(We, '_self', {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Z,
        }),
        Object.defineProperty(We, '_source', {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: de,
        }),
        Object.freeze && (Object.freeze(We.props), Object.freeze(We)),
        We
      )
    }
    function ie(S, O, G) {
      var Z,
        de = {},
        Ue = null,
        Me = null,
        We = null,
        gt = null
      if (O != null) {
        jn(O) && ((Me = O.ref), te(O)),
          tn(O) && (sn(O.key), (Ue = '' + O.key)),
          (We = O.__self === void 0 ? null : O.__self),
          (gt = O.__source === void 0 ? null : O.__source)
        for (Z in O) hn.call(O, Z) && !gn.hasOwnProperty(Z) && (de[Z] = O[Z])
      }
      var Wt = arguments.length - 2
      if (Wt === 1) de.children = G
      else if (Wt > 1) {
        for (var fn = Array(Wt), dn = 0; dn < Wt; dn++) fn[dn] = arguments[dn + 2]
        Object.freeze && Object.freeze(fn), (de.children = fn)
      }
      if (S && S.defaultProps) {
        var bn = S.defaultProps
        for (Z in bn) de[Z] === void 0 && (de[Z] = bn[Z])
      }
      if (Ue || Me) {
        var Ln = typeof S == 'function' ? S.displayName || S.name || 'Unknown' : S
        Ue && On(de, Ln), Me && J(de, Ln)
      }
      return I(S, Ue, Me, We, gt, Q.current, de)
    }
    function ce(S, O) {
      var G = I(S.type, O, S.ref, S._self, S._source, S._owner, S.props)
      return G
    }
    function be(S, O, G) {
      if (S == null)
        throw new Error(
          'React.cloneElement(...): The argument must be a React element, but you passed ' + S + '.'
        )
      var Z,
        de = vt({}, S.props),
        Ue = S.key,
        Me = S.ref,
        We = S._self,
        gt = S._source,
        Wt = S._owner
      if (O != null) {
        jn(O) && ((Me = O.ref), (Wt = Q.current)), tn(O) && (sn(O.key), (Ue = '' + O.key))
        var fn
        S.type && S.type.defaultProps && (fn = S.type.defaultProps)
        for (Z in O)
          hn.call(O, Z) &&
            !gn.hasOwnProperty(Z) &&
            (O[Z] === void 0 && fn !== void 0 ? (de[Z] = fn[Z]) : (de[Z] = O[Z]))
      }
      var dn = arguments.length - 2
      if (dn === 1) de.children = G
      else if (dn > 1) {
        for (var bn = Array(dn), Ln = 0; Ln < dn; Ln++) bn[Ln] = arguments[Ln + 2]
        de.children = bn
      }
      return I(S.type, Ue, Me, We, gt, Wt, de)
    }
    function Se(S) {
      return typeof S == 'object' && S !== null && S.$$typeof === o
    }
    var _e = '.',
      Ce = ':'
    function it(S) {
      var O = /[=:]/g,
        G = { '=': '=0', ':': '=2' },
        Z = S.replace(O, function (de) {
          return G[de]
        })
      return '$' + Z
    }
    var $e = !1,
      ln = /\/+/g
    function et(S) {
      return S.replace(ln, '$&/')
    }
    function Xe(S, O) {
      return typeof S == 'object' && S !== null && S.key != null
        ? (sn(S.key), it('' + S.key))
        : O.toString(36)
    }
    function En(S, O, G, Z, de) {
      var Ue = typeof S
      ;(Ue === 'undefined' || Ue === 'boolean') && (S = null)
      var Me = !1
      if (S === null) Me = !0
      else
        switch (Ue) {
          case 'string':
          case 'number':
            Me = !0
            break
          case 'object':
            switch (S.$$typeof) {
              case o:
              case l:
                Me = !0
            }
        }
      if (Me) {
        var We = S,
          gt = de(We),
          Wt = Z === '' ? _e + Xe(We, 0) : Z
        if (wt(gt)) {
          var fn = ''
          Wt != null && (fn = et(Wt) + '/'),
            En(gt, O, fn, '', function (Fv) {
              return Fv
            })
        } else
          gt != null &&
            (Se(gt) &&
              (gt.key && (!We || We.key !== gt.key) && sn(gt.key),
              (gt = ce(
                gt,
                G + (gt.key && (!We || We.key !== gt.key) ? et('' + gt.key) + '/' : '') + Wt
              ))),
            O.push(gt))
        return 1
      }
      var dn,
        bn,
        Ln = 0,
        Pt = Z === '' ? _e : Z + Ce
      if (wt(S))
        for (var Yo = 0; Yo < S.length; Yo++)
          (dn = S[Yo]), (bn = Pt + Xe(dn, Yo)), (Ln += En(dn, O, G, bn, de))
      else {
        var Yl = z(S)
        if (typeof Yl == 'function') {
          var bc = S
          Yl === bc.entries &&
            ($e ||
              ze(
                'Using Maps as children is not supported. Use an array of keyed ReactElements instead.'
              ),
            ($e = !0))
          for (var $v = Yl.call(bc), eo, Sc = 0; !(eo = $v.next()).done; )
            (dn = eo.value), (bn = Pt + Xe(dn, Sc++)), (Ln += En(dn, O, G, bn, de))
        } else if (Ue === 'object') {
          var xc = String(S)
          throw new Error(
            'Objects are not valid as a React child (found: ' +
              (xc === '[object Object]'
                ? 'object with keys {' + Object.keys(S).join(', ') + '}'
                : xc) +
              '). If you meant to render a collection of children, use an array instead.'
          )
        }
      }
      return Ln
    }
    function yn(S, O, G) {
      if (S == null) return S
      var Z = [],
        de = 0
      return (
        En(S, Z, '', '', function (Ue) {
          return O.call(G, Ue, de++)
        }),
        Z
      )
    }
    function va(S) {
      var O = 0
      return (
        yn(S, function () {
          O++
        }),
        O
      )
    }
    function Zr(S, O, G) {
      yn(
        S,
        function () {
          O.apply(this, arguments)
        },
        G
      )
    }
    function Jr(S) {
      return (
        yn(S, function (O) {
          return O
        }) || []
      )
    }
    function ga(S) {
      if (!Se(S))
        throw new Error('React.Children.only expected to receive a single React element child.')
      return S
    }
    function ya(S) {
      var O = {
        $$typeof: m,
        _currentValue: S,
        _currentValue2: S,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null,
      }
      O.Provider = { $$typeof: h, _context: O }
      var G = !1,
        Z = !1,
        de = !1
      {
        var Ue = { $$typeof: m, _context: O }
        Object.defineProperties(Ue, {
          Provider: {
            get: function () {
              return (
                Z ||
                  ((Z = !0),
                  ee(
                    'Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?'
                  )),
                O.Provider
              )
            },
            set: function (Me) {
              O.Provider = Me
            },
          },
          _currentValue: {
            get: function () {
              return O._currentValue
            },
            set: function (Me) {
              O._currentValue = Me
            },
          },
          _currentValue2: {
            get: function () {
              return O._currentValue2
            },
            set: function (Me) {
              O._currentValue2 = Me
            },
          },
          _threadCount: {
            get: function () {
              return O._threadCount
            },
            set: function (Me) {
              O._threadCount = Me
            },
          },
          Consumer: {
            get: function () {
              return (
                G ||
                  ((G = !0),
                  ee(
                    'Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?'
                  )),
                O.Consumer
              )
            },
          },
          displayName: {
            get: function () {
              return O.displayName
            },
            set: function (Me) {
              de ||
                (ze(
                  "Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.",
                  Me
                ),
                (de = !0))
            },
          },
        }),
          (O.Consumer = Ue)
      }
      return (O._currentRenderer = null), (O._currentRenderer2 = null), O
    }
    var Et = -1,
      Mn = 0,
      Qn = 1,
      cr = 2
    function jr(S) {
      if (S._status === Et) {
        var O = S._result,
          G = O()
        if (
          (G.then(
            function (Ue) {
              if (S._status === Mn || S._status === Et) {
                var Me = S
                ;(Me._status = Qn), (Me._result = Ue)
              }
            },
            function (Ue) {
              if (S._status === Mn || S._status === Et) {
                var Me = S
                ;(Me._status = cr), (Me._result = Ue)
              }
            }
          ),
          S._status === Et)
        ) {
          var Z = S
          ;(Z._status = Mn), (Z._result = G)
        }
      }
      if (S._status === Qn) {
        var de = S._result
        return (
          de === void 0 &&
            ee(
              `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,
              de
            ),
          'default' in de ||
            ee(
              `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,
              de
            ),
          de.default
        )
      } else throw S._result
    }
    function ea(S) {
      var O = { _status: Et, _result: S },
        G = { $$typeof: k, _payload: O, _init: jr }
      {
        var Z, de
        Object.defineProperties(G, {
          defaultProps: {
            configurable: !0,
            get: function () {
              return Z
            },
            set: function (Ue) {
              ee(
                'React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.'
              ),
                (Z = Ue),
                Object.defineProperty(G, 'defaultProps', { enumerable: !0 })
            },
          },
          propTypes: {
            configurable: !0,
            get: function () {
              return de
            },
            set: function (Ue) {
              ee(
                'React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.'
              ),
                (de = Ue),
                Object.defineProperty(G, 'propTypes', { enumerable: !0 })
            },
          },
        })
      }
      return G
    }
    function Tn(S) {
      S != null && S.$$typeof === w
        ? ee(
            'forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).'
          )
        : typeof S != 'function'
        ? ee(
            'forwardRef requires a render function but was given %s.',
            S === null ? 'null' : typeof S
          )
        : S.length !== 0 &&
          S.length !== 2 &&
          ee(
            'forwardRef render functions accept exactly two parameters: props and ref. %s',
            S.length === 1
              ? 'Did you forget to use the ref parameter?'
              : 'Any additional parameter will be undefined.'
          ),
        S != null &&
          (S.defaultProps != null || S.propTypes != null) &&
          ee(
            'forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?'
          )
      var O = { $$typeof: g, render: S }
      {
        var G
        Object.defineProperty(O, 'displayName', {
          enumerable: !1,
          configurable: !0,
          get: function () {
            return G
          },
          set: function (Z) {
            ;(G = Z), !S.name && !S.displayName && (S.displayName = Z)
          },
        })
      }
      return O
    }
    var L
    L = Symbol.for('react.module.reference')
    function se(S) {
      return !!(
        typeof S == 'string' ||
        typeof S == 'function' ||
        S === f ||
        S === p ||
        ge ||
        S === c ||
        S === b ||
        S === C ||
        me ||
        S === D ||
        le ||
        pe ||
        Ne ||
        (typeof S == 'object' &&
          S !== null &&
          (S.$$typeof === k ||
            S.$$typeof === w ||
            S.$$typeof === h ||
            S.$$typeof === m ||
            S.$$typeof === g ||
            S.$$typeof === L ||
            S.getModuleId !== void 0))
      )
    }
    function ve(S, O) {
      se(S) ||
        ee(
          'memo: The first argument must be a component. Instead received: %s',
          S === null ? 'null' : typeof S
        )
      var G = { $$typeof: w, type: S, compare: O === void 0 ? null : O }
      {
        var Z
        Object.defineProperty(G, 'displayName', {
          enumerable: !1,
          configurable: !0,
          get: function () {
            return Z
          },
          set: function (de) {
            ;(Z = de), !S.name && !S.displayName && (S.displayName = de)
          },
        })
      }
      return G
    }
    function ke() {
      var S = P.current
      return (
        S === null &&
          ee(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`),
        S
      )
    }
    function dt(S) {
      var O = ke()
      if (S._context !== void 0) {
        var G = S._context
        G.Consumer === S
          ? ee(
              'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?'
            )
          : G.Provider === S &&
            ee(
              'Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?'
            )
      }
      return O.useContext(S)
    }
    function ct(S) {
      var O = ke()
      return O.useState(S)
    }
    function at(S, O, G) {
      var Z = ke()
      return Z.useReducer(S, O, G)
    }
    function Be(S) {
      var O = ke()
      return O.useRef(S)
    }
    function Fn(S, O) {
      var G = ke()
      return G.useEffect(S, O)
    }
    function un(S, O) {
      var G = ke()
      return G.useInsertionEffect(S, O)
    }
    function cn(S, O) {
      var G = ke()
      return G.useLayoutEffect(S, O)
    }
    function fr(S, O) {
      var G = ke()
      return G.useCallback(S, O)
    }
    function ta(S, O) {
      var G = ke()
      return G.useMemo(S, O)
    }
    function Bo(S, O, G) {
      var Z = ke()
      return Z.useImperativeHandle(S, O, G)
    }
    function Zn(S, O) {
      {
        var G = ke()
        return G.useDebugValue(S, O)
      }
    }
    function $s() {
      var S = ke()
      return S.useTransition()
    }
    function Ka(S) {
      var O = ke()
      return O.useDeferredValue(S)
    }
    function ot() {
      var S = ke()
      return S.useId()
    }
    function yi(S, O, G) {
      var Z = ke()
      return Z.useSyncExternalStore(S, O, G)
    }
    var bi = 0,
      Fs,
      Ns,
      jo,
      Bs,
      js,
      Us,
      Vs
    function Bl() {}
    Bl.__reactDisabledLog = !0
    function vc() {
      {
        if (bi === 0) {
          ;(Fs = console.log),
            (Ns = console.info),
            (jo = console.warn),
            (Bs = console.error),
            (js = console.group),
            (Us = console.groupCollapsed),
            (Vs = console.groupEnd)
          var S = { configurable: !0, enumerable: !0, value: Bl, writable: !0 }
          Object.defineProperties(console, {
            info: S,
            log: S,
            warn: S,
            error: S,
            group: S,
            groupCollapsed: S,
            groupEnd: S,
          })
        }
        bi++
      }
    }
    function Is() {
      {
        if ((bi--, bi === 0)) {
          var S = { configurable: !0, enumerable: !0, writable: !0 }
          Object.defineProperties(console, {
            log: vt({}, S, { value: Fs }),
            info: vt({}, S, { value: Ns }),
            warn: vt({}, S, { value: jo }),
            error: vt({}, S, { value: Bs }),
            group: vt({}, S, { value: js }),
            groupCollapsed: vt({}, S, { value: Us }),
            groupEnd: vt({}, S, { value: Vs }),
          })
        }
        bi < 0 && ee('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
      }
    }
    var Xi = Oe.ReactCurrentDispatcher,
      na
    function Si(S, O, G) {
      {
        if (na === void 0)
          try {
            throw Error()
          } catch (de) {
            var Z = de.stack.trim().match(/\n( *(at )?)/)
            na = (Z && Z[1]) || ''
          }
        return (
          `
` +
          na +
          S
        )
      }
    }
    var ba = !1,
      xi
    {
      var Hs = typeof WeakMap == 'function' ? WeakMap : Map
      xi = new Hs()
    }
    function jl(S, O) {
      if (!S || ba) return ''
      {
        var G = xi.get(S)
        if (G !== void 0) return G
      }
      var Z
      ba = !0
      var de = Error.prepareStackTrace
      Error.prepareStackTrace = void 0
      var Ue
      ;(Ue = Xi.current), (Xi.current = null), vc()
      try {
        if (O) {
          var Me = function () {
            throw Error()
          }
          if (
            (Object.defineProperty(Me.prototype, 'props', {
              set: function () {
                throw Error()
              },
            }),
            typeof Reflect == 'object' && Reflect.construct)
          ) {
            try {
              Reflect.construct(Me, [])
            } catch (Pt) {
              Z = Pt
            }
            Reflect.construct(S, [], Me)
          } else {
            try {
              Me.call()
            } catch (Pt) {
              Z = Pt
            }
            S.call(Me.prototype)
          }
        } else {
          try {
            throw Error()
          } catch (Pt) {
            Z = Pt
          }
          S()
        }
      } catch (Pt) {
        if (Pt && Z && typeof Pt.stack == 'string') {
          for (
            var We = Pt.stack.split(`
`),
              gt = Z.stack.split(`
`),
              Wt = We.length - 1,
              fn = gt.length - 1;
            Wt >= 1 && fn >= 0 && We[Wt] !== gt[fn];

          )
            fn--
          for (; Wt >= 1 && fn >= 0; Wt--, fn--)
            if (We[Wt] !== gt[fn]) {
              if (Wt !== 1 || fn !== 1)
                do
                  if ((Wt--, fn--, fn < 0 || We[Wt] !== gt[fn])) {
                    var dn =
                      `
` + We[Wt].replace(' at new ', ' at ')
                    return (
                      S.displayName &&
                        dn.includes('<anonymous>') &&
                        (dn = dn.replace('<anonymous>', S.displayName)),
                      typeof S == 'function' && xi.set(S, dn),
                      dn
                    )
                  }
                while (Wt >= 1 && fn >= 0)
              break
            }
        }
      } finally {
        ;(ba = !1), (Xi.current = Ue), Is(), (Error.prepareStackTrace = de)
      }
      var bn = S ? S.displayName || S.name : '',
        Ln = bn ? Si(bn) : ''
      return typeof S == 'function' && xi.set(S, Ln), Ln
    }
    function Uo(S, O, G) {
      return jl(S, !1)
    }
    function gc(S) {
      var O = S.prototype
      return !!(O && O.isReactComponent)
    }
    function Ci(S, O, G) {
      if (S == null) return ''
      if (typeof S == 'function') return jl(S, gc(S))
      if (typeof S == 'string') return Si(S)
      switch (S) {
        case b:
          return Si('Suspense')
        case C:
          return Si('SuspenseList')
      }
      if (typeof S == 'object')
        switch (S.$$typeof) {
          case g:
            return Uo(S.render)
          case w:
            return Ci(S.type, O, G)
          case k: {
            var Z = S,
              de = Z._payload,
              Ue = Z._init
            try {
              return Ci(Ue(de), O, G)
            } catch {}
          }
        }
      return ''
    }
    var Ul = {},
      Vo = Oe.ReactDebugCurrentFrame
    function Io(S) {
      if (S) {
        var O = S._owner,
          G = Ci(S.type, S._source, O ? O.type : null)
        Vo.setExtraStackFrame(G)
      } else Vo.setExtraStackFrame(null)
    }
    function Vl(S, O, G, Z, de) {
      {
        var Ue = Function.call.bind(hn)
        for (var Me in S)
          if (Ue(S, Me)) {
            var We = void 0
            try {
              if (typeof S[Me] != 'function') {
                var gt = Error(
                  (Z || 'React class') +
                    ': ' +
                    G +
                    ' type `' +
                    Me +
                    '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                    typeof S[Me] +
                    '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
                )
                throw ((gt.name = 'Invariant Violation'), gt)
              }
              We = S[Me](O, Me, Z, G, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED')
            } catch (Wt) {
              We = Wt
            }
            We &&
              !(We instanceof Error) &&
              (Io(de),
              ee(
                '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
                Z || 'React class',
                G,
                Me,
                typeof We
              ),
              Io(null)),
              We instanceof Error &&
                !(We.message in Ul) &&
                ((Ul[We.message] = !0), Io(de), ee('Failed %s type: %s', G, We.message), Io(null))
          }
      }
    }
    function kt(S) {
      if (S) {
        var O = S._owner,
          G = Ci(S.type, S._source, O ? O.type : null)
        he(G)
      } else he(null)
    }
    var Qi
    Qi = !1
    function Ws() {
      if (Q.current) {
        var S = en(Q.current.type)
        if (S)
          return (
            `

Check the render method of \`` +
            S +
            '`.'
          )
      }
      return ''
    }
    function nt(S) {
      if (S !== void 0) {
        var O = S.fileName.replace(/^.*[\\\/]/, ''),
          G = S.lineNumber
        return (
          `

Check your code at ` +
          O +
          ':' +
          G +
          '.'
        )
      }
      return ''
    }
    function Il(S) {
      return S != null ? nt(S.__source) : ''
    }
    var Nn = {}
    function Xa(S) {
      var O = Ws()
      if (!O) {
        var G = typeof S == 'string' ? S : S.displayName || S.name
        G &&
          (O =
            `

Check the top-level render call using <` +
            G +
            '>.')
      }
      return O
    }
    function za(S, O) {
      if (!(!S._store || S._store.validated || S.key != null)) {
        S._store.validated = !0
        var G = Xa(O)
        if (!Nn[G]) {
          Nn[G] = !0
          var Z = ''
          S &&
            S._owner &&
            S._owner !== Q.current &&
            (Z = ' It was passed a child from ' + en(S._owner.type) + '.'),
            kt(S),
            ee(
              'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
              G,
              Z
            ),
            kt(null)
        }
      }
    }
    function Ho(S, O) {
      if (typeof S == 'object') {
        if (wt(S))
          for (var G = 0; G < S.length; G++) {
            var Z = S[G]
            Se(Z) && za(Z, O)
          }
        else if (Se(S)) S._store && (S._store.validated = !0)
        else if (S) {
          var de = z(S)
          if (typeof de == 'function' && de !== S.entries)
            for (var Ue = de.call(S), Me; !(Me = Ue.next()).done; ) Se(Me.value) && za(Me.value, O)
        }
      }
    }
    function Un(S) {
      {
        var O = S.type
        if (O == null || typeof O == 'string') return
        var G
        if (typeof O == 'function') G = O.propTypes
        else if (typeof O == 'object' && (O.$$typeof === g || O.$$typeof === w)) G = O.propTypes
        else return
        if (G) {
          var Z = en(O)
          Vl(G, S.props, 'prop', Z, S)
        } else if (O.PropTypes !== void 0 && !Qi) {
          Qi = !0
          var de = en(O)
          ee(
            'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
            de || 'Unknown'
          )
        }
        typeof O.getDefaultProps == 'function' &&
          !O.getDefaultProps.isReactClassApproved &&
          ee(
            'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.'
          )
      }
    }
    function mn(S) {
      {
        for (var O = Object.keys(S.props), G = 0; G < O.length; G++) {
          var Z = O[G]
          if (Z !== 'children' && Z !== 'key') {
            kt(S),
              ee(
                'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
                Z
              ),
              kt(null)
            break
          }
        }
        S.ref !== null &&
          (kt(S), ee('Invalid attribute `ref` supplied to `React.Fragment`.'), kt(null))
      }
    }
    function Wo(S, O, G) {
      var Z = se(S)
      if (!Z) {
        var de = ''
        ;(S === void 0 || (typeof S == 'object' && S !== null && Object.keys(S).length === 0)) &&
          (de +=
            " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
        var Ue = Il(O)
        Ue ? (de += Ue) : (de += Ws())
        var Me
        S === null
          ? (Me = 'null')
          : wt(S)
          ? (Me = 'array')
          : S !== void 0 && S.$$typeof === o
          ? ((Me = '<' + (en(S.type) || 'Unknown') + ' />'),
            (de = ' Did you accidentally export a JSX literal instead of a component?'))
          : (Me = typeof S),
          ee(
            'React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
            Me,
            de
          )
      }
      var We = ie.apply(this, arguments)
      if (We == null) return We
      if (Z) for (var gt = 2; gt < arguments.length; gt++) Ho(arguments[gt], S)
      return S === f ? mn(We) : Un(We), We
    }
    var kr = !1
    function Pn(S) {
      var O = Wo.bind(null, S)
      return (
        (O.type = S),
        kr ||
          ((kr = !0),
          ze(
            'React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.'
          )),
        Object.defineProperty(O, 'type', {
          enumerable: !1,
          get: function () {
            return (
              ze(
                'Factory.type is deprecated. Access the class directly before passing it to createFactory.'
              ),
              Object.defineProperty(this, 'type', { value: S }),
              S
            )
          },
        }),
        O
      )
    }
    function Dr(S, O, G) {
      for (var Z = be.apply(this, arguments), de = 2; de < arguments.length; de++)
        Ho(arguments[de], Z.type)
      return Un(Z), Z
    }
    function yc(S, O) {
      var G = B.transition
      B.transition = {}
      var Z = B.transition
      B.transition._updatedFibers = new Set()
      try {
        S()
      } finally {
        if (((B.transition = G), G === null && Z._updatedFibers)) {
          var de = Z._updatedFibers.size
          de > 10 &&
            ze(
              'Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.'
            ),
            Z._updatedFibers.clear()
        }
      }
    }
    var Zi = !1,
      Ji = null
    function Ys(S) {
      if (Ji === null)
        try {
          var O = ('require' + Math.random()).slice(0, 7),
            G = t && t[O]
          Ji = G.call(t, 'timers').setImmediate
        } catch {
          Ji = function (de) {
            Zi === !1 &&
              ((Zi = !0),
              typeof MessageChannel > 'u' &&
                ee(
                  'This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.'
                ))
            var Ue = new MessageChannel()
            ;(Ue.port1.onmessage = de), Ue.port2.postMessage(void 0)
          }
        }
      return Ji(S)
    }
    var wi = 0,
      Hl = !1
    function Wl(S) {
      {
        var O = wi
        wi++, j.current === null && (j.current = [])
        var G = j.isBatchingLegacy,
          Z
        try {
          if (((j.isBatchingLegacy = !0), (Z = S()), !G && j.didScheduleLegacyUpdate)) {
            var de = j.current
            de !== null && ((j.didScheduleLegacyUpdate = !1), X(de))
          }
        } catch (bn) {
          throw (Qa(O), bn)
        } finally {
          j.isBatchingLegacy = G
        }
        if (Z !== null && typeof Z == 'object' && typeof Z.then == 'function') {
          var Ue = Z,
            Me = !1,
            We = {
              then: function (bn, Ln) {
                ;(Me = !0),
                  Ue.then(
                    function (Pt) {
                      Qa(O), wi === 0 ? A(Pt, bn, Ln) : bn(Pt)
                    },
                    function (Pt) {
                      Qa(O), Ln(Pt)
                    }
                  )
              },
            }
          return (
            !Hl &&
              typeof Promise < 'u' &&
              Promise.resolve()
                .then(function () {})
                .then(function () {
                  Me ||
                    ((Hl = !0),
                    ee(
                      'You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);'
                    ))
                }),
            We
          )
        } else {
          var gt = Z
          if ((Qa(O), wi === 0)) {
            var Wt = j.current
            Wt !== null && (X(Wt), (j.current = null))
            var fn = {
              then: function (bn, Ln) {
                j.current === null ? ((j.current = []), A(gt, bn, Ln)) : bn(gt)
              },
            }
            return fn
          } else {
            var dn = {
              then: function (bn, Ln) {
                bn(gt)
              },
            }
            return dn
          }
        }
      }
    }
    function Qa(S) {
      S !== wi - 1 &&
        ee(
          'You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. '
        ),
        (wi = S)
    }
    function A(S, O, G) {
      {
        var Z = j.current
        if (Z !== null)
          try {
            X(Z),
              Ys(function () {
                Z.length === 0 ? ((j.current = null), O(S)) : A(S, O, G)
              })
          } catch (de) {
            G(de)
          }
        else O(S)
      }
    }
    var F = !1
    function X(S) {
      if (!F) {
        F = !0
        var O = 0
        try {
          for (; O < S.length; O++) {
            var G = S[O]
            do G = G(!0)
            while (G !== null)
          }
          S.length = 0
        } catch (Z) {
          throw ((S = S.slice(O + 1)), Z)
        } finally {
          F = !1
        }
      }
    }
    var Te = Wo,
      pt = Dr,
      $t = Pn,
      nn = { map: yn, forEach: Zr, count: va, toArray: Jr, only: ga }
    ;(r.Children = nn),
      (r.Component = Ke),
      (r.Fragment = f),
      (r.Profiler = p),
      (r.PureComponent = zt),
      (r.StrictMode = c),
      (r.Suspense = b),
      (r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Oe),
      (r.cloneElement = pt),
      (r.createContext = ya),
      (r.createElement = Te),
      (r.createFactory = $t),
      (r.createRef = Ct),
      (r.forwardRef = Tn),
      (r.isValidElement = Se),
      (r.lazy = ea),
      (r.memo = ve),
      (r.startTransition = yc),
      (r.unstable_act = Wl),
      (r.useCallback = fr),
      (r.useContext = dt),
      (r.useDebugValue = Zn),
      (r.useDeferredValue = Ka),
      (r.useEffect = Fn),
      (r.useId = ot),
      (r.useImperativeHandle = Bo),
      (r.useInsertionEffect = un),
      (r.useLayoutEffect = cn),
      (r.useMemo = ta),
      (r.useReducer = at),
      (r.useRef = Be),
      (r.useState = ct),
      (r.useSyncExternalStore = yi),
      (r.useTransition = $s),
      (r.version = a),
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == 'function' &&
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
  })()
})(uj, Fm)
;(function (t) {
  t.exports = Fm
})(lj)
const ca = oj(R),
  tc = ij({ __proto__: null, default: ca }, [R])
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function () {
  var t = R,
    r = Symbol.for('react.element'),
    a = Symbol.for('react.portal'),
    o = Symbol.for('react.fragment'),
    l = Symbol.for('react.strict_mode'),
    f = Symbol.for('react.profiler'),
    c = Symbol.for('react.provider'),
    p = Symbol.for('react.context'),
    h = Symbol.for('react.forward_ref'),
    m = Symbol.for('react.suspense'),
    g = Symbol.for('react.suspense_list'),
    b = Symbol.for('react.memo'),
    C = Symbol.for('react.lazy'),
    w = Symbol.for('react.offscreen'),
    k = Symbol.iterator,
    D = '@@iterator'
  function E(L) {
    if (L === null || typeof L != 'object') return null
    var se = (k && L[k]) || L[D]
    return typeof se == 'function' ? se : null
  }
  var M = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  function z(L) {
    {
      for (var se = arguments.length, ve = new Array(se > 1 ? se - 1 : 0), ke = 1; ke < se; ke++)
        ve[ke - 1] = arguments[ke]
      P('error', L, ve)
    }
  }
  function P(L, se, ve) {
    {
      var ke = M.ReactDebugCurrentFrame,
        dt = ke.getStackAddendum()
      dt !== '' && ((se += '%s'), (ve = ve.concat([dt])))
      var ct = ve.map(function (at) {
        return String(at)
      })
      ct.unshift('Warning: ' + se), Function.prototype.apply.call(console[L], console, ct)
    }
  }
  var B = !1,
    j = !1,
    Q = !1,
    Y = !1,
    ne = !1,
    he
  he = Symbol.for('react.module.reference')
  function le(L) {
    return !!(
      typeof L == 'string' ||
      typeof L == 'function' ||
      L === o ||
      L === f ||
      ne ||
      L === l ||
      L === m ||
      L === g ||
      Y ||
      L === w ||
      B ||
      j ||
      Q ||
      (typeof L == 'object' &&
        L !== null &&
        (L.$$typeof === C ||
          L.$$typeof === b ||
          L.$$typeof === c ||
          L.$$typeof === p ||
          L.$$typeof === h ||
          L.$$typeof === he ||
          L.getModuleId !== void 0))
    )
  }
  function pe(L, se, ve) {
    var ke = L.displayName
    if (ke) return ke
    var dt = se.displayName || se.name || ''
    return dt !== '' ? ve + '(' + dt + ')' : ve
  }
  function Ne(L) {
    return L.displayName || 'Context'
  }
  function me(L) {
    if (L == null) return null
    if (
      (typeof L.tag == 'number' &&
        z(
          'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
        ),
      typeof L == 'function')
    )
      return L.displayName || L.name || null
    if (typeof L == 'string') return L
    switch (L) {
      case o:
        return 'Fragment'
      case a:
        return 'Portal'
      case f:
        return 'Profiler'
      case l:
        return 'StrictMode'
      case m:
        return 'Suspense'
      case g:
        return 'SuspenseList'
    }
    if (typeof L == 'object')
      switch (L.$$typeof) {
        case p:
          var se = L
          return Ne(se) + '.Consumer'
        case c:
          var ve = L
          return Ne(ve._context) + '.Provider'
        case h:
          return pe(L, L.render, 'ForwardRef')
        case b:
          var ke = L.displayName || null
          return ke !== null ? ke : me(L.type) || 'Memo'
        case C: {
          var dt = L,
            ct = dt._payload,
            at = dt._init
          try {
            return me(at(ct))
          } catch {
            return null
          }
        }
      }
    return null
  }
  var ge = Object.assign,
    Oe = 0,
    ze,
    ee,
    ut,
    Bt,
    rt,
    qe,
    vt
  function Pe() {}
  Pe.__reactDisabledLog = !0
  function Ke() {
    {
      if (Oe === 0) {
        ;(ze = console.log),
          (ee = console.info),
          (ut = console.warn),
          (Bt = console.error),
          (rt = console.group),
          (qe = console.groupCollapsed),
          (vt = console.groupEnd)
        var L = { configurable: !0, enumerable: !0, value: Pe, writable: !0 }
        Object.defineProperties(console, {
          info: L,
          log: L,
          warn: L,
          error: L,
          group: L,
          groupCollapsed: L,
          groupEnd: L,
        })
      }
      Oe++
    }
  }
  function Mt() {
    {
      if ((Oe--, Oe === 0)) {
        var L = { configurable: !0, enumerable: !0, writable: !0 }
        Object.defineProperties(console, {
          log: ge({}, L, { value: ze }),
          info: ge({}, L, { value: ee }),
          warn: ge({}, L, { value: ut }),
          error: ge({}, L, { value: Bt }),
          group: ge({}, L, { value: rt }),
          groupCollapsed: ge({}, L, { value: qe }),
          groupEnd: ge({}, L, { value: vt }),
        })
      }
      Oe < 0 && z('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
    }
  }
  var Rt = M.ReactCurrentDispatcher,
    an
  function _t(L, se, ve) {
    {
      if (an === void 0)
        try {
          throw Error()
        } catch (dt) {
          var ke = dt.stack.trim().match(/\n( *(at )?)/)
          an = (ke && ke[1]) || ''
        }
      return (
        `
` +
        an +
        L
      )
    }
  }
  var zt = !1,
    Qt
  {
    var Ct = typeof WeakMap == 'function' ? WeakMap : Map
    Qt = new Ct()
  }
  function xe(L, se) {
    if (!L || zt) return ''
    {
      var ve = Qt.get(L)
      if (ve !== void 0) return ve
    }
    var ke
    zt = !0
    var dt = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    var ct
    ;(ct = Rt.current), (Rt.current = null), Ke()
    try {
      if (se) {
        var at = function () {
          throw Error()
        }
        if (
          (Object.defineProperty(at.prototype, 'props', {
            set: function () {
              throw Error()
            },
          }),
          typeof Reflect == 'object' && Reflect.construct)
        ) {
          try {
            Reflect.construct(at, [])
          } catch (Zn) {
            ke = Zn
          }
          Reflect.construct(L, [], at)
        } else {
          try {
            at.call()
          } catch (Zn) {
            ke = Zn
          }
          L.call(at.prototype)
        }
      } else {
        try {
          throw Error()
        } catch (Zn) {
          ke = Zn
        }
        L()
      }
    } catch (Zn) {
      if (Zn && ke && typeof Zn.stack == 'string') {
        for (
          var Be = Zn.stack.split(`
`),
            Fn = ke.stack.split(`
`),
            un = Be.length - 1,
            cn = Fn.length - 1;
          un >= 1 && cn >= 0 && Be[un] !== Fn[cn];

        )
          cn--
        for (; un >= 1 && cn >= 0; un--, cn--)
          if (Be[un] !== Fn[cn]) {
            if (un !== 1 || cn !== 1)
              do
                if ((un--, cn--, cn < 0 || Be[un] !== Fn[cn])) {
                  var fr =
                    `
` + Be[un].replace(' at new ', ' at ')
                  return (
                    L.displayName &&
                      fr.includes('<anonymous>') &&
                      (fr = fr.replace('<anonymous>', L.displayName)),
                    typeof L == 'function' && Qt.set(L, fr),
                    fr
                  )
                }
              while (un >= 1 && cn >= 0)
            break
          }
      }
    } finally {
      ;(zt = !1), (Rt.current = ct), Mt(), (Error.prepareStackTrace = dt)
    }
    var ta = L ? L.displayName || L.name : '',
      Bo = ta ? _t(ta) : ''
    return typeof L == 'function' && Qt.set(L, Bo), Bo
  }
  function wt(L, se, ve) {
    return xe(L, !1)
  }
  function Zt(L) {
    var se = L.prototype
    return !!(se && se.isReactComponent)
  }
  function Jt(L, se, ve) {
    if (L == null) return ''
    if (typeof L == 'function') return xe(L, Zt(L))
    if (typeof L == 'string') return _t(L)
    switch (L) {
      case m:
        return _t('Suspense')
      case g:
        return _t('SuspenseList')
    }
    if (typeof L == 'object')
      switch (L.$$typeof) {
        case h:
          return wt(L.render)
        case b:
          return Jt(L.type, se, ve)
        case C: {
          var ke = L,
            dt = ke._payload,
            ct = ke._init
          try {
            return Jt(ct(dt), se, ve)
          } catch {}
        }
      }
    return ''
  }
  var on = Object.prototype.hasOwnProperty,
    sn = {},
    Kn = M.ReactDebugCurrentFrame
  function Xn(L) {
    if (L) {
      var se = L._owner,
        ve = Jt(L.type, L._source, se ? se.type : null)
      Kn.setExtraStackFrame(ve)
    } else Kn.setExtraStackFrame(null)
  }
  function en(L, se, ve, ke, dt) {
    {
      var ct = Function.call.bind(on)
      for (var at in L)
        if (ct(L, at)) {
          var Be = void 0
          try {
            if (typeof L[at] != 'function') {
              var Fn = Error(
                (ke || 'React class') +
                  ': ' +
                  ve +
                  ' type `' +
                  at +
                  '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                  typeof L[at] +
                  '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
              )
              throw ((Fn.name = 'Invariant Violation'), Fn)
            }
            Be = L[at](se, at, ke, ve, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED')
          } catch (un) {
            Be = un
          }
          Be &&
            !(Be instanceof Error) &&
            (Xn(dt),
            z(
              '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
              ke || 'React class',
              ve,
              at,
              typeof Be
            ),
            Xn(null)),
            Be instanceof Error &&
              !(Be.message in sn) &&
              ((sn[Be.message] = !0), Xn(dt), z('Failed %s type: %s', ve, Be.message), Xn(null))
        }
    }
  }
  var hn = Array.isArray
  function gn(L) {
    return hn(L)
  }
  function jt(L) {
    {
      var se = typeof Symbol == 'function' && Symbol.toStringTag,
        ve = (se && L[Symbol.toStringTag]) || L.constructor.name || 'Object'
      return ve
    }
  }
  function kn(L) {
    try {
      return wn(L), !1
    } catch {
      return !0
    }
  }
  function wn(L) {
    return '' + L
  }
  function jn(L) {
    if (kn(L))
      return (
        z(
          'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
          jt(L)
        ),
        wn(L)
      )
  }
  var tn = M.ReactCurrentOwner,
    On = { key: !0, ref: !0, __self: !0, __source: !0 },
    J,
    te,
    I
  I = {}
  function ie(L) {
    if (on.call(L, 'ref')) {
      var se = Object.getOwnPropertyDescriptor(L, 'ref').get
      if (se && se.isReactWarning) return !1
    }
    return L.ref !== void 0
  }
  function ce(L) {
    if (on.call(L, 'key')) {
      var se = Object.getOwnPropertyDescriptor(L, 'key').get
      if (se && se.isReactWarning) return !1
    }
    return L.key !== void 0
  }
  function be(L, se) {
    if (typeof L.ref == 'string' && tn.current && se && tn.current.stateNode !== se) {
      var ve = me(tn.current.type)
      I[ve] ||
        (z(
          'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
          me(tn.current.type),
          L.ref
        ),
        (I[ve] = !0))
    }
  }
  function Se(L, se) {
    {
      var ve = function () {
        J ||
          ((J = !0),
          z(
            '%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            se
          ))
      }
      ;(ve.isReactWarning = !0), Object.defineProperty(L, 'key', { get: ve, configurable: !0 })
    }
  }
  function _e(L, se) {
    {
      var ve = function () {
        te ||
          ((te = !0),
          z(
            '%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
            se
          ))
      }
      ;(ve.isReactWarning = !0), Object.defineProperty(L, 'ref', { get: ve, configurable: !0 })
    }
  }
  var Ce = function (L, se, ve, ke, dt, ct, at) {
    var Be = { $$typeof: r, type: L, key: se, ref: ve, props: at, _owner: ct }
    return (
      (Be._store = {}),
      Object.defineProperty(Be._store, 'validated', {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1,
      }),
      Object.defineProperty(Be, '_self', {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ke,
      }),
      Object.defineProperty(Be, '_source', {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: dt,
      }),
      Object.freeze && (Object.freeze(Be.props), Object.freeze(Be)),
      Be
    )
  }
  function it(L, se, ve, ke, dt) {
    {
      var ct,
        at = {},
        Be = null,
        Fn = null
      ve !== void 0 && (jn(ve), (Be = '' + ve)),
        ce(se) && (jn(se.key), (Be = '' + se.key)),
        ie(se) && ((Fn = se.ref), be(se, dt))
      for (ct in se) on.call(se, ct) && !On.hasOwnProperty(ct) && (at[ct] = se[ct])
      if (L && L.defaultProps) {
        var un = L.defaultProps
        for (ct in un) at[ct] === void 0 && (at[ct] = un[ct])
      }
      if (Be || Fn) {
        var cn = typeof L == 'function' ? L.displayName || L.name || 'Unknown' : L
        Be && Se(at, cn), Fn && _e(at, cn)
      }
      return Ce(L, Be, Fn, dt, ke, tn.current, at)
    }
  }
  var $e = M.ReactCurrentOwner,
    ln = M.ReactDebugCurrentFrame
  function et(L) {
    if (L) {
      var se = L._owner,
        ve = Jt(L.type, L._source, se ? se.type : null)
      ln.setExtraStackFrame(ve)
    } else ln.setExtraStackFrame(null)
  }
  var Xe
  Xe = !1
  function En(L) {
    return typeof L == 'object' && L !== null && L.$$typeof === r
  }
  function yn() {
    {
      if ($e.current) {
        var L = me($e.current.type)
        if (L)
          return (
            `

Check the render method of \`` +
            L +
            '`.'
          )
      }
      return ''
    }
  }
  function va(L) {
    {
      if (L !== void 0) {
        var se = L.fileName.replace(/^.*[\\\/]/, ''),
          ve = L.lineNumber
        return (
          `

Check your code at ` +
          se +
          ':' +
          ve +
          '.'
        )
      }
      return ''
    }
  }
  var Zr = {}
  function Jr(L) {
    {
      var se = yn()
      if (!se) {
        var ve = typeof L == 'string' ? L : L.displayName || L.name
        ve &&
          (se =
            `

Check the top-level render call using <` +
            ve +
            '>.')
      }
      return se
    }
  }
  function ga(L, se) {
    {
      if (!L._store || L._store.validated || L.key != null) return
      L._store.validated = !0
      var ve = Jr(se)
      if (Zr[ve]) return
      Zr[ve] = !0
      var ke = ''
      L &&
        L._owner &&
        L._owner !== $e.current &&
        (ke = ' It was passed a child from ' + me(L._owner.type) + '.'),
        et(L),
        z(
          'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
          ve,
          ke
        ),
        et(null)
    }
  }
  function ya(L, se) {
    {
      if (typeof L != 'object') return
      if (gn(L))
        for (var ve = 0; ve < L.length; ve++) {
          var ke = L[ve]
          En(ke) && ga(ke, se)
        }
      else if (En(L)) L._store && (L._store.validated = !0)
      else if (L) {
        var dt = E(L)
        if (typeof dt == 'function' && dt !== L.entries)
          for (var ct = dt.call(L), at; !(at = ct.next()).done; ) En(at.value) && ga(at.value, se)
      }
    }
  }
  function Et(L) {
    {
      var se = L.type
      if (se == null || typeof se == 'string') return
      var ve
      if (typeof se == 'function') ve = se.propTypes
      else if (typeof se == 'object' && (se.$$typeof === h || se.$$typeof === b)) ve = se.propTypes
      else return
      if (ve) {
        var ke = me(se)
        en(ve, L.props, 'prop', ke, L)
      } else if (se.PropTypes !== void 0 && !Xe) {
        Xe = !0
        var dt = me(se)
        z(
          'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
          dt || 'Unknown'
        )
      }
      typeof se.getDefaultProps == 'function' &&
        !se.getDefaultProps.isReactClassApproved &&
        z(
          'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.'
        )
    }
  }
  function Mn(L) {
    {
      for (var se = Object.keys(L.props), ve = 0; ve < se.length; ve++) {
        var ke = se[ve]
        if (ke !== 'children' && ke !== 'key') {
          et(L),
            z(
              'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
              ke
            ),
            et(null)
          break
        }
      }
      L.ref !== null &&
        (et(L), z('Invalid attribute `ref` supplied to `React.Fragment`.'), et(null))
    }
  }
  function Qn(L, se, ve, ke, dt, ct) {
    {
      var at = le(L)
      if (!at) {
        var Be = ''
        ;(L === void 0 || (typeof L == 'object' && L !== null && Object.keys(L).length === 0)) &&
          (Be +=
            " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
        var Fn = va(dt)
        Fn ? (Be += Fn) : (Be += yn())
        var un
        L === null
          ? (un = 'null')
          : gn(L)
          ? (un = 'array')
          : L !== void 0 && L.$$typeof === r
          ? ((un = '<' + (me(L.type) || 'Unknown') + ' />'),
            (Be = ' Did you accidentally export a JSX literal instead of a component?'))
          : (un = typeof L),
          z(
            'React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
            un,
            Be
          )
      }
      var cn = it(L, se, ve, dt, ct)
      if (cn == null) return cn
      if (at) {
        var fr = se.children
        if (fr !== void 0)
          if (ke)
            if (gn(fr)) {
              for (var ta = 0; ta < fr.length; ta++) ya(fr[ta], L)
              Object.freeze && Object.freeze(fr)
            } else
              z(
                'React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.'
              )
          else ya(fr, L)
      }
      return L === o ? Mn(cn) : Et(cn), cn
    }
  }
  function cr(L, se, ve) {
    return Qn(L, se, ve, !0)
  }
  function jr(L, se, ve) {
    return Qn(L, se, ve, !1)
  }
  var ea = jr,
    Tn = cr
  ;(Em.Fragment = o), (Em.jsx = ea), (Em.jsxs = Tn)
})()
;(function (t) {
  t.exports = Em
})(sj)
const sv = Ed.Fragment,
  V = Ed.jsx,
  He = Ed.jsxs
function cj(t) {
  if (t.sheet) return t.sheet
  for (var r = 0; r < document.styleSheets.length; r++)
    if (document.styleSheets[r].ownerNode === t) return document.styleSheets[r]
}
function fj(t) {
  var r = document.createElement('style')
  return (
    r.setAttribute('data-emotion', t.key),
    t.nonce !== void 0 && r.setAttribute('nonce', t.nonce),
    r.appendChild(document.createTextNode('')),
    r.setAttribute('data-s', ''),
    r
  )
}
var dj = (function () {
    function t(a) {
      var o = this
      ;(this._insertTag = function (l) {
        var f
        o.tags.length === 0
          ? o.insertionPoint
            ? (f = o.insertionPoint.nextSibling)
            : o.prepend
            ? (f = o.container.firstChild)
            : (f = o.before)
          : (f = o.tags[o.tags.length - 1].nextSibling),
          o.container.insertBefore(l, f),
          o.tags.push(l)
      }),
        (this.isSpeedy = a.speedy === void 0 ? !1 : a.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = a.nonce),
        (this.key = a.key),
        (this.container = a.container),
        (this.prepend = a.prepend),
        (this.insertionPoint = a.insertionPoint),
        (this.before = null)
    }
    var r = t.prototype
    return (
      (r.hydrate = function (o) {
        o.forEach(this._insertTag)
      }),
      (r.insert = function (o) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(fj(this))
        var l = this.tags[this.tags.length - 1]
        {
          var f = o.charCodeAt(0) === 64 && o.charCodeAt(1) === 105
          f &&
            this._alreadyInsertedOrderInsensitiveRule &&
            console.error(
              `You're attempting to insert the following rule:
` +
                o +
                '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.'
            ),
            (this._alreadyInsertedOrderInsensitiveRule =
              this._alreadyInsertedOrderInsensitiveRule || !f)
        }
        if (this.isSpeedy) {
          var c = cj(l)
          try {
            c.insertRule(o, c.cssRules.length)
          } catch (p) {
            ;/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(
              o
            ) || console.error('There was a problem inserting the following rule: "' + o + '"', p)
          }
        } else l.appendChild(document.createTextNode(o))
        this.ctr++
      }),
      (r.flush = function () {
        this.tags.forEach(function (o) {
          return o.parentNode && o.parentNode.removeChild(o)
        }),
          (this.tags = []),
          (this.ctr = 0),
          (this._alreadyInsertedOrderInsensitiveRule = !1)
      }),
      t
    )
  })(),
  $r = '-ms-',
  Nm = '-moz-',
  Vt = '-webkit-',
  hx = 'comm',
  mx = 'rule',
  vx = 'decl',
  pj = '@import',
  TD = '@keyframes',
  hj = Math.abs,
  lv = String.fromCharCode,
  mj = Object.assign
function vj(t, r) {
  return _r(t, 0) ^ 45
    ? (((((((r << 2) ^ _r(t, 0)) << 2) ^ _r(t, 1)) << 2) ^ _r(t, 2)) << 2) ^ _r(t, 3)
    : 0
}
function RD(t) {
  return t.trim()
}
function gj(t, r) {
  return (t = r.exec(t)) ? t[0] : t
}
function Kt(t, r, a) {
  return t.replace(r, a)
}
function CS(t, r) {
  return t.indexOf(r)
}
function _r(t, r) {
  return t.charCodeAt(r) | 0
}
function Td(t, r, a) {
  return t.slice(r, a)
}
function Ui(t) {
  return t.length
}
function gx(t) {
  return t.length
}
function um(t, r) {
  return r.push(t), t
}
function yj(t, r) {
  return t.map(r).join('')
}
var uv = 1,
  nc = 1,
  _D = 0,
  pa = 0,
  qn = 0,
  fc = ''
function cv(t, r, a, o, l, f, c) {
  return {
    value: t,
    root: r,
    parent: a,
    type: o,
    props: l,
    children: f,
    line: uv,
    column: nc,
    length: c,
    return: '',
  }
}
function Xf(t, r) {
  return mj(cv('', null, null, '', null, null, 0), t, { length: -t.length }, r)
}
function bj() {
  return qn
}
function Sj() {
  return (qn = pa > 0 ? _r(fc, --pa) : 0), nc--, qn === 10 && ((nc = 1), uv--), qn
}
function Aa() {
  return (qn = pa < _D ? _r(fc, pa++) : 0), nc++, qn === 10 && ((nc = 1), uv++), qn
}
function Hi() {
  return _r(fc, pa)
}
function Tm() {
  return pa
}
function Yd(t, r) {
  return Td(fc, t, r)
}
function Rd(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4
    case 58:
      return 3
    case 34:
    case 39:
    case 40:
    case 91:
      return 2
    case 41:
    case 93:
      return 1
  }
  return 0
}
function kD(t) {
  return (uv = nc = 1), (_D = Ui((fc = t))), (pa = 0), []
}
function DD(t) {
  return (fc = ''), t
}
function Rm(t) {
  return RD(Yd(pa - 1, wS(t === 91 ? t + 2 : t === 40 ? t + 1 : t)))
}
function xj(t) {
  for (; (qn = Hi()) && qn < 33; ) Aa()
  return Rd(t) > 2 || Rd(qn) > 3 ? '' : ' '
}
function Cj(t, r) {
  for (; --r && Aa() && !(qn < 48 || qn > 102 || (qn > 57 && qn < 65) || (qn > 70 && qn < 97)); );
  return Yd(t, Tm() + (r < 6 && Hi() == 32 && Aa() == 32))
}
function wS(t) {
  for (; Aa(); )
    switch (qn) {
      case t:
        return pa
      case 34:
      case 39:
        t !== 34 && t !== 39 && wS(qn)
        break
      case 40:
        t === 41 && wS(t)
        break
      case 92:
        Aa()
        break
    }
  return pa
}
function wj(t, r) {
  for (; Aa() && t + qn !== 47 + 10; ) if (t + qn === 42 + 42 && Hi() === 47) break
  return '/*' + Yd(r, pa - 1) + '*' + lv(t === 47 ? t : Aa())
}
function Ej(t) {
  for (; !Rd(Hi()); ) Aa()
  return Yd(t, pa)
}
function Tj(t) {
  return DD(_m('', null, null, null, [''], (t = kD(t)), 0, [0], t))
}
function _m(t, r, a, o, l, f, c, p, h) {
  for (
    var m = 0,
      g = 0,
      b = c,
      C = 0,
      w = 0,
      k = 0,
      D = 1,
      E = 1,
      M = 1,
      z = 0,
      P = '',
      B = l,
      j = f,
      Q = o,
      Y = P;
    E;

  )
    switch (((k = z), (z = Aa()))) {
      case 40:
        if (k != 108 && _r(Y, b - 1) == 58) {
          CS((Y += Kt(Rm(z), '&', '&\f')), '&\f') != -1 && (M = -1)
          break
        }
      case 34:
      case 39:
      case 91:
        Y += Rm(z)
        break
      case 9:
      case 10:
      case 13:
      case 32:
        Y += xj(k)
        break
      case 92:
        Y += Cj(Tm() - 1, 7)
        continue
      case 47:
        switch (Hi()) {
          case 42:
          case 47:
            um(Rj(wj(Aa(), Tm()), r, a), h)
            break
          default:
            Y += '/'
        }
        break
      case 123 * D:
        p[m++] = Ui(Y) * M
      case 125 * D:
      case 59:
      case 0:
        switch (z) {
          case 0:
          case 125:
            E = 0
          case 59 + g:
            w > 0 &&
              Ui(Y) - b &&
              um(w > 32 ? xR(Y + ';', o, a, b - 1) : xR(Kt(Y, ' ', '') + ';', o, a, b - 2), h)
            break
          case 59:
            Y += ';'
          default:
            if ((um((Q = SR(Y, r, a, m, g, l, p, P, (B = []), (j = []), b)), f), z === 123))
              if (g === 0) _m(Y, r, Q, Q, B, f, b, p, j)
              else
                switch (C === 99 && _r(Y, 3) === 110 ? 100 : C) {
                  case 100:
                  case 109:
                  case 115:
                    _m(
                      t,
                      Q,
                      Q,
                      o && um(SR(t, Q, Q, 0, 0, l, p, P, l, (B = []), b), j),
                      l,
                      j,
                      b,
                      p,
                      o ? B : j
                    )
                    break
                  default:
                    _m(Y, Q, Q, Q, [''], j, 0, p, j)
                }
        }
        ;(m = g = w = 0), (D = M = 1), (P = Y = ''), (b = c)
        break
      case 58:
        ;(b = 1 + Ui(Y)), (w = k)
      default:
        if (D < 1) {
          if (z == 123) --D
          else if (z == 125 && D++ == 0 && Sj() == 125) continue
        }
        switch (((Y += lv(z)), z * D)) {
          case 38:
            M = g > 0 ? 1 : ((Y += '\f'), -1)
            break
          case 44:
            ;(p[m++] = (Ui(Y) - 1) * M), (M = 1)
            break
          case 64:
            Hi() === 45 && (Y += Rm(Aa())), (C = Hi()), (g = b = Ui((P = Y += Ej(Tm())))), z++
            break
          case 45:
            k === 45 && Ui(Y) == 2 && (D = 0)
        }
    }
  return f
}
function SR(t, r, a, o, l, f, c, p, h, m, g) {
  for (var b = l - 1, C = l === 0 ? f : [''], w = gx(C), k = 0, D = 0, E = 0; k < o; ++k)
    for (var M = 0, z = Td(t, b + 1, (b = hj((D = c[k])))), P = t; M < w; ++M)
      (P = RD(D > 0 ? C[M] + ' ' + z : Kt(z, /&\f/g, C[M]))) && (h[E++] = P)
  return cv(t, r, a, l === 0 ? mx : p, h, m, g)
}
function Rj(t, r, a) {
  return cv(t, r, a, hx, lv(bj()), Td(t, 2, -2), 0)
}
function xR(t, r, a, o) {
  return cv(t, r, a, vx, Td(t, 0, o), Td(t, o + 1, -1), o)
}
function Ku(t, r) {
  for (var a = '', o = gx(t), l = 0; l < o; l++) a += r(t[l], l, t, r) || ''
  return a
}
function _j(t, r, a, o) {
  switch (t.type) {
    case pj:
    case vx:
      return (t.return = t.return || t.value)
    case hx:
      return ''
    case TD:
      return (t.return = t.value + '{' + Ku(t.children, o) + '}')
    case mx:
      t.value = t.props.join(',')
  }
  return Ui((a = Ku(t.children, o))) ? (t.return = t.value + '{' + a + '}') : ''
}
function kj(t) {
  var r = gx(t)
  return function (a, o, l, f) {
    for (var c = '', p = 0; p < r; p++) c += t[p](a, o, l, f) || ''
    return c
  }
}
var CR = function (r) {
  var a = new WeakMap()
  return function (o) {
    if (a.has(o)) return a.get(o)
    var l = r(o)
    return a.set(o, l), l
  }
}
function AD(t) {
  var r = Object.create(null)
  return function (a) {
    return r[a] === void 0 && (r[a] = t(a)), r[a]
  }
}
var Dj = function (r, a, o) {
    for (var l = 0, f = 0; (l = f), (f = Hi()), l === 38 && f === 12 && (a[o] = 1), !Rd(f); ) Aa()
    return Yd(r, pa)
  },
  Aj = function (r, a) {
    var o = -1,
      l = 44
    do
      switch (Rd(l)) {
        case 0:
          l === 38 && Hi() === 12 && (a[o] = 1), (r[o] += Dj(pa - 1, a, o))
          break
        case 2:
          r[o] += Rm(l)
          break
        case 4:
          if (l === 44) {
            ;(r[++o] = Hi() === 58 ? '&\f' : ''), (a[o] = r[o].length)
            break
          }
        default:
          r[o] += lv(l)
      }
    while ((l = Aa()))
    return r
  },
  Oj = function (r, a) {
    return DD(Aj(kD(r), a))
  },
  wR = new WeakMap(),
  Mj = function (r) {
    if (!(r.type !== 'rule' || !r.parent || r.length < 1)) {
      for (
        var a = r.value, o = r.parent, l = r.column === o.column && r.line === o.line;
        o.type !== 'rule';

      )
        if (((o = o.parent), !o)) return
      if (!(r.props.length === 1 && a.charCodeAt(0) !== 58 && !wR.get(o)) && !l) {
        wR.set(r, !0)
        for (var f = [], c = Oj(a, f), p = o.props, h = 0, m = 0; h < c.length; h++)
          for (var g = 0; g < p.length; g++, m++)
            r.props[m] = f[h] ? c[h].replace(/&\f/g, p[g]) : p[g] + ' ' + c[h]
      }
    }
  },
  Pj = function (r) {
    if (r.type === 'decl') {
      var a = r.value
      a.charCodeAt(0) === 108 && a.charCodeAt(2) === 98 && ((r.return = ''), (r.value = ''))
    }
  },
  Lj =
    'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason',
  zj = function (r) {
    return r.type === 'comm' && r.children.indexOf(Lj) > -1
  },
  $j = function (r) {
    return function (a, o, l) {
      if (!(a.type !== 'rule' || r.compat)) {
        var f = a.value.match(/(:first|:nth|:nth-last)-child/g)
        if (f) {
          for (
            var c = a.parent === l[0], p = c ? l[0].children : l, h = p.length - 1;
            h >= 0;
            h--
          ) {
            var m = p[h]
            if (m.line < a.line) break
            if (m.column < a.column) {
              if (zj(m)) return
              break
            }
          }
          f.forEach(function (g) {
            console.error(
              'The pseudo class "' +
                g +
                '" is potentially unsafe when doing server-side rendering. Try changing it to "' +
                g.split('-child')[0] +
                '-of-type".'
            )
          })
        }
      }
    }
  },
  OD = function (r) {
    return r.type.charCodeAt(1) === 105 && r.type.charCodeAt(0) === 64
  },
  Fj = function (r, a) {
    for (var o = r - 1; o >= 0; o--) if (!OD(a[o])) return !0
    return !1
  },
  ER = function (r) {
    ;(r.type = ''), (r.value = ''), (r.return = ''), (r.children = ''), (r.props = '')
  },
  Nj = function (r, a, o) {
    OD(r) &&
      (r.parent
        ? (console.error(
            "`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."
          ),
          ER(r))
        : Fj(a, o) &&
          (console.error(
            "`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."
          ),
          ER(r)))
  }
function MD(t, r) {
  switch (vj(t, r)) {
    case 5103:
      return Vt + 'print-' + t + t
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Vt + t + t
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Vt + t + Nm + t + $r + t + t
    case 6828:
    case 4268:
      return Vt + t + $r + t + t
    case 6165:
      return Vt + t + $r + 'flex-' + t + t
    case 5187:
      return Vt + t + Kt(t, /(\w+).+(:[^]+)/, Vt + 'box-$1$2' + $r + 'flex-$1$2') + t
    case 5443:
      return Vt + t + $r + 'flex-item-' + Kt(t, /flex-|-self/, '') + t
    case 4675:
      return Vt + t + $r + 'flex-line-pack' + Kt(t, /align-content|flex-|-self/, '') + t
    case 5548:
      return Vt + t + $r + Kt(t, 'shrink', 'negative') + t
    case 5292:
      return Vt + t + $r + Kt(t, 'basis', 'preferred-size') + t
    case 6060:
      return Vt + 'box-' + Kt(t, '-grow', '') + Vt + t + $r + Kt(t, 'grow', 'positive') + t
    case 4554:
      return Vt + Kt(t, /([^-])(transform)/g, '$1' + Vt + '$2') + t
    case 6187:
      return Kt(Kt(Kt(t, /(zoom-|grab)/, Vt + '$1'), /(image-set)/, Vt + '$1'), t, '') + t
    case 5495:
    case 3959:
      return Kt(t, /(image-set\([^]*)/, Vt + '$1$`$1')
    case 4968:
      return (
        Kt(
          Kt(t, /(.+:)(flex-)?(.*)/, Vt + 'box-pack:$3' + $r + 'flex-pack:$3'),
          /s.+-b[^;]+/,
          'justify'
        ) +
        Vt +
        t +
        t
      )
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Kt(t, /(.+)-inline(.+)/, Vt + '$1$2') + t
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Ui(t) - 1 - r > 6)
        switch (_r(t, r + 1)) {
          case 109:
            if (_r(t, r + 4) !== 45) break
          case 102:
            return (
              Kt(
                t,
                /(.+:)(.+)-([^]+)/,
                '$1' + Vt + '$2-$3$1' + Nm + (_r(t, r + 3) == 108 ? '$3' : '$2-$3')
              ) + t
            )
          case 115:
            return ~CS(t, 'stretch') ? MD(Kt(t, 'stretch', 'fill-available'), r) + t : t
        }
      break
    case 4949:
      if (_r(t, r + 1) !== 115) break
    case 6444:
      switch (_r(t, Ui(t) - 3 - (~CS(t, '!important') && 10))) {
        case 107:
          return Kt(t, ':', ':' + Vt) + t
        case 101:
          return (
            Kt(
              t,
              /(.+:)([^;!]+)(;|!.+)?/,
              '$1' +
                Vt +
                (_r(t, 14) === 45 ? 'inline-' : '') +
                'box$3$1' +
                Vt +
                '$2$3$1' +
                $r +
                '$2box$3'
            ) + t
          )
      }
      break
    case 5936:
      switch (_r(t, r + 11)) {
        case 114:
          return Vt + t + $r + Kt(t, /[svh]\w+-[tblr]{2}/, 'tb') + t
        case 108:
          return Vt + t + $r + Kt(t, /[svh]\w+-[tblr]{2}/, 'tb-rl') + t
        case 45:
          return Vt + t + $r + Kt(t, /[svh]\w+-[tblr]{2}/, 'lr') + t
      }
      return Vt + t + $r + t + t
  }
  return t
}
var Bj = function (r, a, o, l) {
    if (r.length > -1 && !r.return)
      switch (r.type) {
        case vx:
          r.return = MD(r.value, r.length)
          break
        case TD:
          return Ku([Xf(r, { value: Kt(r.value, '@', '@' + Vt) })], l)
        case mx:
          if (r.length)
            return yj(r.props, function (f) {
              switch (gj(f, /(::plac\w+|:read-\w+)/)) {
                case ':read-only':
                case ':read-write':
                  return Ku([Xf(r, { props: [Kt(f, /:(read-\w+)/, ':' + Nm + '$1')] })], l)
                case '::placeholder':
                  return Ku(
                    [
                      Xf(r, { props: [Kt(f, /:(plac\w+)/, ':' + Vt + 'input-$1')] }),
                      Xf(r, { props: [Kt(f, /:(plac\w+)/, ':' + Nm + '$1')] }),
                      Xf(r, { props: [Kt(f, /:(plac\w+)/, $r + 'input-$1')] }),
                    ],
                    l
                  )
              }
              return ''
            })
      }
  },
  jj = [Bj],
  Uj = function (r) {
    var a = r.key
    if (!a)
      throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`)
    if (a === 'css') {
      var o = document.querySelectorAll('style[data-emotion]:not([data-s])')
      Array.prototype.forEach.call(o, function (D) {
        var E = D.getAttribute('data-emotion')
        E.indexOf(' ') !== -1 && (document.head.appendChild(D), D.setAttribute('data-s', ''))
      })
    }
    var l = r.stylisPlugins || jj
    if (/[^a-z-]/.test(a))
      throw new Error(
        'Emotion key must only contain lower case alphabetical characters and - but "' +
          a +
          '" was passed'
      )
    var f = {},
      c,
      p = []
    ;(c = r.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + a + ' "]'),
        function (D) {
          for (var E = D.getAttribute('data-emotion').split(' '), M = 1; M < E.length; M++)
            f[E[M]] = !0
          p.push(D)
        }
      )
    var h,
      m = [Mj, Pj]
    m.push(
      $j({
        get compat() {
          return k.compat
        },
      }),
      Nj
    )
    {
      var g,
        b = [
          _j,
          function (D) {
            D.root ||
              (D.return ? g.insert(D.return) : D.value && D.type !== hx && g.insert(D.value + '{}'))
          },
        ],
        C = kj(m.concat(l, b)),
        w = function (E) {
          return Ku(Tj(E), C)
        }
      h = function (E, M, z, P) {
        ;(g = z),
          M.map !== void 0 &&
            (g = {
              insert: function (j) {
                z.insert(j + M.map)
              },
            }),
          w(E ? E + '{' + M.styles + '}' : M.styles),
          P && (k.inserted[M.name] = !0)
      }
    }
    var k = {
      key: a,
      sheet: new dj({
        key: a,
        container: c,
        nonce: r.nonce,
        speedy: r.speedy,
        prepend: r.prepend,
        insertionPoint: r.insertionPoint,
      }),
      nonce: r.nonce,
      inserted: f,
      registered: {},
      insert: h,
    }
    return k.sheet.hydrate(p), k
  }
function Bm() {
  return (
    (Bm = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var r = 1; r < arguments.length; r++) {
            var a = arguments[r]
            for (var o in a) Object.prototype.hasOwnProperty.call(a, o) && (t[o] = a[o])
          }
          return t
        }),
    Bm.apply(this, arguments)
  )
}
var ES = {},
  Vj = {
    get exports() {
      return ES
    },
    set exports(t) {
      ES = t
    },
  },
  rn = {}
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function () {
  var t = typeof Symbol == 'function' && Symbol.for,
    r = t ? Symbol.for('react.element') : 60103,
    a = t ? Symbol.for('react.portal') : 60106,
    o = t ? Symbol.for('react.fragment') : 60107,
    l = t ? Symbol.for('react.strict_mode') : 60108,
    f = t ? Symbol.for('react.profiler') : 60114,
    c = t ? Symbol.for('react.provider') : 60109,
    p = t ? Symbol.for('react.context') : 60110,
    h = t ? Symbol.for('react.async_mode') : 60111,
    m = t ? Symbol.for('react.concurrent_mode') : 60111,
    g = t ? Symbol.for('react.forward_ref') : 60112,
    b = t ? Symbol.for('react.suspense') : 60113,
    C = t ? Symbol.for('react.suspense_list') : 60120,
    w = t ? Symbol.for('react.memo') : 60115,
    k = t ? Symbol.for('react.lazy') : 60116,
    D = t ? Symbol.for('react.block') : 60121,
    E = t ? Symbol.for('react.fundamental') : 60117,
    M = t ? Symbol.for('react.responder') : 60118,
    z = t ? Symbol.for('react.scope') : 60119
  function P(xe) {
    return (
      typeof xe == 'string' ||
      typeof xe == 'function' ||
      xe === o ||
      xe === m ||
      xe === f ||
      xe === l ||
      xe === b ||
      xe === C ||
      (typeof xe == 'object' &&
        xe !== null &&
        (xe.$$typeof === k ||
          xe.$$typeof === w ||
          xe.$$typeof === c ||
          xe.$$typeof === p ||
          xe.$$typeof === g ||
          xe.$$typeof === E ||
          xe.$$typeof === M ||
          xe.$$typeof === z ||
          xe.$$typeof === D))
    )
  }
  function B(xe) {
    if (typeof xe == 'object' && xe !== null) {
      var wt = xe.$$typeof
      switch (wt) {
        case r:
          var Zt = xe.type
          switch (Zt) {
            case h:
            case m:
            case o:
            case f:
            case l:
            case b:
              return Zt
            default:
              var Jt = Zt && Zt.$$typeof
              switch (Jt) {
                case p:
                case g:
                case k:
                case w:
                case c:
                  return Jt
                default:
                  return wt
              }
          }
        case a:
          return wt
      }
    }
  }
  var j = h,
    Q = m,
    Y = p,
    ne = c,
    he = r,
    le = g,
    pe = o,
    Ne = k,
    me = w,
    ge = a,
    Oe = f,
    ze = l,
    ee = b,
    ut = !1
  function Bt(xe) {
    return (
      ut ||
        ((ut = !0),
        console.warn(
          'The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.'
        )),
      rt(xe) || B(xe) === h
    )
  }
  function rt(xe) {
    return B(xe) === m
  }
  function qe(xe) {
    return B(xe) === p
  }
  function vt(xe) {
    return B(xe) === c
  }
  function Pe(xe) {
    return typeof xe == 'object' && xe !== null && xe.$$typeof === r
  }
  function Ke(xe) {
    return B(xe) === g
  }
  function Mt(xe) {
    return B(xe) === o
  }
  function Rt(xe) {
    return B(xe) === k
  }
  function an(xe) {
    return B(xe) === w
  }
  function _t(xe) {
    return B(xe) === a
  }
  function zt(xe) {
    return B(xe) === f
  }
  function Qt(xe) {
    return B(xe) === l
  }
  function Ct(xe) {
    return B(xe) === b
  }
  ;(rn.AsyncMode = j),
    (rn.ConcurrentMode = Q),
    (rn.ContextConsumer = Y),
    (rn.ContextProvider = ne),
    (rn.Element = he),
    (rn.ForwardRef = le),
    (rn.Fragment = pe),
    (rn.Lazy = Ne),
    (rn.Memo = me),
    (rn.Portal = ge),
    (rn.Profiler = Oe),
    (rn.StrictMode = ze),
    (rn.Suspense = ee),
    (rn.isAsyncMode = Bt),
    (rn.isConcurrentMode = rt),
    (rn.isContextConsumer = qe),
    (rn.isContextProvider = vt),
    (rn.isElement = Pe),
    (rn.isForwardRef = Ke),
    (rn.isFragment = Mt),
    (rn.isLazy = Rt),
    (rn.isMemo = an),
    (rn.isPortal = _t),
    (rn.isProfiler = zt),
    (rn.isStrictMode = Qt),
    (rn.isSuspense = Ct),
    (rn.isValidElementType = P),
    (rn.typeOf = B)
})()
;(function (t) {
  t.exports = rn
})(Vj)
var PD = ES,
  Ij = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 },
  Hj = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 },
  LD = {}
LD[PD.ForwardRef] = Ij
LD[PD.Memo] = Hj
var Wj = !0
function yx(t, r, a) {
  var o = ''
  return (
    a.split(' ').forEach(function (l) {
      t[l] !== void 0 ? r.push(t[l] + ';') : (o += l + ' ')
    }),
    o
  )
}
var fv = function (r, a, o) {
    var l = r.key + '-' + a.name
    ;(o === !1 || Wj === !1) && r.registered[l] === void 0 && (r.registered[l] = a.styles)
  },
  dv = function (r, a, o) {
    fv(r, a, o)
    var l = r.key + '-' + a.name
    if (r.inserted[a.name] === void 0) {
      var f = a
      do r.insert(a === f ? '.' + l : '', f, r.sheet, !0), (f = f.next)
      while (f !== void 0)
    }
  }
function Yj(t) {
  for (var r = 0, a, o = 0, l = t.length; l >= 4; ++o, l -= 4)
    (a =
      (t.charCodeAt(o) & 255) |
      ((t.charCodeAt(++o) & 255) << 8) |
      ((t.charCodeAt(++o) & 255) << 16) |
      ((t.charCodeAt(++o) & 255) << 24)),
      (a = (a & 65535) * 1540483477 + (((a >>> 16) * 59797) << 16)),
      (a ^= a >>> 24),
      (r =
        ((a & 65535) * 1540483477 + (((a >>> 16) * 59797) << 16)) ^
        ((r & 65535) * 1540483477 + (((r >>> 16) * 59797) << 16)))
  switch (l) {
    case 3:
      r ^= (t.charCodeAt(o + 2) & 255) << 16
    case 2:
      r ^= (t.charCodeAt(o + 1) & 255) << 8
    case 1:
      ;(r ^= t.charCodeAt(o) & 255), (r = (r & 65535) * 1540483477 + (((r >>> 16) * 59797) << 16))
  }
  return (
    (r ^= r >>> 13),
    (r = (r & 65535) * 1540483477 + (((r >>> 16) * 59797) << 16)),
    ((r ^ (r >>> 15)) >>> 0).toString(36)
  )
}
var Gj = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  TR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`,
  qj =
    "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).",
  Kj = /[A-Z]|^ms/g,
  zD = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  bx = function (r) {
    return r.charCodeAt(1) === 45
  },
  RR = function (r) {
    return r != null && typeof r != 'boolean'
  },
  N0 = AD(function (t) {
    return bx(t) ? t : t.replace(Kj, '-$&').toLowerCase()
  }),
  jm = function (r, a) {
    switch (r) {
      case 'animation':
      case 'animationName':
        if (typeof a == 'string')
          return a.replace(zD, function (o, l, f) {
            return (Vi = { name: l, styles: f, next: Vi }), l
          })
    }
    return Gj[r] !== 1 && !bx(r) && typeof a == 'number' && a !== 0 ? a + 'px' : a
  }
{
  var Xj =
      /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/,
    Qj = ['normal', 'none', 'initial', 'inherit', 'unset'],
    Zj = jm,
    Jj = /^-ms-/,
    eU = /-(.)/g,
    _R = {}
  jm = function (r, a) {
    if (
      r === 'content' &&
      (typeof a != 'string' ||
        (Qj.indexOf(a) === -1 &&
          !Xj.test(a) &&
          (a.charAt(0) !== a.charAt(a.length - 1) || (a.charAt(0) !== '"' && a.charAt(0) !== "'"))))
    )
      throw new Error(
        "You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" +
          a +
          '"\'`'
      )
    var o = Zj(r, a)
    return (
      o !== '' &&
        !bx(r) &&
        r.indexOf('-') !== -1 &&
        _R[r] === void 0 &&
        ((_R[r] = !0),
        console.error(
          'Using kebab-case for css properties in objects is not supported. Did you mean ' +
            r.replace(Jj, 'ms-').replace(eU, function (l, f) {
              return f.toUpperCase()
            }) +
            '?'
        )),
      o
    )
  }
}
var $D =
  'Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.'
function _d(t, r, a) {
  if (a == null) return ''
  if (a.__emotion_styles !== void 0) {
    if (a.toString() === 'NO_COMPONENT_SELECTOR') throw new Error($D)
    return a
  }
  switch (typeof a) {
    case 'boolean':
      return ''
    case 'object': {
      if (a.anim === 1) return (Vi = { name: a.name, styles: a.styles, next: Vi }), a.name
      if (a.styles !== void 0) {
        var o = a.next
        if (o !== void 0)
          for (; o !== void 0; ) (Vi = { name: o.name, styles: o.styles, next: Vi }), (o = o.next)
        var l = a.styles + ';'
        return a.map !== void 0 && (l += a.map), l
      }
      return tU(t, r, a)
    }
    case 'function': {
      if (t !== void 0) {
        var f = Vi,
          c = a(t)
        return (Vi = f), _d(t, r, c)
      } else
        console.error(
          "Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`"
        )
      break
    }
    case 'string':
      {
        var p = [],
          h = a.replace(zD, function (g, b, C) {
            var w = 'animation' + p.length
            return (
              p.push(
                'const ' + w + ' = keyframes`' + C.replace(/^@keyframes animation-\w+/, '') + '`'
              ),
              '${' + w + '}'
            )
          })
        p.length &&
          console.error(
            '`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n' +
              [].concat(p, ['`' + h + '`']).join(`
`) +
              `

You should wrap it with \`css\` like this:

` +
              ('css`' + h + '`')
          )
      }
      break
  }
  if (r == null) return a
  var m = r[a]
  return m !== void 0 ? m : a
}
function tU(t, r, a) {
  var o = ''
  if (Array.isArray(a)) for (var l = 0; l < a.length; l++) o += _d(t, r, a[l]) + ';'
  else
    for (var f in a) {
      var c = a[f]
      if (typeof c != 'object')
        r != null && r[c] !== void 0
          ? (o += f + '{' + r[c] + '}')
          : RR(c) && (o += N0(f) + ':' + jm(f, c) + ';')
      else {
        if (f === 'NO_COMPONENT_SELECTOR') throw new Error($D)
        if (Array.isArray(c) && typeof c[0] == 'string' && (r == null || r[c[0]] === void 0))
          for (var p = 0; p < c.length; p++) RR(c[p]) && (o += N0(f) + ':' + jm(f, c[p]) + ';')
        else {
          var h = _d(t, r, c)
          switch (f) {
            case 'animation':
            case 'animationName': {
              o += N0(f) + ':' + h + ';'
              break
            }
            default:
              f === 'undefined' && console.error(qj), (o += f + '{' + h + '}')
          }
        }
      }
    }
  return o
}
var kR = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
  FD
FD = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g
var Vi,
  rc = function (r, a, o) {
    if (r.length === 1 && typeof r[0] == 'object' && r[0] !== null && r[0].styles !== void 0)
      return r[0]
    var l = !0,
      f = ''
    Vi = void 0
    var c = r[0]
    c == null || c.raw === void 0
      ? ((l = !1), (f += _d(o, a, c)))
      : (c[0] === void 0 && console.error(TR), (f += c[0]))
    for (var p = 1; p < r.length; p++)
      (f += _d(o, a, r[p])), l && (c[p] === void 0 && console.error(TR), (f += c[p]))
    var h
    ;(f = f.replace(FD, function (C) {
      return (h = C), ''
    })),
      (kR.lastIndex = 0)
    for (var m = '', g; (g = kR.exec(f)) !== null; ) m += '-' + g[1]
    var b = Yj(f) + m
    return {
      name: b,
      styles: f,
      map: h,
      next: Vi,
      toString: function () {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."
      },
    }
  },
  nU = function (r) {
    return r()
  },
  ND = tc['useInsertionEffect'] ? tc['useInsertionEffect'] : !1,
  Sx = ND || nU,
  DR = ND || R.useLayoutEffect,
  rU = {}.hasOwnProperty,
  xx = R.createContext(typeof HTMLElement < 'u' ? Uj({ key: 'css' }) : null)
xx.displayName = 'EmotionCacheContext'
xx.Provider
var pv = function (r) {
    return R.forwardRef(function (a, o) {
      var l = R.useContext(xx)
      return r(a, l, o)
    })
  },
  ks = R.createContext({})
ks.displayName = 'EmotionThemeContext'
var aU = function (r, a) {
    if (typeof a == 'function') {
      var o = a(r)
      if (o == null || typeof o != 'object' || Array.isArray(o))
        throw new Error(
          '[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!'
        )
      return o
    }
    if (a == null || typeof a != 'object' || Array.isArray(a))
      throw new Error('[ThemeProvider] Please make your theme prop a plain object')
    return Bm({}, r, a)
  },
  iU = CR(function (t) {
    return CR(function (r) {
      return aU(t, r)
    })
  }),
  oU = function (r) {
    var a = R.useContext(ks)
    return (
      r.theme !== a && (a = iU(a)(r.theme)), R.createElement(ks.Provider, { value: a }, r.children)
    )
  },
  AR = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__',
  OR = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__',
  sU = function (r) {
    var a = r.cache,
      o = r.serialized,
      l = r.isStringTag
    return (
      fv(a, o, l),
      Sx(function () {
        return dv(a, o, l)
      }),
      null
    )
  },
  lU = pv(function (t, r, a) {
    var o = t.css
    typeof o == 'string' && r.registered[o] !== void 0 && (o = r.registered[o])
    var l = t[AR],
      f = [o],
      c = ''
    typeof t.className == 'string'
      ? (c = yx(r.registered, f, t.className))
      : t.className != null && (c = t.className + ' ')
    var p = rc(f, void 0, R.useContext(ks))
    if (p.name.indexOf('-') === -1) {
      var h = t[OR]
      h && (p = rc([p, 'label:' + h + ';']))
    }
    c += r.key + '-' + p.name
    var m = {}
    for (var g in t) rU.call(t, g) && g !== 'css' && g !== AR && g !== OR && (m[g] = t[g])
    return (
      (m.ref = a),
      (m.className = c),
      R.createElement(
        R.Fragment,
        null,
        R.createElement(sU, { cache: r, serialized: p, isStringTag: typeof l == 'string' }),
        R.createElement(l, m)
      )
    )
  })
lU.displayName = 'EmotionCssPropInternal'
var uU = {
    'name': '@emotion/react',
    'version': '11.10.6',
    'main': 'dist/emotion-react.cjs.js',
    'module': 'dist/emotion-react.esm.js',
    'browser': { './dist/emotion-react.esm.js': './dist/emotion-react.browser.esm.js' },
    'exports': {
      '.': {
        module: {
          worker: './dist/emotion-react.worker.esm.js',
          browser: './dist/emotion-react.browser.esm.js',
          default: './dist/emotion-react.esm.js',
        },
        default: './dist/emotion-react.cjs.js',
      },
      './jsx-runtime': {
        module: {
          worker: './jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js',
          browser: './jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js',
          default: './jsx-runtime/dist/emotion-react-jsx-runtime.esm.js',
        },
        default: './jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js',
      },
      './_isolated-hnrs': {
        module: {
          worker: './_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js',
          browser: './_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js',
          default: './_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js',
        },
        default: './_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js',
      },
      './jsx-dev-runtime': {
        module: {
          worker: './jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js',
          browser: './jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js',
          default: './jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js',
        },
        default: './jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js',
      },
      './package.json': './package.json',
      './types/css-prop': './types/css-prop.d.ts',
      './macro': './macro.js',
    },
    'types': 'types/index.d.ts',
    'files': [
      'src',
      'dist',
      'jsx-runtime',
      'jsx-dev-runtime',
      '_isolated-hnrs',
      'types/*.d.ts',
      'macro.js',
      'macro.d.ts',
      'macro.js.flow',
    ],
    'sideEffects': !1,
    'author': 'Emotion Contributors',
    'license': 'MIT',
    'scripts': { 'test:typescript': 'dtslint types' },
    'dependencies': {
      '@babel/runtime': '^7.18.3',
      '@emotion/babel-plugin': '^11.10.6',
      '@emotion/cache': '^11.10.5',
      '@emotion/serialize': '^1.1.1',
      '@emotion/use-insertion-effect-with-fallbacks': '^1.0.0',
      '@emotion/utils': '^1.2.0',
      '@emotion/weak-memoize': '^0.3.0',
      'hoist-non-react-statics': '^3.3.1',
    },
    'peerDependencies': { react: '>=16.8.0' },
    'peerDependenciesMeta': { '@types/react': { optional: !0 } },
    'devDependencies': {
      '@definitelytyped/dtslint': '0.0.112',
      '@emotion/css': '11.10.6',
      '@emotion/css-prettifier': '1.1.1',
      '@emotion/server': '11.10.0',
      '@emotion/styled': '11.10.6',
      'html-tag-names': '^1.1.2',
      'react': '16.14.0',
      'svg-tag-names': '^1.1.1',
      'typescript': '^4.5.5',
    },
    'repository': 'https://github.com/emotion-js/emotion/tree/main/packages/react',
    'publishConfig': { access: 'public' },
    'umd:main': 'dist/emotion-react.umd.min.js',
    'preconstruct': {
      entrypoints: [
        './index.js',
        './jsx-runtime.js',
        './jsx-dev-runtime.js',
        './_isolated-hnrs.js',
      ],
      umdName: 'emotionReact',
      exports: {
        envConditions: ['browser', 'worker'],
        extra: { './types/css-prop': './types/css-prop.d.ts', './macro': './macro.js' },
      },
    },
  },
  MR = !1,
  Gd = pv(function (t, r) {
    !MR &&
      (t.className || t.css) &&
      (console.error(
        "It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"
      ),
      (MR = !0))
    var a = t.styles,
      o = rc([a], void 0, R.useContext(ks)),
      l = R.useRef()
    return (
      DR(
        function () {
          var f = r.key + '-global',
            c = new r.sheet.constructor({
              key: f,
              nonce: r.sheet.nonce,
              container: r.sheet.container,
              speedy: r.sheet.isSpeedy,
            }),
            p = !1,
            h = document.querySelector('style[data-emotion="' + f + ' ' + o.name + '"]')
          return (
            r.sheet.tags.length && (c.before = r.sheet.tags[0]),
            h !== null && ((p = !0), h.setAttribute('data-emotion', f), c.hydrate([h])),
            (l.current = [c, p]),
            function () {
              c.flush()
            }
          )
        },
        [r]
      ),
      DR(
        function () {
          var f = l.current,
            c = f[0],
            p = f[1]
          if (p) {
            f[1] = !1
            return
          }
          if ((o.next !== void 0 && dv(r, o.next, !0), c.tags.length)) {
            var h = c.tags[c.tags.length - 1].nextElementSibling
            ;(c.before = h), c.flush()
          }
          r.insert('', o, c, !1)
        },
        [r, o.name]
      ),
      null
    )
  })
Gd.displayName = 'EmotionGlobal'
function cU() {
  for (var t = arguments.length, r = new Array(t), a = 0; a < t; a++) r[a] = arguments[a]
  return rc(r)
}
var fU = function () {
    var r = cU.apply(void 0, arguments),
      a = 'animation-' + r.name
    return {
      name: a,
      styles: '@keyframes ' + a + '{' + r.styles + '}',
      anim: 1,
      toString: function () {
        return '_EMO_' + this.name + '_' + this.styles + '_EMO_'
      },
    }
  },
  dU = function t(r) {
    for (var a = r.length, o = 0, l = ''; o < a; o++) {
      var f = r[o]
      if (f != null) {
        var c = void 0
        switch (typeof f) {
          case 'boolean':
            break
          case 'object': {
            if (Array.isArray(f)) c = t(f)
            else {
              f.styles !== void 0 &&
                f.name !== void 0 &&
                console.error(
                  'You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.'
                ),
                (c = '')
              for (var p in f) f[p] && p && (c && (c += ' '), (c += p))
            }
            break
          }
          default:
            c = f
        }
        c && (l && (l += ' '), (l += c))
      }
    }
    return l
  }
function pU(t, r, a) {
  var o = [],
    l = yx(t, o, a)
  return o.length < 2 ? a : l + r(o)
}
var hU = function (r) {
    var a = r.cache,
      o = r.serializedArr
    return (
      Sx(function () {
        for (var l = 0; l < o.length; l++) dv(a, o[l], !1)
      }),
      null
    )
  },
  mU = pv(function (t, r) {
    var a = !1,
      o = [],
      l = function () {
        if (a) throw new Error('css can only be used during render')
        for (var m = arguments.length, g = new Array(m), b = 0; b < m; b++) g[b] = arguments[b]
        var C = rc(g, r.registered)
        return o.push(C), fv(r, C, !1), r.key + '-' + C.name
      },
      f = function () {
        if (a) throw new Error('cx can only be used during render')
        for (var m = arguments.length, g = new Array(m), b = 0; b < m; b++) g[b] = arguments[b]
        return pU(r.registered, l, dU(g))
      },
      c = { css: l, cx: f, theme: R.useContext(ks) },
      p = t.children(c)
    return (
      (a = !0),
      R.createElement(R.Fragment, null, R.createElement(hU, { cache: r, serializedArr: o }), p)
    )
  })
mU.displayName = 'EmotionClassNames'
{
  var PR = !0,
    vU = typeof jest < 'u' || typeof vi < 'u'
  if (PR && !vU) {
    var LR = typeof globalThis < 'u' ? globalThis : PR ? window : global,
      zR = '__EMOTION_REACT_' + uU.version.split('.')[0] + '__'
    LR[zR] &&
      console.warn(
        'You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.'
      ),
      (LR[zR] = !0)
  }
}
var BD = String.raw,
  jD = BD`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`,
  gU = () => V(Gd, { styles: jD }),
  yU = ({ scope: t = '' }) =>
    V(Gd, {
      styles: BD`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${t} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${t} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${t} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${t} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${t} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${t} :where(b, strong) {
        font-weight: bold;
      }

      ${t} small {
        font-size: 80%;
      }

      ${t} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${t} sub {
        bottom: -0.25em;
      }

      ${t} sup {
        top: -0.5em;
      }

      ${t} img {
        border-style: none;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${t} :where(button, input) {
        overflow: visible;
      }

      ${t} :where(button, select) {
        text-transform: none;
      }

      ${t} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${t} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${t} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${t} progress {
        vertical-align: baseline;
      }

      ${t} textarea {
        overflow: auto;
      }

      ${t} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${t} :where(
          [type="number"]::-webkit-inner-spin-button,
          [type="number"]::-webkit-outer-spin-button
        ) {
        -webkit-appearance: none !important;
      }

      ${t} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${t} [type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${t} [type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${t} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${t} details {
        display: block;
      }

      ${t} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${t} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${t} button {
        background: transparent;
        padding: 0;
      }

      ${t} fieldset {
        margin: 0;
        padding: 0;
      }

      ${t} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${t} textarea {
        resize: vertical;
      }

      ${t} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${t} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${t} table {
        border-collapse: collapse;
      }

      ${t} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${t} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${t} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${t} select::-ms-expand {
        display: none;
      }

      ${jD}
    `,
    })
function bU(t, r) {
  return `${t} returned \`undefined\`. Seems you forgot to wrap component within ${r}`
}
function zo(t = {}) {
  const {
      name: r,
      strict: a = !0,
      hookName: o = 'useContext',
      providerName: l = 'Provider',
      errorMessage: f,
      defaultValue: c,
    } = t,
    p = R.createContext(c)
  p.displayName = r
  function h() {
    var m
    const g = R.useContext(p)
    if (!g && a) {
      const b = new Error(f ?? bU(o, l))
      throw (
        ((b.name = 'ContextError'), (m = Error.captureStackTrace) == null || m.call(Error, b, h), b)
      )
    }
    return g
  }
  return [p.Provider, h, p]
}
var [SU, xU] = zo({ strict: !1, name: 'PortalManagerContext' })
function UD(t) {
  const { children: r, zIndex: a } = t
  return V(SU, { value: { zIndex: a }, children: r })
}
UD.displayName = 'PortalManager'
var kd = globalThis != null && globalThis.document ? R.useLayoutEffect : R.useEffect,
  Dd = {},
  CU = {
    get exports() {
      return Dd
    },
    set exports(t) {
      Dd = t
    },
  },
  ka = {},
  TS = {},
  wU = {
    get exports() {
      return TS
    },
    set exports(t) {
      TS = t
    },
  },
  VD = {}
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (t) {
  ;(function () {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == 'function' &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
    var r = !1,
      a = !1,
      o = 5
    function l(I, ie) {
      var ce = I.length
      I.push(ie), p(I, ie, ce)
    }
    function f(I) {
      return I.length === 0 ? null : I[0]
    }
    function c(I) {
      if (I.length === 0) return null
      var ie = I[0],
        ce = I.pop()
      return ce !== ie && ((I[0] = ce), h(I, ce, 0)), ie
    }
    function p(I, ie, ce) {
      for (var be = ce; be > 0; ) {
        var Se = (be - 1) >>> 1,
          _e = I[Se]
        if (m(_e, ie) > 0) (I[Se] = ie), (I[be] = _e), (be = Se)
        else return
      }
    }
    function h(I, ie, ce) {
      for (var be = ce, Se = I.length, _e = Se >>> 1; be < _e; ) {
        var Ce = (be + 1) * 2 - 1,
          it = I[Ce],
          $e = Ce + 1,
          ln = I[$e]
        if (m(it, ie) < 0)
          $e < Se && m(ln, it) < 0
            ? ((I[be] = ln), (I[$e] = ie), (be = $e))
            : ((I[be] = it), (I[Ce] = ie), (be = Ce))
        else if ($e < Se && m(ln, ie) < 0) (I[be] = ln), (I[$e] = ie), (be = $e)
        else return
      }
    }
    function m(I, ie) {
      var ce = I.sortIndex - ie.sortIndex
      return ce !== 0 ? ce : I.id - ie.id
    }
    var g = 1,
      b = 2,
      C = 3,
      w = 4,
      k = 5
    function D(I, ie) {}
    var E = typeof performance == 'object' && typeof performance.now == 'function'
    if (E) {
      var M = performance
      t.unstable_now = function () {
        return M.now()
      }
    } else {
      var z = Date,
        P = z.now()
      t.unstable_now = function () {
        return z.now() - P
      }
    }
    var B = 1073741823,
      j = -1,
      Q = 250,
      Y = 5e3,
      ne = 1e4,
      he = B,
      le = [],
      pe = [],
      Ne = 1,
      me = null,
      ge = C,
      Oe = !1,
      ze = !1,
      ee = !1,
      ut = typeof setTimeout == 'function' ? setTimeout : null,
      Bt = typeof clearTimeout == 'function' ? clearTimeout : null,
      rt = typeof setImmediate < 'u' ? setImmediate : null
    typeof navigator < 'u' &&
      navigator.scheduling !== void 0 &&
      navigator.scheduling.isInputPending !== void 0 &&
      navigator.scheduling.isInputPending.bind(navigator.scheduling)
    function qe(I) {
      for (var ie = f(pe); ie !== null; ) {
        if (ie.callback === null) c(pe)
        else if (ie.startTime <= I) c(pe), (ie.sortIndex = ie.expirationTime), l(le, ie)
        else return
        ie = f(pe)
      }
    }
    function vt(I) {
      if (((ee = !1), qe(I), !ze))
        if (f(le) !== null) (ze = !0), jn(Pe)
        else {
          var ie = f(pe)
          ie !== null && tn(vt, ie.startTime - I)
        }
    }
    function Pe(I, ie) {
      ;(ze = !1), ee && ((ee = !1), On()), (Oe = !0)
      var ce = ge
      try {
        var be
        if (!a) return Ke(I, ie)
      } finally {
        ;(me = null), (ge = ce), (Oe = !1)
      }
    }
    function Ke(I, ie) {
      var ce = ie
      for (qe(ce), me = f(le); me !== null && !r && !(me.expirationTime > ce && (!I || Xn())); ) {
        var be = me.callback
        if (typeof be == 'function') {
          ;(me.callback = null), (ge = me.priorityLevel)
          var Se = me.expirationTime <= ce,
            _e = be(Se)
          ;(ce = t.unstable_now()),
            typeof _e == 'function' ? (me.callback = _e) : me === f(le) && c(le),
            qe(ce)
        } else c(le)
        me = f(le)
      }
      if (me !== null) return !0
      var Ce = f(pe)
      return Ce !== null && tn(vt, Ce.startTime - ce), !1
    }
    function Mt(I, ie) {
      switch (I) {
        case g:
        case b:
        case C:
        case w:
        case k:
          break
        default:
          I = C
      }
      var ce = ge
      ge = I
      try {
        return ie()
      } finally {
        ge = ce
      }
    }
    function Rt(I) {
      var ie
      switch (ge) {
        case g:
        case b:
        case C:
          ie = C
          break
        default:
          ie = ge
          break
      }
      var ce = ge
      ge = ie
      try {
        return I()
      } finally {
        ge = ce
      }
    }
    function an(I) {
      var ie = ge
      return function () {
        var ce = ge
        ge = ie
        try {
          return I.apply(this, arguments)
        } finally {
          ge = ce
        }
      }
    }
    function _t(I, ie, ce) {
      var be = t.unstable_now(),
        Se
      if (typeof ce == 'object' && ce !== null) {
        var _e = ce.delay
        typeof _e == 'number' && _e > 0 ? (Se = be + _e) : (Se = be)
      } else Se = be
      var Ce
      switch (I) {
        case g:
          Ce = j
          break
        case b:
          Ce = Q
          break
        case k:
          Ce = he
          break
        case w:
          Ce = ne
          break
        case C:
        default:
          Ce = Y
          break
      }
      var it = Se + Ce,
        $e = {
          id: Ne++,
          callback: ie,
          priorityLevel: I,
          startTime: Se,
          expirationTime: it,
          sortIndex: -1,
        }
      return (
        Se > be
          ? (($e.sortIndex = Se),
            l(pe, $e),
            f(le) === null && $e === f(pe) && (ee ? On() : (ee = !0), tn(vt, Se - be)))
          : (($e.sortIndex = it), l(le, $e), !ze && !Oe && ((ze = !0), jn(Pe))),
        $e
      )
    }
    function zt() {}
    function Qt() {
      !ze && !Oe && ((ze = !0), jn(Pe))
    }
    function Ct() {
      return f(le)
    }
    function xe(I) {
      I.callback = null
    }
    function wt() {
      return ge
    }
    var Zt = !1,
      Jt = null,
      on = -1,
      sn = o,
      Kn = -1
    function Xn() {
      var I = t.unstable_now() - Kn
      return !(I < sn)
    }
    function en() {}
    function hn(I) {
      if (I < 0 || I > 125) {
        console.error(
          'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
        )
        return
      }
      I > 0 ? (sn = Math.floor(1e3 / I)) : (sn = o)
    }
    var gn = function () {
        if (Jt !== null) {
          var I = t.unstable_now()
          Kn = I
          var ie = !0,
            ce = !0
          try {
            ce = Jt(ie, I)
          } finally {
            ce ? jt() : ((Zt = !1), (Jt = null))
          }
        } else Zt = !1
      },
      jt
    if (typeof rt == 'function')
      jt = function () {
        rt(gn)
      }
    else if (typeof MessageChannel < 'u') {
      var kn = new MessageChannel(),
        wn = kn.port2
      ;(kn.port1.onmessage = gn),
        (jt = function () {
          wn.postMessage(null)
        })
    } else
      jt = function () {
        ut(gn, 0)
      }
    function jn(I) {
      ;(Jt = I), Zt || ((Zt = !0), jt())
    }
    function tn(I, ie) {
      on = ut(function () {
        I(t.unstable_now())
      }, ie)
    }
    function On() {
      Bt(on), (on = -1)
    }
    var J = en,
      te = null
    ;(t.unstable_IdlePriority = k),
      (t.unstable_ImmediatePriority = g),
      (t.unstable_LowPriority = w),
      (t.unstable_NormalPriority = C),
      (t.unstable_Profiling = te),
      (t.unstable_UserBlockingPriority = b),
      (t.unstable_cancelCallback = xe),
      (t.unstable_continueExecution = Qt),
      (t.unstable_forceFrameRate = hn),
      (t.unstable_getCurrentPriorityLevel = wt),
      (t.unstable_getFirstCallbackNode = Ct),
      (t.unstable_next = Rt),
      (t.unstable_pauseExecution = zt),
      (t.unstable_requestPaint = J),
      (t.unstable_runWithPriority = Mt),
      (t.unstable_scheduleCallback = _t),
      (t.unstable_shouldYield = Xn),
      (t.unstable_wrapCallback = an),
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == 'function' &&
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
  })()
})(VD)
;(function (t) {
  t.exports = VD
})(wU)
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function () {
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == 'function' &&
    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
  var t = R,
    r = TS,
    a = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    o = !1
  function l(e) {
    o = e
  }
  function f(e) {
    if (!o) {
      for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
        i[s - 1] = arguments[s]
      p('warn', e, i)
    }
  }
  function c(e) {
    if (!o) {
      for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
        i[s - 1] = arguments[s]
      p('error', e, i)
    }
  }
  function p(e, n, i) {
    {
      var s = a.ReactDebugCurrentFrame,
        u = s.getStackAddendum()
      u !== '' && ((n += '%s'), (i = i.concat([u])))
      var d = i.map(function (v) {
        return String(v)
      })
      d.unshift('Warning: ' + n), Function.prototype.apply.call(console[e], console, d)
    }
  }
  var h = 0,
    m = 1,
    g = 2,
    b = 3,
    C = 4,
    w = 5,
    k = 6,
    D = 7,
    E = 8,
    M = 9,
    z = 10,
    P = 11,
    B = 12,
    j = 13,
    Q = 14,
    Y = 15,
    ne = 16,
    he = 17,
    le = 18,
    pe = 19,
    Ne = 21,
    me = 22,
    ge = 23,
    Oe = 24,
    ze = 25,
    ee = !0,
    ut = !1,
    Bt = !1,
    rt = !1,
    qe = !1,
    vt = !0,
    Pe = !1,
    Ke = !1,
    Mt = !0,
    Rt = !0,
    an = !0,
    _t = new Set(),
    zt = {},
    Qt = {}
  function Ct(e, n) {
    xe(e, n), xe(e + 'Capture', n)
  }
  function xe(e, n) {
    zt[e] &&
      c(
        'EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.',
        e
      ),
      (zt[e] = n)
    {
      var i = e.toLowerCase()
      ;(Qt[i] = e), e === 'onDoubleClick' && (Qt.ondblclick = e)
    }
    for (var s = 0; s < n.length; s++) _t.add(n[s])
  }
  var wt =
      typeof window < 'u' &&
      typeof window.document < 'u' &&
      typeof window.document.createElement < 'u',
    Zt = Object.prototype.hasOwnProperty
  function Jt(e) {
    {
      var n = typeof Symbol == 'function' && Symbol.toStringTag,
        i = (n && e[Symbol.toStringTag]) || e.constructor.name || 'Object'
      return i
    }
  }
  function on(e) {
    try {
      return sn(e), !1
    } catch {
      return !0
    }
  }
  function sn(e) {
    return '' + e
  }
  function Kn(e, n) {
    if (on(e))
      return (
        c(
          'The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.',
          n,
          Jt(e)
        ),
        sn(e)
      )
  }
  function Xn(e) {
    if (on(e))
      return (
        c(
          'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
          Jt(e)
        ),
        sn(e)
      )
  }
  function en(e, n) {
    if (on(e))
      return (
        c(
          'The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.',
          n,
          Jt(e)
        ),
        sn(e)
      )
  }
  function hn(e, n) {
    if (on(e))
      return (
        c(
          'The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.',
          n,
          Jt(e)
        ),
        sn(e)
      )
  }
  function gn(e) {
    if (on(e))
      return (
        c(
          'The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.',
          Jt(e)
        ),
        sn(e)
      )
  }
  function jt(e) {
    if (on(e))
      return (
        c(
          'Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.',
          Jt(e)
        ),
        sn(e)
      )
  }
  var kn = 0,
    wn = 1,
    jn = 2,
    tn = 3,
    On = 4,
    J = 5,
    te = 6,
    I =
      ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
    ie = I + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
    ce = new RegExp('^[' + I + '][' + ie + ']*$'),
    be = {},
    Se = {}
  function _e(e) {
    return Zt.call(Se, e)
      ? !0
      : Zt.call(be, e)
      ? !1
      : ce.test(e)
      ? ((Se[e] = !0), !0)
      : ((be[e] = !0), c('Invalid attribute name: `%s`', e), !1)
  }
  function Ce(e, n, i) {
    return n !== null
      ? n.type === kn
      : i
      ? !1
      : e.length > 2 && (e[0] === 'o' || e[0] === 'O') && (e[1] === 'n' || e[1] === 'N')
  }
  function it(e, n, i, s) {
    if (i !== null && i.type === kn) return !1
    switch (typeof n) {
      case 'function':
      case 'symbol':
        return !0
      case 'boolean': {
        if (s) return !1
        if (i !== null) return !i.acceptsBooleans
        var u = e.toLowerCase().slice(0, 5)
        return u !== 'data-' && u !== 'aria-'
      }
      default:
        return !1
    }
  }
  function $e(e, n, i, s) {
    if (n === null || typeof n > 'u' || it(e, n, i, s)) return !0
    if (s) return !1
    if (i !== null)
      switch (i.type) {
        case tn:
          return !n
        case On:
          return n === !1
        case J:
          return isNaN(n)
        case te:
          return isNaN(n) || n < 1
      }
    return !1
  }
  function ln(e) {
    return Xe.hasOwnProperty(e) ? Xe[e] : null
  }
  function et(e, n, i, s, u, d, v) {
    ;(this.acceptsBooleans = n === jn || n === tn || n === On),
      (this.attributeName = s),
      (this.attributeNamespace = u),
      (this.mustUseProperty = i),
      (this.propertyName = e),
      (this.type = n),
      (this.sanitizeURL = d),
      (this.removeEmptyString = v)
  }
  var Xe = {},
    En = [
      'children',
      'dangerouslySetInnerHTML',
      'defaultValue',
      'defaultChecked',
      'innerHTML',
      'suppressContentEditableWarning',
      'suppressHydrationWarning',
      'style',
    ]
  En.forEach(function (e) {
    Xe[e] = new et(e, kn, !1, e, null, !1, !1)
  }),
    [
      ['acceptCharset', 'accept-charset'],
      ['className', 'class'],
      ['htmlFor', 'for'],
      ['httpEquiv', 'http-equiv'],
    ].forEach(function (e) {
      var n = e[0],
        i = e[1]
      Xe[n] = new et(n, wn, !1, i, null, !1, !1)
    }),
    ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
      Xe[e] = new et(e, jn, !1, e.toLowerCase(), null, !1, !1)
    }),
    ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (
      e
    ) {
      Xe[e] = new et(e, jn, !1, e, null, !1, !1)
    }),
    [
      'allowFullScreen',
      'async',
      'autoFocus',
      'autoPlay',
      'controls',
      'default',
      'defer',
      'disabled',
      'disablePictureInPicture',
      'disableRemotePlayback',
      'formNoValidate',
      'hidden',
      'loop',
      'noModule',
      'noValidate',
      'open',
      'playsInline',
      'readOnly',
      'required',
      'reversed',
      'scoped',
      'seamless',
      'itemScope',
    ].forEach(function (e) {
      Xe[e] = new et(e, tn, !1, e.toLowerCase(), null, !1, !1)
    }),
    ['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
      Xe[e] = new et(e, tn, !0, e, null, !1, !1)
    }),
    ['capture', 'download'].forEach(function (e) {
      Xe[e] = new et(e, On, !1, e, null, !1, !1)
    }),
    ['cols', 'rows', 'size', 'span'].forEach(function (e) {
      Xe[e] = new et(e, te, !1, e, null, !1, !1)
    }),
    ['rowSpan', 'start'].forEach(function (e) {
      Xe[e] = new et(e, J, !1, e.toLowerCase(), null, !1, !1)
    })
  var yn = /[\-\:]([a-z])/g,
    va = function (e) {
      return e[1].toUpperCase()
    }
  ;[
    'accent-height',
    'alignment-baseline',
    'arabic-form',
    'baseline-shift',
    'cap-height',
    'clip-path',
    'clip-rule',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'dominant-baseline',
    'enable-background',
    'fill-opacity',
    'fill-rule',
    'flood-color',
    'flood-opacity',
    'font-family',
    'font-size',
    'font-size-adjust',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-weight',
    'glyph-name',
    'glyph-orientation-horizontal',
    'glyph-orientation-vertical',
    'horiz-adv-x',
    'horiz-origin-x',
    'image-rendering',
    'letter-spacing',
    'lighting-color',
    'marker-end',
    'marker-mid',
    'marker-start',
    'overline-position',
    'overline-thickness',
    'paint-order',
    'panose-1',
    'pointer-events',
    'rendering-intent',
    'shape-rendering',
    'stop-color',
    'stop-opacity',
    'strikethrough-position',
    'strikethrough-thickness',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke-width',
    'text-anchor',
    'text-decoration',
    'text-rendering',
    'underline-position',
    'underline-thickness',
    'unicode-bidi',
    'unicode-range',
    'units-per-em',
    'v-alphabetic',
    'v-hanging',
    'v-ideographic',
    'v-mathematical',
    'vector-effect',
    'vert-adv-y',
    'vert-origin-x',
    'vert-origin-y',
    'word-spacing',
    'writing-mode',
    'xmlns:xlink',
    'x-height',
  ].forEach(function (e) {
    var n = e.replace(yn, va)
    Xe[n] = new et(n, wn, !1, e, null, !1, !1)
  }),
    [
      'xlink:actuate',
      'xlink:arcrole',
      'xlink:role',
      'xlink:show',
      'xlink:title',
      'xlink:type',
    ].forEach(function (e) {
      var n = e.replace(yn, va)
      Xe[n] = new et(n, wn, !1, e, 'http://www.w3.org/1999/xlink', !1, !1)
    }),
    ['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
      var n = e.replace(yn, va)
      Xe[n] = new et(n, wn, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1)
    }),
    ['tabIndex', 'crossOrigin'].forEach(function (e) {
      Xe[e] = new et(e, wn, !1, e.toLowerCase(), null, !1, !1)
    })
  var Zr = 'xlinkHref'
  ;(Xe[Zr] = new et('xlinkHref', wn, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)),
    ['src', 'href', 'action', 'formAction'].forEach(function (e) {
      Xe[e] = new et(e, wn, !1, e.toLowerCase(), null, !0, !0)
    })
  var Jr =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i,
    ga = !1
  function ya(e) {
    !ga &&
      Jr.test(e) &&
      ((ga = !0),
      c(
        'A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.',
        JSON.stringify(e)
      ))
  }
  function Et(e, n, i, s) {
    if (s.mustUseProperty) {
      var u = s.propertyName
      return e[u]
    } else {
      Kn(i, n), s.sanitizeURL && ya('' + i)
      var d = s.attributeName,
        v = null
      if (s.type === On) {
        if (e.hasAttribute(d)) {
          var y = e.getAttribute(d)
          return y === '' ? !0 : $e(n, i, s, !1) ? y : y === '' + i ? i : y
        }
      } else if (e.hasAttribute(d)) {
        if ($e(n, i, s, !1)) return e.getAttribute(d)
        if (s.type === tn) return i
        v = e.getAttribute(d)
      }
      return $e(n, i, s, !1) ? (v === null ? i : v) : v === '' + i ? i : v
    }
  }
  function Mn(e, n, i, s) {
    {
      if (!_e(n)) return
      if (!e.hasAttribute(n)) return i === void 0 ? void 0 : null
      var u = e.getAttribute(n)
      return Kn(i, n), u === '' + i ? i : u
    }
  }
  function Qn(e, n, i, s) {
    var u = ln(n)
    if (!Ce(n, u, s)) {
      if (($e(n, i, u, s) && (i = null), s || u === null)) {
        if (_e(n)) {
          var d = n
          i === null ? e.removeAttribute(d) : (Kn(i, n), e.setAttribute(d, '' + i))
        }
        return
      }
      var v = u.mustUseProperty
      if (v) {
        var y = u.propertyName
        if (i === null) {
          var x = u.type
          e[y] = x === tn ? !1 : ''
        } else e[y] = i
        return
      }
      var T = u.attributeName,
        _ = u.attributeNamespace
      if (i === null) e.removeAttribute(T)
      else {
        var N = u.type,
          $
        N === tn || (N === On && i === !0)
          ? ($ = '')
          : (Kn(i, T), ($ = '' + i), u.sanitizeURL && ya($.toString())),
          _ ? e.setAttributeNS(_, T, $) : e.setAttribute(T, $)
      }
    }
  }
  var cr = Symbol.for('react.element'),
    jr = Symbol.for('react.portal'),
    ea = Symbol.for('react.fragment'),
    Tn = Symbol.for('react.strict_mode'),
    L = Symbol.for('react.profiler'),
    se = Symbol.for('react.provider'),
    ve = Symbol.for('react.context'),
    ke = Symbol.for('react.forward_ref'),
    dt = Symbol.for('react.suspense'),
    ct = Symbol.for('react.suspense_list'),
    at = Symbol.for('react.memo'),
    Be = Symbol.for('react.lazy'),
    Fn = Symbol.for('react.scope'),
    un = Symbol.for('react.debug_trace_mode'),
    cn = Symbol.for('react.offscreen'),
    fr = Symbol.for('react.legacy_hidden'),
    ta = Symbol.for('react.cache'),
    Bo = Symbol.for('react.tracing_marker'),
    Zn = Symbol.iterator,
    $s = '@@iterator'
  function Ka(e) {
    if (e === null || typeof e != 'object') return null
    var n = (Zn && e[Zn]) || e[$s]
    return typeof n == 'function' ? n : null
  }
  var ot = Object.assign,
    yi = 0,
    bi,
    Fs,
    Ns,
    jo,
    Bs,
    js,
    Us
  function Vs() {}
  Vs.__reactDisabledLog = !0
  function Bl() {
    {
      if (yi === 0) {
        ;(bi = console.log),
          (Fs = console.info),
          (Ns = console.warn),
          (jo = console.error),
          (Bs = console.group),
          (js = console.groupCollapsed),
          (Us = console.groupEnd)
        var e = { configurable: !0, enumerable: !0, value: Vs, writable: !0 }
        Object.defineProperties(console, {
          info: e,
          log: e,
          warn: e,
          error: e,
          group: e,
          groupCollapsed: e,
          groupEnd: e,
        })
      }
      yi++
    }
  }
  function vc() {
    {
      if ((yi--, yi === 0)) {
        var e = { configurable: !0, enumerable: !0, writable: !0 }
        Object.defineProperties(console, {
          log: ot({}, e, { value: bi }),
          info: ot({}, e, { value: Fs }),
          warn: ot({}, e, { value: Ns }),
          error: ot({}, e, { value: jo }),
          group: ot({}, e, { value: Bs }),
          groupCollapsed: ot({}, e, { value: js }),
          groupEnd: ot({}, e, { value: Us }),
        })
      }
      yi < 0 && c('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
    }
  }
  var Is = a.ReactCurrentDispatcher,
    Xi
  function na(e, n, i) {
    {
      if (Xi === void 0)
        try {
          throw Error()
        } catch (u) {
          var s = u.stack.trim().match(/\n( *(at )?)/)
          Xi = (s && s[1]) || ''
        }
      return (
        `
` +
        Xi +
        e
      )
    }
  }
  var Si = !1,
    ba
  {
    var xi = typeof WeakMap == 'function' ? WeakMap : Map
    ba = new xi()
  }
  function Hs(e, n) {
    if (!e || Si) return ''
    {
      var i = ba.get(e)
      if (i !== void 0) return i
    }
    var s
    Si = !0
    var u = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    var d
    ;(d = Is.current), (Is.current = null), Bl()
    try {
      if (n) {
        var v = function () {
          throw Error()
        }
        if (
          (Object.defineProperty(v.prototype, 'props', {
            set: function () {
              throw Error()
            },
          }),
          typeof Reflect == 'object' && Reflect.construct)
        ) {
          try {
            Reflect.construct(v, [])
          } catch (K) {
            s = K
          }
          Reflect.construct(e, [], v)
        } else {
          try {
            v.call()
          } catch (K) {
            s = K
          }
          e.call(v.prototype)
        }
      } else {
        try {
          throw Error()
        } catch (K) {
          s = K
        }
        e()
      }
    } catch (K) {
      if (K && s && typeof K.stack == 'string') {
        for (
          var y = K.stack.split(`
`),
            x = s.stack.split(`
`),
            T = y.length - 1,
            _ = x.length - 1;
          T >= 1 && _ >= 0 && y[T] !== x[_];

        )
          _--
        for (; T >= 1 && _ >= 0; T--, _--)
          if (y[T] !== x[_]) {
            if (T !== 1 || _ !== 1)
              do
                if ((T--, _--, _ < 0 || y[T] !== x[_])) {
                  var N =
                    `
` + y[T].replace(' at new ', ' at ')
                  return (
                    e.displayName &&
                      N.includes('<anonymous>') &&
                      (N = N.replace('<anonymous>', e.displayName)),
                    typeof e == 'function' && ba.set(e, N),
                    N
                  )
                }
              while (T >= 1 && _ >= 0)
            break
          }
      }
    } finally {
      ;(Si = !1), (Is.current = d), vc(), (Error.prepareStackTrace = u)
    }
    var $ = e ? e.displayName || e.name : '',
      q = $ ? na($) : ''
    return typeof e == 'function' && ba.set(e, q), q
  }
  function jl(e, n, i) {
    return Hs(e, !0)
  }
  function Uo(e, n, i) {
    return Hs(e, !1)
  }
  function gc(e) {
    var n = e.prototype
    return !!(n && n.isReactComponent)
  }
  function Ci(e, n, i) {
    if (e == null) return ''
    if (typeof e == 'function') return Hs(e, gc(e))
    if (typeof e == 'string') return na(e)
    switch (e) {
      case dt:
        return na('Suspense')
      case ct:
        return na('SuspenseList')
    }
    if (typeof e == 'object')
      switch (e.$$typeof) {
        case ke:
          return Uo(e.render)
        case at:
          return Ci(e.type, n, i)
        case Be: {
          var s = e,
            u = s._payload,
            d = s._init
          try {
            return Ci(d(u), n, i)
          } catch {}
        }
      }
    return ''
  }
  function Ul(e) {
    switch ((e._debugOwner && e._debugOwner.type, e._debugSource, e.tag)) {
      case w:
        return na(e.type)
      case ne:
        return na('Lazy')
      case j:
        return na('Suspense')
      case pe:
        return na('SuspenseList')
      case h:
      case g:
      case Y:
        return Uo(e.type)
      case P:
        return Uo(e.type.render)
      case m:
        return jl(e.type)
      default:
        return ''
    }
  }
  function Vo(e) {
    try {
      var n = '',
        i = e
      do (n += Ul(i)), (i = i.return)
      while (i)
      return n
    } catch (s) {
      return (
        `
Error generating stack: ` +
        s.message +
        `
` +
        s.stack
      )
    }
  }
  function Io(e, n, i) {
    var s = e.displayName
    if (s) return s
    var u = n.displayName || n.name || ''
    return u !== '' ? i + '(' + u + ')' : i
  }
  function Vl(e) {
    return e.displayName || 'Context'
  }
  function kt(e) {
    if (e == null) return null
    if (
      (typeof e.tag == 'number' &&
        c(
          'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
        ),
      typeof e == 'function')
    )
      return e.displayName || e.name || null
    if (typeof e == 'string') return e
    switch (e) {
      case ea:
        return 'Fragment'
      case jr:
        return 'Portal'
      case L:
        return 'Profiler'
      case Tn:
        return 'StrictMode'
      case dt:
        return 'Suspense'
      case ct:
        return 'SuspenseList'
    }
    if (typeof e == 'object')
      switch (e.$$typeof) {
        case ve:
          var n = e
          return Vl(n) + '.Consumer'
        case se:
          var i = e
          return Vl(i._context) + '.Provider'
        case ke:
          return Io(e, e.render, 'ForwardRef')
        case at:
          var s = e.displayName || null
          return s !== null ? s : kt(e.type) || 'Memo'
        case Be: {
          var u = e,
            d = u._payload,
            v = u._init
          try {
            return kt(v(d))
          } catch {
            return null
          }
        }
      }
    return null
  }
  function Qi(e, n, i) {
    var s = n.displayName || n.name || ''
    return e.displayName || (s !== '' ? i + '(' + s + ')' : i)
  }
  function Ws(e) {
    return e.displayName || 'Context'
  }
  function nt(e) {
    var n = e.tag,
      i = e.type
    switch (n) {
      case Oe:
        return 'Cache'
      case M:
        var s = i
        return Ws(s) + '.Consumer'
      case z:
        var u = i
        return Ws(u._context) + '.Provider'
      case le:
        return 'DehydratedFragment'
      case P:
        return Qi(i, i.render, 'ForwardRef')
      case D:
        return 'Fragment'
      case w:
        return i
      case C:
        return 'Portal'
      case b:
        return 'Root'
      case k:
        return 'Text'
      case ne:
        return kt(i)
      case E:
        return i === Tn ? 'StrictMode' : 'Mode'
      case me:
        return 'Offscreen'
      case B:
        return 'Profiler'
      case Ne:
        return 'Scope'
      case j:
        return 'Suspense'
      case pe:
        return 'SuspenseList'
      case ze:
        return 'TracingMarker'
      case m:
      case h:
      case he:
      case g:
      case Q:
      case Y:
        if (typeof i == 'function') return i.displayName || i.name || null
        if (typeof i == 'string') return i
        break
    }
    return null
  }
  var Il = a.ReactDebugCurrentFrame,
    Nn = null,
    Xa = !1
  function za() {
    {
      if (Nn === null) return null
      var e = Nn._debugOwner
      if (e !== null && typeof e < 'u') return nt(e)
    }
    return null
  }
  function Ho() {
    return Nn === null ? '' : Vo(Nn)
  }
  function Un() {
    ;(Il.getCurrentStack = null), (Nn = null), (Xa = !1)
  }
  function mn(e) {
    ;(Il.getCurrentStack = e === null ? null : Ho), (Nn = e), (Xa = !1)
  }
  function Wo() {
    return Nn
  }
  function kr(e) {
    Xa = e
  }
  function Pn(e) {
    return '' + e
  }
  function Dr(e) {
    switch (typeof e) {
      case 'boolean':
      case 'number':
      case 'string':
      case 'undefined':
        return e
      case 'object':
        return jt(e), e
      default:
        return ''
    }
  }
  var yc = { button: !0, checkbox: !0, image: !0, hidden: !0, radio: !0, reset: !0, submit: !0 }
  function Zi(e, n) {
    yc[n.type] ||
      n.onChange ||
      n.onInput ||
      n.readOnly ||
      n.disabled ||
      n.value == null ||
      c(
        'You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.'
      ),
      n.onChange ||
        n.readOnly ||
        n.disabled ||
        n.checked == null ||
        c(
          'You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.'
        )
  }
  function Ji(e) {
    var n = e.type,
      i = e.nodeName
    return i && i.toLowerCase() === 'input' && (n === 'checkbox' || n === 'radio')
  }
  function Ys(e) {
    return e._valueTracker
  }
  function wi(e) {
    e._valueTracker = null
  }
  function Hl(e) {
    var n = ''
    return e && (Ji(e) ? (n = e.checked ? 'true' : 'false') : (n = e.value)), n
  }
  function Wl(e) {
    var n = Ji(e) ? 'checked' : 'value',
      i = Object.getOwnPropertyDescriptor(e.constructor.prototype, n)
    jt(e[n])
    var s = '' + e[n]
    if (
      !(
        e.hasOwnProperty(n) ||
        typeof i > 'u' ||
        typeof i.get != 'function' ||
        typeof i.set != 'function'
      )
    ) {
      var u = i.get,
        d = i.set
      Object.defineProperty(e, n, {
        configurable: !0,
        get: function () {
          return u.call(this)
        },
        set: function (y) {
          jt(y), (s = '' + y), d.call(this, y)
        },
      }),
        Object.defineProperty(e, n, { enumerable: i.enumerable })
      var v = {
        getValue: function () {
          return s
        },
        setValue: function (y) {
          jt(y), (s = '' + y)
        },
        stopTracking: function () {
          wi(e), delete e[n]
        },
      }
      return v
    }
  }
  function Qa(e) {
    Ys(e) || (e._valueTracker = Wl(e))
  }
  function A(e) {
    if (!e) return !1
    var n = Ys(e)
    if (!n) return !0
    var i = n.getValue(),
      s = Hl(e)
    return s !== i ? (n.setValue(s), !0) : !1
  }
  function F(e) {
    if (((e = e || (typeof document < 'u' ? document : void 0)), typeof e > 'u')) return null
    try {
      return e.activeElement || e.body
    } catch {
      return e.body
    }
  }
  var X = !1,
    Te = !1,
    pt = !1,
    $t = !1
  function nn(e) {
    var n = e.type === 'checkbox' || e.type === 'radio'
    return n ? e.checked != null : e.value != null
  }
  function S(e, n) {
    var i = e,
      s = n.checked,
      u = ot({}, n, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: s ?? i._wrapperState.initialChecked,
      })
    return u
  }
  function O(e, n) {
    Zi('input', n),
      n.checked !== void 0 &&
        n.defaultChecked !== void 0 &&
        !Te &&
        (c(
          '%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
          za() || 'A component',
          n.type
        ),
        (Te = !0)),
      n.value !== void 0 &&
        n.defaultValue !== void 0 &&
        !X &&
        (c(
          '%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
          za() || 'A component',
          n.type
        ),
        (X = !0))
    var i = e,
      s = n.defaultValue == null ? '' : n.defaultValue
    i._wrapperState = {
      initialChecked: n.checked != null ? n.checked : n.defaultChecked,
      initialValue: Dr(n.value != null ? n.value : s),
      controlled: nn(n),
    }
  }
  function G(e, n) {
    var i = e,
      s = n.checked
    s != null && Qn(i, 'checked', s, !1)
  }
  function Z(e, n) {
    var i = e
    {
      var s = nn(n)
      !i._wrapperState.controlled &&
        s &&
        !$t &&
        (c(
          'A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components'
        ),
        ($t = !0)),
        i._wrapperState.controlled &&
          !s &&
          !pt &&
          (c(
            'A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components'
          ),
          (pt = !0))
    }
    G(e, n)
    var u = Dr(n.value),
      d = n.type
    if (u != null)
      d === 'number'
        ? ((u === 0 && i.value === '') || i.value != u) && (i.value = Pn(u))
        : i.value !== Pn(u) && (i.value = Pn(u))
    else if (d === 'submit' || d === 'reset') {
      i.removeAttribute('value')
      return
    }
    n.hasOwnProperty('value')
      ? We(i, n.type, u)
      : n.hasOwnProperty('defaultValue') && We(i, n.type, Dr(n.defaultValue)),
      n.checked == null && n.defaultChecked != null && (i.defaultChecked = !!n.defaultChecked)
  }
  function de(e, n, i) {
    var s = e
    if (n.hasOwnProperty('value') || n.hasOwnProperty('defaultValue')) {
      var u = n.type,
        d = u === 'submit' || u === 'reset'
      if (d && (n.value === void 0 || n.value === null)) return
      var v = Pn(s._wrapperState.initialValue)
      i || (v !== s.value && (s.value = v)), (s.defaultValue = v)
    }
    var y = s.name
    y !== '' && (s.name = ''),
      (s.defaultChecked = !s.defaultChecked),
      (s.defaultChecked = !!s._wrapperState.initialChecked),
      y !== '' && (s.name = y)
  }
  function Ue(e, n) {
    var i = e
    Z(i, n), Me(i, n)
  }
  function Me(e, n) {
    var i = n.name
    if (n.type === 'radio' && i != null) {
      for (var s = e; s.parentNode; ) s = s.parentNode
      Kn(i, 'name')
      for (
        var u = s.querySelectorAll('input[name=' + JSON.stringify('' + i) + '][type="radio"]'),
          d = 0;
        d < u.length;
        d++
      ) {
        var v = u[d]
        if (!(v === e || v.form !== e.form)) {
          var y = qp(v)
          if (!y)
            throw new Error(
              'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'
            )
          A(v), Z(v, y)
        }
      }
    }
  }
  function We(e, n, i) {
    ;(n !== 'number' || F(e.ownerDocument) !== e) &&
      (i == null
        ? (e.defaultValue = Pn(e._wrapperState.initialValue))
        : e.defaultValue !== Pn(i) && (e.defaultValue = Pn(i)))
  }
  var gt = !1,
    Wt = !1,
    fn = !1
  function dn(e, n) {
    n.value == null &&
      (typeof n.children == 'object' && n.children !== null
        ? t.Children.forEach(n.children, function (i) {
            i != null &&
              (typeof i == 'string' ||
                typeof i == 'number' ||
                Wt ||
                ((Wt = !0),
                c(
                  'Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.'
                )))
          })
        : n.dangerouslySetInnerHTML != null &&
          (fn ||
            ((fn = !0),
            c(
              'Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.'
            )))),
      n.selected != null &&
        !gt &&
        (c(
          'Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.'
        ),
        (gt = !0))
  }
  function bn(e, n) {
    n.value != null && e.setAttribute('value', Pn(Dr(n.value)))
  }
  var Ln = Array.isArray
  function Pt(e) {
    return Ln(e)
  }
  var Yo
  Yo = !1
  function Yl() {
    var e = za()
    return e
      ? `

Check the render method of \`` +
          e +
          '`.'
      : ''
  }
  var bc = ['value', 'defaultValue']
  function $v(e) {
    {
      Zi('select', e)
      for (var n = 0; n < bc.length; n++) {
        var i = bc[n]
        if (e[i] != null) {
          var s = Pt(e[i])
          e.multiple && !s
            ? c(
                'The `%s` prop supplied to <select> must be an array if `multiple` is true.%s',
                i,
                Yl()
              )
            : !e.multiple &&
              s &&
              c(
                'The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s',
                i,
                Yl()
              )
        }
      }
    }
  }
  function eo(e, n, i, s) {
    var u = e.options
    if (n) {
      for (var d = i, v = {}, y = 0; y < d.length; y++) v['$' + d[y]] = !0
      for (var x = 0; x < u.length; x++) {
        var T = v.hasOwnProperty('$' + u[x].value)
        u[x].selected !== T && (u[x].selected = T), T && s && (u[x].defaultSelected = !0)
      }
    } else {
      for (var _ = Pn(Dr(i)), N = null, $ = 0; $ < u.length; $++) {
        if (u[$].value === _) {
          ;(u[$].selected = !0), s && (u[$].defaultSelected = !0)
          return
        }
        N === null && !u[$].disabled && (N = u[$])
      }
      N !== null && (N.selected = !0)
    }
  }
  function Sc(e, n) {
    return ot({}, n, { value: void 0 })
  }
  function xc(e, n) {
    var i = e
    $v(n),
      (i._wrapperState = { wasMultiple: !!n.multiple }),
      n.value !== void 0 &&
        n.defaultValue !== void 0 &&
        !Yo &&
        (c(
          'Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components'
        ),
        (Yo = !0))
  }
  function Fv(e, n) {
    var i = e
    i.multiple = !!n.multiple
    var s = n.value
    s != null
      ? eo(i, !!n.multiple, s, !1)
      : n.defaultValue != null && eo(i, !!n.multiple, n.defaultValue, !0)
  }
  function HM(e, n) {
    var i = e,
      s = i._wrapperState.wasMultiple
    i._wrapperState.wasMultiple = !!n.multiple
    var u = n.value
    u != null
      ? eo(i, !!n.multiple, u, !1)
      : s !== !!n.multiple &&
        (n.defaultValue != null
          ? eo(i, !!n.multiple, n.defaultValue, !0)
          : eo(i, !!n.multiple, n.multiple ? [] : '', !1))
  }
  function WM(e, n) {
    var i = e,
      s = n.value
    s != null && eo(i, !!n.multiple, s, !1)
  }
  var hC = !1
  function Nv(e, n) {
    var i = e
    if (n.dangerouslySetInnerHTML != null)
      throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.')
    var s = ot({}, n, {
      value: void 0,
      defaultValue: void 0,
      children: Pn(i._wrapperState.initialValue),
    })
    return s
  }
  function mC(e, n) {
    var i = e
    Zi('textarea', n),
      n.value !== void 0 &&
        n.defaultValue !== void 0 &&
        !hC &&
        (c(
          '%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components',
          za() || 'A component'
        ),
        (hC = !0))
    var s = n.value
    if (s == null) {
      var u = n.children,
        d = n.defaultValue
      if (u != null) {
        c('Use the `defaultValue` or `value` props instead of setting children on <textarea>.')
        {
          if (d != null)
            throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.')
          if (Pt(u)) {
            if (u.length > 1) throw new Error('<textarea> can only have at most one child.')
            u = u[0]
          }
          d = u
        }
      }
      d == null && (d = ''), (s = d)
    }
    i._wrapperState = { initialValue: Dr(s) }
  }
  function vC(e, n) {
    var i = e,
      s = Dr(n.value),
      u = Dr(n.defaultValue)
    if (s != null) {
      var d = Pn(s)
      d !== i.value && (i.value = d),
        n.defaultValue == null && i.defaultValue !== d && (i.defaultValue = d)
    }
    u != null && (i.defaultValue = Pn(u))
  }
  function gC(e, n) {
    var i = e,
      s = i.textContent
    s === i._wrapperState.initialValue && s !== '' && s !== null && (i.value = s)
  }
  function YM(e, n) {
    vC(e, n)
  }
  var to = 'http://www.w3.org/1999/xhtml',
    GM = 'http://www.w3.org/1998/Math/MathML',
    Bv = 'http://www.w3.org/2000/svg'
  function jv(e) {
    switch (e) {
      case 'svg':
        return Bv
      case 'math':
        return GM
      default:
        return to
    }
  }
  function Uv(e, n) {
    return e == null || e === to ? jv(n) : e === Bv && n === 'foreignObject' ? to : e
  }
  var qM = function (e) {
      return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
        ? function (n, i, s, u) {
            MSApp.execUnsafeLocalFunction(function () {
              return e(n, i, s, u)
            })
          }
        : e
    },
    up,
    yC = qM(function (e, n) {
      if (e.namespaceURI === Bv && !('innerHTML' in e)) {
        ;(up = up || document.createElement('div')),
          (up.innerHTML = '<svg>' + n.valueOf().toString() + '</svg>')
        for (var i = up.firstChild; e.firstChild; ) e.removeChild(e.firstChild)
        for (; i.firstChild; ) e.appendChild(i.firstChild)
        return
      }
      e.innerHTML = n
    }),
    ra = 1,
    no = 3,
    Vn = 8,
    ro = 9,
    Vv = 11,
    cp = function (e, n) {
      if (n) {
        var i = e.firstChild
        if (i && i === e.lastChild && i.nodeType === no) {
          i.nodeValue = n
          return
        }
      }
      e.textContent = n
    },
    KM = {
      animation: [
        'animationDelay',
        'animationDirection',
        'animationDuration',
        'animationFillMode',
        'animationIterationCount',
        'animationName',
        'animationPlayState',
        'animationTimingFunction',
      ],
      background: [
        'backgroundAttachment',
        'backgroundClip',
        'backgroundColor',
        'backgroundImage',
        'backgroundOrigin',
        'backgroundPositionX',
        'backgroundPositionY',
        'backgroundRepeat',
        'backgroundSize',
      ],
      backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
      border: [
        'borderBottomColor',
        'borderBottomStyle',
        'borderBottomWidth',
        'borderImageOutset',
        'borderImageRepeat',
        'borderImageSlice',
        'borderImageSource',
        'borderImageWidth',
        'borderLeftColor',
        'borderLeftStyle',
        'borderLeftWidth',
        'borderRightColor',
        'borderRightStyle',
        'borderRightWidth',
        'borderTopColor',
        'borderTopStyle',
        'borderTopWidth',
      ],
      borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
      borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
      borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
      borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
      borderImage: [
        'borderImageOutset',
        'borderImageRepeat',
        'borderImageSlice',
        'borderImageSource',
        'borderImageWidth',
      ],
      borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
      borderInlineStart: [
        'borderInlineStartColor',
        'borderInlineStartStyle',
        'borderInlineStartWidth',
      ],
      borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
      borderRadius: [
        'borderBottomLeftRadius',
        'borderBottomRightRadius',
        'borderTopLeftRadius',
        'borderTopRightRadius',
      ],
      borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
      borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
      borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
      borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
      columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
      columns: ['columnCount', 'columnWidth'],
      flex: ['flexBasis', 'flexGrow', 'flexShrink'],
      flexFlow: ['flexDirection', 'flexWrap'],
      font: [
        'fontFamily',
        'fontFeatureSettings',
        'fontKerning',
        'fontLanguageOverride',
        'fontSize',
        'fontSizeAdjust',
        'fontStretch',
        'fontStyle',
        'fontVariant',
        'fontVariantAlternates',
        'fontVariantCaps',
        'fontVariantEastAsian',
        'fontVariantLigatures',
        'fontVariantNumeric',
        'fontVariantPosition',
        'fontWeight',
        'lineHeight',
      ],
      fontVariant: [
        'fontVariantAlternates',
        'fontVariantCaps',
        'fontVariantEastAsian',
        'fontVariantLigatures',
        'fontVariantNumeric',
        'fontVariantPosition',
      ],
      gap: ['columnGap', 'rowGap'],
      grid: [
        'gridAutoColumns',
        'gridAutoFlow',
        'gridAutoRows',
        'gridTemplateAreas',
        'gridTemplateColumns',
        'gridTemplateRows',
      ],
      gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
      gridColumn: ['gridColumnEnd', 'gridColumnStart'],
      gridColumnGap: ['columnGap'],
      gridGap: ['columnGap', 'rowGap'],
      gridRow: ['gridRowEnd', 'gridRowStart'],
      gridRowGap: ['rowGap'],
      gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
      listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
      margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
      marker: ['markerEnd', 'markerMid', 'markerStart'],
      mask: [
        'maskClip',
        'maskComposite',
        'maskImage',
        'maskMode',
        'maskOrigin',
        'maskPositionX',
        'maskPositionY',
        'maskRepeat',
        'maskSize',
      ],
      maskPosition: ['maskPositionX', 'maskPositionY'],
      outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
      overflow: ['overflowX', 'overflowY'],
      padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
      placeContent: ['alignContent', 'justifyContent'],
      placeItems: ['alignItems', 'justifyItems'],
      placeSelf: ['alignSelf', 'justifySelf'],
      textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
      textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
      transition: [
        'transitionDelay',
        'transitionDuration',
        'transitionProperty',
        'transitionTimingFunction',
      ],
      wordWrap: ['overflowWrap'],
    },
    Cc = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    }
  function XM(e, n) {
    return e + n.charAt(0).toUpperCase() + n.substring(1)
  }
  var QM = ['Webkit', 'ms', 'Moz', 'O']
  Object.keys(Cc).forEach(function (e) {
    QM.forEach(function (n) {
      Cc[XM(n, e)] = Cc[e]
    })
  })
  function Iv(e, n, i) {
    var s = n == null || typeof n == 'boolean' || n === ''
    return s
      ? ''
      : !i && typeof n == 'number' && n !== 0 && !(Cc.hasOwnProperty(e) && Cc[e])
      ? n + 'px'
      : (hn(n, e), ('' + n).trim())
  }
  var ZM = /([A-Z])/g,
    JM = /^ms-/
  function eP(e) {
    return e.replace(ZM, '-$1').toLowerCase().replace(JM, '-ms-')
  }
  var bC = function () {}
  {
    var tP = /^(?:webkit|moz|o)[A-Z]/,
      nP = /^-ms-/,
      rP = /-(.)/g,
      SC = /;\s*$/,
      Gl = {},
      Hv = {},
      xC = !1,
      CC = !1,
      aP = function (e) {
        return e.replace(rP, function (n, i) {
          return i.toUpperCase()
        })
      },
      iP = function (e) {
        ;(Gl.hasOwnProperty(e) && Gl[e]) ||
          ((Gl[e] = !0),
          c('Unsupported style property %s. Did you mean %s?', e, aP(e.replace(nP, 'ms-'))))
      },
      oP = function (e) {
        ;(Gl.hasOwnProperty(e) && Gl[e]) ||
          ((Gl[e] = !0),
          c(
            'Unsupported vendor-prefixed style property %s. Did you mean %s?',
            e,
            e.charAt(0).toUpperCase() + e.slice(1)
          ))
      },
      sP = function (e, n) {
        ;(Hv.hasOwnProperty(n) && Hv[n]) ||
          ((Hv[n] = !0),
          c(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            e,
            n.replace(SC, '')
          ))
      },
      lP = function (e, n) {
        xC || ((xC = !0), c('`NaN` is an invalid value for the `%s` css style property.', e))
      },
      uP = function (e, n) {
        CC || ((CC = !0), c('`Infinity` is an invalid value for the `%s` css style property.', e))
      }
    bC = function (e, n) {
      e.indexOf('-') > -1 ? iP(e) : tP.test(e) ? oP(e) : SC.test(n) && sP(e, n),
        typeof n == 'number' && (isNaN(n) ? lP(e, n) : isFinite(n) || uP(e, n))
    }
  }
  var cP = bC
  function fP(e) {
    {
      var n = '',
        i = ''
      for (var s in e)
        if (e.hasOwnProperty(s)) {
          var u = e[s]
          if (u != null) {
            var d = s.indexOf('--') === 0
            ;(n += i + (d ? s : eP(s)) + ':'), (n += Iv(s, u, d)), (i = ';')
          }
        }
      return n || null
    }
  }
  function wC(e, n) {
    var i = e.style
    for (var s in n)
      if (n.hasOwnProperty(s)) {
        var u = s.indexOf('--') === 0
        u || cP(s, n[s])
        var d = Iv(s, n[s], u)
        s === 'float' && (s = 'cssFloat'), u ? i.setProperty(s, d) : (i[s] = d)
      }
  }
  function dP(e) {
    return e == null || typeof e == 'boolean' || e === ''
  }
  function EC(e) {
    var n = {}
    for (var i in e) for (var s = KM[i] || [i], u = 0; u < s.length; u++) n[s[u]] = i
    return n
  }
  function pP(e, n) {
    {
      if (!n) return
      var i = EC(e),
        s = EC(n),
        u = {}
      for (var d in i) {
        var v = i[d],
          y = s[d]
        if (y && v !== y) {
          var x = v + ',' + y
          if (u[x]) continue
          ;(u[x] = !0),
            c(
              "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
              dP(e[v]) ? 'Removing' : 'Updating',
              v,
              y
            )
        }
      }
    }
  }
  var hP = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    },
    mP = ot({ menuitem: !0 }, hP),
    vP = '__html'
  function Wv(e, n) {
    if (n) {
      if (mP[e] && (n.children != null || n.dangerouslySetInnerHTML != null))
        throw new Error(
          e +
            ' is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.'
        )
      if (n.dangerouslySetInnerHTML != null) {
        if (n.children != null)
          throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.')
        if (typeof n.dangerouslySetInnerHTML != 'object' || !(vP in n.dangerouslySetInnerHTML))
          throw new Error(
            '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.'
          )
      }
      if (
        (!n.suppressContentEditableWarning &&
          n.contentEditable &&
          n.children != null &&
          c(
            'A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.'
          ),
        n.style != null && typeof n.style != 'object')
      )
        throw new Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        )
    }
  }
  function Gs(e, n) {
    if (e.indexOf('-') === -1) return typeof n.is == 'string'
    switch (e) {
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return !1
      default:
        return !0
    }
  }
  var fp = {
      'accept': 'accept',
      'acceptcharset': 'acceptCharset',
      'accept-charset': 'acceptCharset',
      'accesskey': 'accessKey',
      'action': 'action',
      'allowfullscreen': 'allowFullScreen',
      'alt': 'alt',
      'as': 'as',
      'async': 'async',
      'autocapitalize': 'autoCapitalize',
      'autocomplete': 'autoComplete',
      'autocorrect': 'autoCorrect',
      'autofocus': 'autoFocus',
      'autoplay': 'autoPlay',
      'autosave': 'autoSave',
      'capture': 'capture',
      'cellpadding': 'cellPadding',
      'cellspacing': 'cellSpacing',
      'challenge': 'challenge',
      'charset': 'charSet',
      'checked': 'checked',
      'children': 'children',
      'cite': 'cite',
      'class': 'className',
      'classid': 'classID',
      'classname': 'className',
      'cols': 'cols',
      'colspan': 'colSpan',
      'content': 'content',
      'contenteditable': 'contentEditable',
      'contextmenu': 'contextMenu',
      'controls': 'controls',
      'controlslist': 'controlsList',
      'coords': 'coords',
      'crossorigin': 'crossOrigin',
      'dangerouslysetinnerhtml': 'dangerouslySetInnerHTML',
      'data': 'data',
      'datetime': 'dateTime',
      'default': 'default',
      'defaultchecked': 'defaultChecked',
      'defaultvalue': 'defaultValue',
      'defer': 'defer',
      'dir': 'dir',
      'disabled': 'disabled',
      'disablepictureinpicture': 'disablePictureInPicture',
      'disableremoteplayback': 'disableRemotePlayback',
      'download': 'download',
      'draggable': 'draggable',
      'enctype': 'encType',
      'enterkeyhint': 'enterKeyHint',
      'for': 'htmlFor',
      'form': 'form',
      'formmethod': 'formMethod',
      'formaction': 'formAction',
      'formenctype': 'formEncType',
      'formnovalidate': 'formNoValidate',
      'formtarget': 'formTarget',
      'frameborder': 'frameBorder',
      'headers': 'headers',
      'height': 'height',
      'hidden': 'hidden',
      'high': 'high',
      'href': 'href',
      'hreflang': 'hrefLang',
      'htmlfor': 'htmlFor',
      'httpequiv': 'httpEquiv',
      'http-equiv': 'httpEquiv',
      'icon': 'icon',
      'id': 'id',
      'imagesizes': 'imageSizes',
      'imagesrcset': 'imageSrcSet',
      'innerhtml': 'innerHTML',
      'inputmode': 'inputMode',
      'integrity': 'integrity',
      'is': 'is',
      'itemid': 'itemID',
      'itemprop': 'itemProp',
      'itemref': 'itemRef',
      'itemscope': 'itemScope',
      'itemtype': 'itemType',
      'keyparams': 'keyParams',
      'keytype': 'keyType',
      'kind': 'kind',
      'label': 'label',
      'lang': 'lang',
      'list': 'list',
      'loop': 'loop',
      'low': 'low',
      'manifest': 'manifest',
      'marginwidth': 'marginWidth',
      'marginheight': 'marginHeight',
      'max': 'max',
      'maxlength': 'maxLength',
      'media': 'media',
      'mediagroup': 'mediaGroup',
      'method': 'method',
      'min': 'min',
      'minlength': 'minLength',
      'multiple': 'multiple',
      'muted': 'muted',
      'name': 'name',
      'nomodule': 'noModule',
      'nonce': 'nonce',
      'novalidate': 'noValidate',
      'open': 'open',
      'optimum': 'optimum',
      'pattern': 'pattern',
      'placeholder': 'placeholder',
      'playsinline': 'playsInline',
      'poster': 'poster',
      'preload': 'preload',
      'profile': 'profile',
      'radiogroup': 'radioGroup',
      'readonly': 'readOnly',
      'referrerpolicy': 'referrerPolicy',
      'rel': 'rel',
      'required': 'required',
      'reversed': 'reversed',
      'role': 'role',
      'rows': 'rows',
      'rowspan': 'rowSpan',
      'sandbox': 'sandbox',
      'scope': 'scope',
      'scoped': 'scoped',
      'scrolling': 'scrolling',
      'seamless': 'seamless',
      'selected': 'selected',
      'shape': 'shape',
      'size': 'size',
      'sizes': 'sizes',
      'span': 'span',
      'spellcheck': 'spellCheck',
      'src': 'src',
      'srcdoc': 'srcDoc',
      'srclang': 'srcLang',
      'srcset': 'srcSet',
      'start': 'start',
      'step': 'step',
      'style': 'style',
      'summary': 'summary',
      'tabindex': 'tabIndex',
      'target': 'target',
      'title': 'title',
      'type': 'type',
      'usemap': 'useMap',
      'value': 'value',
      'width': 'width',
      'wmode': 'wmode',
      'wrap': 'wrap',
      'about': 'about',
      'accentheight': 'accentHeight',
      'accent-height': 'accentHeight',
      'accumulate': 'accumulate',
      'additive': 'additive',
      'alignmentbaseline': 'alignmentBaseline',
      'alignment-baseline': 'alignmentBaseline',
      'allowreorder': 'allowReorder',
      'alphabetic': 'alphabetic',
      'amplitude': 'amplitude',
      'arabicform': 'arabicForm',
      'arabic-form': 'arabicForm',
      'ascent': 'ascent',
      'attributename': 'attributeName',
      'attributetype': 'attributeType',
      'autoreverse': 'autoReverse',
      'azimuth': 'azimuth',
      'basefrequency': 'baseFrequency',
      'baselineshift': 'baselineShift',
      'baseline-shift': 'baselineShift',
      'baseprofile': 'baseProfile',
      'bbox': 'bbox',
      'begin': 'begin',
      'bias': 'bias',
      'by': 'by',
      'calcmode': 'calcMode',
      'capheight': 'capHeight',
      'cap-height': 'capHeight',
      'clip': 'clip',
      'clippath': 'clipPath',
      'clip-path': 'clipPath',
      'clippathunits': 'clipPathUnits',
      'cliprule': 'clipRule',
      'clip-rule': 'clipRule',
      'color': 'color',
      'colorinterpolation': 'colorInterpolation',
      'color-interpolation': 'colorInterpolation',
      'colorinterpolationfilters': 'colorInterpolationFilters',
      'color-interpolation-filters': 'colorInterpolationFilters',
      'colorprofile': 'colorProfile',
      'color-profile': 'colorProfile',
      'colorrendering': 'colorRendering',
      'color-rendering': 'colorRendering',
      'contentscripttype': 'contentScriptType',
      'contentstyletype': 'contentStyleType',
      'cursor': 'cursor',
      'cx': 'cx',
      'cy': 'cy',
      'd': 'd',
      'datatype': 'datatype',
      'decelerate': 'decelerate',
      'descent': 'descent',
      'diffuseconstant': 'diffuseConstant',
      'direction': 'direction',
      'display': 'display',
      'divisor': 'divisor',
      'dominantbaseline': 'dominantBaseline',
      'dominant-baseline': 'dominantBaseline',
      'dur': 'dur',
      'dx': 'dx',
      'dy': 'dy',
      'edgemode': 'edgeMode',
      'elevation': 'elevation',
      'enablebackground': 'enableBackground',
      'enable-background': 'enableBackground',
      'end': 'end',
      'exponent': 'exponent',
      'externalresourcesrequired': 'externalResourcesRequired',
      'fill': 'fill',
      'fillopacity': 'fillOpacity',
      'fill-opacity': 'fillOpacity',
      'fillrule': 'fillRule',
      'fill-rule': 'fillRule',
      'filter': 'filter',
      'filterres': 'filterRes',
      'filterunits': 'filterUnits',
      'floodopacity': 'floodOpacity',
      'flood-opacity': 'floodOpacity',
      'floodcolor': 'floodColor',
      'flood-color': 'floodColor',
      'focusable': 'focusable',
      'fontfamily': 'fontFamily',
      'font-family': 'fontFamily',
      'fontsize': 'fontSize',
      'font-size': 'fontSize',
      'fontsizeadjust': 'fontSizeAdjust',
      'font-size-adjust': 'fontSizeAdjust',
      'fontstretch': 'fontStretch',
      'font-stretch': 'fontStretch',
      'fontstyle': 'fontStyle',
      'font-style': 'fontStyle',
      'fontvariant': 'fontVariant',
      'font-variant': 'fontVariant',
      'fontweight': 'fontWeight',
      'font-weight': 'fontWeight',
      'format': 'format',
      'from': 'from',
      'fx': 'fx',
      'fy': 'fy',
      'g1': 'g1',
      'g2': 'g2',
      'glyphname': 'glyphName',
      'glyph-name': 'glyphName',
      'glyphorientationhorizontal': 'glyphOrientationHorizontal',
      'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
      'glyphorientationvertical': 'glyphOrientationVertical',
      'glyph-orientation-vertical': 'glyphOrientationVertical',
      'glyphref': 'glyphRef',
      'gradienttransform': 'gradientTransform',
      'gradientunits': 'gradientUnits',
      'hanging': 'hanging',
      'horizadvx': 'horizAdvX',
      'horiz-adv-x': 'horizAdvX',
      'horizoriginx': 'horizOriginX',
      'horiz-origin-x': 'horizOriginX',
      'ideographic': 'ideographic',
      'imagerendering': 'imageRendering',
      'image-rendering': 'imageRendering',
      'in2': 'in2',
      'in': 'in',
      'inlist': 'inlist',
      'intercept': 'intercept',
      'k1': 'k1',
      'k2': 'k2',
      'k3': 'k3',
      'k4': 'k4',
      'k': 'k',
      'kernelmatrix': 'kernelMatrix',
      'kernelunitlength': 'kernelUnitLength',
      'kerning': 'kerning',
      'keypoints': 'keyPoints',
      'keysplines': 'keySplines',
      'keytimes': 'keyTimes',
      'lengthadjust': 'lengthAdjust',
      'letterspacing': 'letterSpacing',
      'letter-spacing': 'letterSpacing',
      'lightingcolor': 'lightingColor',
      'lighting-color': 'lightingColor',
      'limitingconeangle': 'limitingConeAngle',
      'local': 'local',
      'markerend': 'markerEnd',
      'marker-end': 'markerEnd',
      'markerheight': 'markerHeight',
      'markermid': 'markerMid',
      'marker-mid': 'markerMid',
      'markerstart': 'markerStart',
      'marker-start': 'markerStart',
      'markerunits': 'markerUnits',
      'markerwidth': 'markerWidth',
      'mask': 'mask',
      'maskcontentunits': 'maskContentUnits',
      'maskunits': 'maskUnits',
      'mathematical': 'mathematical',
      'mode': 'mode',
      'numoctaves': 'numOctaves',
      'offset': 'offset',
      'opacity': 'opacity',
      'operator': 'operator',
      'order': 'order',
      'orient': 'orient',
      'orientation': 'orientation',
      'origin': 'origin',
      'overflow': 'overflow',
      'overlineposition': 'overlinePosition',
      'overline-position': 'overlinePosition',
      'overlinethickness': 'overlineThickness',
      'overline-thickness': 'overlineThickness',
      'paintorder': 'paintOrder',
      'paint-order': 'paintOrder',
      'panose1': 'panose1',
      'panose-1': 'panose1',
      'pathlength': 'pathLength',
      'patterncontentunits': 'patternContentUnits',
      'patterntransform': 'patternTransform',
      'patternunits': 'patternUnits',
      'pointerevents': 'pointerEvents',
      'pointer-events': 'pointerEvents',
      'points': 'points',
      'pointsatx': 'pointsAtX',
      'pointsaty': 'pointsAtY',
      'pointsatz': 'pointsAtZ',
      'prefix': 'prefix',
      'preservealpha': 'preserveAlpha',
      'preserveaspectratio': 'preserveAspectRatio',
      'primitiveunits': 'primitiveUnits',
      'property': 'property',
      'r': 'r',
      'radius': 'radius',
      'refx': 'refX',
      'refy': 'refY',
      'renderingintent': 'renderingIntent',
      'rendering-intent': 'renderingIntent',
      'repeatcount': 'repeatCount',
      'repeatdur': 'repeatDur',
      'requiredextensions': 'requiredExtensions',
      'requiredfeatures': 'requiredFeatures',
      'resource': 'resource',
      'restart': 'restart',
      'result': 'result',
      'results': 'results',
      'rotate': 'rotate',
      'rx': 'rx',
      'ry': 'ry',
      'scale': 'scale',
      'security': 'security',
      'seed': 'seed',
      'shaperendering': 'shapeRendering',
      'shape-rendering': 'shapeRendering',
      'slope': 'slope',
      'spacing': 'spacing',
      'specularconstant': 'specularConstant',
      'specularexponent': 'specularExponent',
      'speed': 'speed',
      'spreadmethod': 'spreadMethod',
      'startoffset': 'startOffset',
      'stddeviation': 'stdDeviation',
      'stemh': 'stemh',
      'stemv': 'stemv',
      'stitchtiles': 'stitchTiles',
      'stopcolor': 'stopColor',
      'stop-color': 'stopColor',
      'stopopacity': 'stopOpacity',
      'stop-opacity': 'stopOpacity',
      'strikethroughposition': 'strikethroughPosition',
      'strikethrough-position': 'strikethroughPosition',
      'strikethroughthickness': 'strikethroughThickness',
      'strikethrough-thickness': 'strikethroughThickness',
      'string': 'string',
      'stroke': 'stroke',
      'strokedasharray': 'strokeDasharray',
      'stroke-dasharray': 'strokeDasharray',
      'strokedashoffset': 'strokeDashoffset',
      'stroke-dashoffset': 'strokeDashoffset',
      'strokelinecap': 'strokeLinecap',
      'stroke-linecap': 'strokeLinecap',
      'strokelinejoin': 'strokeLinejoin',
      'stroke-linejoin': 'strokeLinejoin',
      'strokemiterlimit': 'strokeMiterlimit',
      'stroke-miterlimit': 'strokeMiterlimit',
      'strokewidth': 'strokeWidth',
      'stroke-width': 'strokeWidth',
      'strokeopacity': 'strokeOpacity',
      'stroke-opacity': 'strokeOpacity',
      'suppresscontenteditablewarning': 'suppressContentEditableWarning',
      'suppresshydrationwarning': 'suppressHydrationWarning',
      'surfacescale': 'surfaceScale',
      'systemlanguage': 'systemLanguage',
      'tablevalues': 'tableValues',
      'targetx': 'targetX',
      'targety': 'targetY',
      'textanchor': 'textAnchor',
      'text-anchor': 'textAnchor',
      'textdecoration': 'textDecoration',
      'text-decoration': 'textDecoration',
      'textlength': 'textLength',
      'textrendering': 'textRendering',
      'text-rendering': 'textRendering',
      'to': 'to',
      'transform': 'transform',
      'typeof': 'typeof',
      'u1': 'u1',
      'u2': 'u2',
      'underlineposition': 'underlinePosition',
      'underline-position': 'underlinePosition',
      'underlinethickness': 'underlineThickness',
      'underline-thickness': 'underlineThickness',
      'unicode': 'unicode',
      'unicodebidi': 'unicodeBidi',
      'unicode-bidi': 'unicodeBidi',
      'unicoderange': 'unicodeRange',
      'unicode-range': 'unicodeRange',
      'unitsperem': 'unitsPerEm',
      'units-per-em': 'unitsPerEm',
      'unselectable': 'unselectable',
      'valphabetic': 'vAlphabetic',
      'v-alphabetic': 'vAlphabetic',
      'values': 'values',
      'vectoreffect': 'vectorEffect',
      'vector-effect': 'vectorEffect',
      'version': 'version',
      'vertadvy': 'vertAdvY',
      'vert-adv-y': 'vertAdvY',
      'vertoriginx': 'vertOriginX',
      'vert-origin-x': 'vertOriginX',
      'vertoriginy': 'vertOriginY',
      'vert-origin-y': 'vertOriginY',
      'vhanging': 'vHanging',
      'v-hanging': 'vHanging',
      'videographic': 'vIdeographic',
      'v-ideographic': 'vIdeographic',
      'viewbox': 'viewBox',
      'viewtarget': 'viewTarget',
      'visibility': 'visibility',
      'vmathematical': 'vMathematical',
      'v-mathematical': 'vMathematical',
      'vocab': 'vocab',
      'widths': 'widths',
      'wordspacing': 'wordSpacing',
      'word-spacing': 'wordSpacing',
      'writingmode': 'writingMode',
      'writing-mode': 'writingMode',
      'x1': 'x1',
      'x2': 'x2',
      'x': 'x',
      'xchannelselector': 'xChannelSelector',
      'xheight': 'xHeight',
      'x-height': 'xHeight',
      'xlinkactuate': 'xlinkActuate',
      'xlink:actuate': 'xlinkActuate',
      'xlinkarcrole': 'xlinkArcrole',
      'xlink:arcrole': 'xlinkArcrole',
      'xlinkhref': 'xlinkHref',
      'xlink:href': 'xlinkHref',
      'xlinkrole': 'xlinkRole',
      'xlink:role': 'xlinkRole',
      'xlinkshow': 'xlinkShow',
      'xlink:show': 'xlinkShow',
      'xlinktitle': 'xlinkTitle',
      'xlink:title': 'xlinkTitle',
      'xlinktype': 'xlinkType',
      'xlink:type': 'xlinkType',
      'xmlbase': 'xmlBase',
      'xml:base': 'xmlBase',
      'xmllang': 'xmlLang',
      'xml:lang': 'xmlLang',
      'xmlns': 'xmlns',
      'xml:space': 'xmlSpace',
      'xmlnsxlink': 'xmlnsXlink',
      'xmlns:xlink': 'xmlnsXlink',
      'xmlspace': 'xmlSpace',
      'y1': 'y1',
      'y2': 'y2',
      'y': 'y',
      'ychannelselector': 'yChannelSelector',
      'z': 'z',
      'zoomandpan': 'zoomAndPan',
    },
    TC = {
      'aria-current': 0,
      'aria-description': 0,
      'aria-details': 0,
      'aria-disabled': 0,
      'aria-hidden': 0,
      'aria-invalid': 0,
      'aria-keyshortcuts': 0,
      'aria-label': 0,
      'aria-roledescription': 0,
      'aria-autocomplete': 0,
      'aria-checked': 0,
      'aria-expanded': 0,
      'aria-haspopup': 0,
      'aria-level': 0,
      'aria-modal': 0,
      'aria-multiline': 0,
      'aria-multiselectable': 0,
      'aria-orientation': 0,
      'aria-placeholder': 0,
      'aria-pressed': 0,
      'aria-readonly': 0,
      'aria-required': 0,
      'aria-selected': 0,
      'aria-sort': 0,
      'aria-valuemax': 0,
      'aria-valuemin': 0,
      'aria-valuenow': 0,
      'aria-valuetext': 0,
      'aria-atomic': 0,
      'aria-busy': 0,
      'aria-live': 0,
      'aria-relevant': 0,
      'aria-dropeffect': 0,
      'aria-grabbed': 0,
      'aria-activedescendant': 0,
      'aria-colcount': 0,
      'aria-colindex': 0,
      'aria-colspan': 0,
      'aria-controls': 0,
      'aria-describedby': 0,
      'aria-errormessage': 0,
      'aria-flowto': 0,
      'aria-labelledby': 0,
      'aria-owns': 0,
      'aria-posinset': 0,
      'aria-rowcount': 0,
      'aria-rowindex': 0,
      'aria-rowspan': 0,
      'aria-setsize': 0,
    },
    ql = {},
    gP = new RegExp('^(aria)-[' + ie + ']*$'),
    yP = new RegExp('^(aria)[A-Z][' + ie + ']*$')
  function bP(e, n) {
    {
      if (Zt.call(ql, n) && ql[n]) return !0
      if (yP.test(n)) {
        var i = 'aria-' + n.slice(4).toLowerCase(),
          s = TC.hasOwnProperty(i) ? i : null
        if (s == null)
          return (
            c(
              'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',
              n
            ),
            (ql[n] = !0),
            !0
          )
        if (n !== s)
          return c('Invalid ARIA attribute `%s`. Did you mean `%s`?', n, s), (ql[n] = !0), !0
      }
      if (gP.test(n)) {
        var u = n.toLowerCase(),
          d = TC.hasOwnProperty(u) ? u : null
        if (d == null) return (ql[n] = !0), !1
        if (n !== d)
          return c('Unknown ARIA attribute `%s`. Did you mean `%s`?', n, d), (ql[n] = !0), !0
      }
    }
    return !0
  }
  function SP(e, n) {
    {
      var i = []
      for (var s in n) {
        var u = bP(e, s)
        u || i.push(s)
      }
      var d = i
        .map(function (v) {
          return '`' + v + '`'
        })
        .join(', ')
      i.length === 1
        ? c(
            'Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
            d,
            e
          )
        : i.length > 1 &&
          c(
            'Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
            d,
            e
          )
    }
  }
  function xP(e, n) {
    Gs(e, n) || SP(e, n)
  }
  var RC = !1
  function CP(e, n) {
    {
      if (e !== 'input' && e !== 'textarea' && e !== 'select') return
      n != null &&
        n.value === null &&
        !RC &&
        ((RC = !0),
        e === 'select' && n.multiple
          ? c(
              '`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.',
              e
            )
          : c(
              '`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.',
              e
            ))
    }
  }
  var _C = function () {}
  {
    var Ur = {},
      kC = /^on./,
      wP = /^on[^A-Z]/,
      EP = new RegExp('^(aria)-[' + ie + ']*$'),
      TP = new RegExp('^(aria)[A-Z][' + ie + ']*$')
    _C = function (e, n, i, s) {
      if (Zt.call(Ur, n) && Ur[n]) return !0
      var u = n.toLowerCase()
      if (u === 'onfocusin' || u === 'onfocusout')
        return (
          c(
            'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.'
          ),
          (Ur[n] = !0),
          !0
        )
      if (s != null) {
        var d = s.registrationNameDependencies,
          v = s.possibleRegistrationNames
        if (d.hasOwnProperty(n)) return !0
        var y = v.hasOwnProperty(u) ? v[u] : null
        if (y != null)
          return (
            c('Invalid event handler property `%s`. Did you mean `%s`?', n, y), (Ur[n] = !0), !0
          )
        if (kC.test(n))
          return c('Unknown event handler property `%s`. It will be ignored.', n), (Ur[n] = !0), !0
      } else if (kC.test(n))
        return (
          wP.test(n) &&
            c(
              'Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.',
              n
            ),
          (Ur[n] = !0),
          !0
        )
      if (EP.test(n) || TP.test(n)) return !0
      if (u === 'innerhtml')
        return (
          c(
            'Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.'
          ),
          (Ur[n] = !0),
          !0
        )
      if (u === 'aria')
        return (
          c(
            'The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.'
          ),
          (Ur[n] = !0),
          !0
        )
      if (u === 'is' && i !== null && i !== void 0 && typeof i != 'string')
        return (
          c(
            'Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.',
            typeof i
          ),
          (Ur[n] = !0),
          !0
        )
      if (typeof i == 'number' && isNaN(i))
        return (
          c(
            'Received NaN for the `%s` attribute. If this is expected, cast the value to a string.',
            n
          ),
          (Ur[n] = !0),
          !0
        )
      var x = ln(n),
        T = x !== null && x.type === kn
      if (fp.hasOwnProperty(u)) {
        var _ = fp[u]
        if (_ !== n)
          return c('Invalid DOM property `%s`. Did you mean `%s`?', n, _), (Ur[n] = !0), !0
      } else if (!T && n !== u)
        return (
          c(
            'React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.',
            n,
            u
          ),
          (Ur[n] = !0),
          !0
        )
      return typeof i == 'boolean' && it(n, i, x, !1)
        ? (i
            ? c(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                i,
                n,
                n,
                i,
                n
              )
            : c(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                i,
                n,
                n,
                i,
                n,
                n,
                n
              ),
          (Ur[n] = !0),
          !0)
        : T
        ? !0
        : it(n, i, x, !1)
        ? ((Ur[n] = !0), !1)
        : ((i === 'false' || i === 'true') &&
            x !== null &&
            x.type === tn &&
            (c(
              'Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?',
              i,
              n,
              i === 'false'
                ? 'The browser will interpret it as a truthy value.'
                : 'Although this works, it will not work as expected if you pass the string "false".',
              n,
              i
            ),
            (Ur[n] = !0)),
          !0)
    }
  }
  var RP = function (e, n, i) {
    {
      var s = []
      for (var u in n) {
        var d = _C(e, u, n[u], i)
        d || s.push(u)
      }
      var v = s
        .map(function (y) {
          return '`' + y + '`'
        })
        .join(', ')
      s.length === 1
        ? c(
            'Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
            v,
            e
          )
        : s.length > 1 &&
          c(
            'Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
            v,
            e
          )
    }
  }
  function _P(e, n, i) {
    Gs(e, n) || RP(e, n, i)
  }
  var DC = 1,
    Yv = 1 << 1,
    wc = 1 << 2,
    kP = DC | Yv | wc,
    Ec = null
  function DP(e) {
    Ec !== null &&
      c(
        'Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.'
      ),
      (Ec = e)
  }
  function AP() {
    Ec === null &&
      c(
        'Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.'
      ),
      (Ec = null)
  }
  function OP(e) {
    return e === Ec
  }
  function Gv(e) {
    var n = e.target || e.srcElement || window
    return (
      n.correspondingUseElement && (n = n.correspondingUseElement),
      n.nodeType === no ? n.parentNode : n
    )
  }
  var qv = null,
    Kl = null,
    Xl = null
  function AC(e) {
    var n = es(e)
    if (n) {
      if (typeof qv != 'function')
        throw new Error(
          'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.'
        )
      var i = n.stateNode
      if (i) {
        var s = qp(i)
        qv(n.stateNode, n.type, s)
      }
    }
  }
  function MP(e) {
    qv = e
  }
  function OC(e) {
    Kl ? (Xl ? Xl.push(e) : (Xl = [e])) : (Kl = e)
  }
  function PP() {
    return Kl !== null || Xl !== null
  }
  function MC() {
    if (Kl) {
      var e = Kl,
        n = Xl
      if (((Kl = null), (Xl = null), AC(e), n)) for (var i = 0; i < n.length; i++) AC(n[i])
    }
  }
  var PC = function (e, n) {
      return e(n)
    },
    LC = function () {},
    Kv = !1
  function LP() {
    var e = PP()
    e && (LC(), MC())
  }
  function zC(e, n, i) {
    if (Kv) return e(n, i)
    Kv = !0
    try {
      return PC(e, n, i)
    } finally {
      ;(Kv = !1), LP()
    }
  }
  function zP(e, n, i) {
    ;(PC = e), (LC = i)
  }
  function $P(e) {
    return e === 'button' || e === 'input' || e === 'select' || e === 'textarea'
  }
  function FP(e, n, i) {
    switch (e) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
      case 'onMouseEnter':
        return !!(i.disabled && $P(n))
      default:
        return !1
    }
  }
  function Tc(e, n) {
    var i = e.stateNode
    if (i === null) return null
    var s = qp(i)
    if (s === null) return null
    var u = s[n]
    if (FP(n, e.type, s)) return null
    if (u && typeof u != 'function')
      throw new Error(
        'Expected `' +
          n +
          '` listener to be a function, instead got a value of `' +
          typeof u +
          '` type.'
      )
    return u
  }
  var Xv = !1
  if (wt)
    try {
      var Rc = {}
      Object.defineProperty(Rc, 'passive', {
        get: function () {
          Xv = !0
        },
      }),
        window.addEventListener('test', Rc, Rc),
        window.removeEventListener('test', Rc, Rc)
    } catch {
      Xv = !1
    }
  function $C(e, n, i, s, u, d, v, y, x) {
    var T = Array.prototype.slice.call(arguments, 3)
    try {
      n.apply(i, T)
    } catch (_) {
      this.onError(_)
    }
  }
  var FC = $C
  if (
    typeof window < 'u' &&
    typeof window.dispatchEvent == 'function' &&
    typeof document < 'u' &&
    typeof document.createEvent == 'function'
  ) {
    var Qv = document.createElement('react')
    FC = function (n, i, s, u, d, v, y, x, T) {
      if (typeof document > 'u' || document === null)
        throw new Error(
          'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.'
        )
      var _ = document.createEvent('Event'),
        N = !1,
        $ = !0,
        q = window.event,
        K = Object.getOwnPropertyDescriptor(window, 'event')
      function re() {
        Qv.removeEventListener(ae, je, !1),
          typeof window.event < 'u' && window.hasOwnProperty('event') && (window.event = q)
      }
      var De = Array.prototype.slice.call(arguments, 3)
      function je() {
        ;(N = !0), re(), i.apply(s, De), ($ = !1)
      }
      var Fe,
        St = !1,
        ht = !1
      function H(W) {
        if (
          ((Fe = W.error),
          (St = !0),
          Fe === null && W.colno === 0 && W.lineno === 0 && (ht = !0),
          W.defaultPrevented && Fe != null && typeof Fe == 'object')
        )
          try {
            Fe._suppressLogging = !0
          } catch {}
      }
      var ae = 'react-' + (n || 'invokeguardedcallback')
      if (
        (window.addEventListener('error', H),
        Qv.addEventListener(ae, je, !1),
        _.initEvent(ae, !1, !1),
        Qv.dispatchEvent(_),
        K && Object.defineProperty(window, 'event', K),
        N &&
          $ &&
          (St
            ? ht &&
              (Fe = new Error(
                "A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information."
              ))
            : (Fe = new Error(
                `An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`
              )),
          this.onError(Fe)),
        window.removeEventListener('error', H),
        !N)
      )
        return re(), $C.apply(this, arguments)
    }
  }
  var NP = FC,
    Ql = !1,
    dp = null,
    pp = !1,
    Zv = null,
    BP = {
      onError: function (e) {
        ;(Ql = !0), (dp = e)
      },
    }
  function Jv(e, n, i, s, u, d, v, y, x) {
    ;(Ql = !1), (dp = null), NP.apply(BP, arguments)
  }
  function jP(e, n, i, s, u, d, v, y, x) {
    if ((Jv.apply(this, arguments), Ql)) {
      var T = eg()
      pp || ((pp = !0), (Zv = T))
    }
  }
  function UP() {
    if (pp) {
      var e = Zv
      throw ((pp = !1), (Zv = null), e)
    }
  }
  function VP() {
    return Ql
  }
  function eg() {
    if (Ql) {
      var e = dp
      return (Ql = !1), (dp = null), e
    } else
      throw new Error(
        'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.'
      )
  }
  function Zl(e) {
    return e._reactInternals
  }
  function IP(e) {
    return e._reactInternals !== void 0
  }
  function HP(e, n) {
    e._reactInternals = n
  }
  var Ve = 0,
    Jl = 1,
    In = 2,
    Tt = 4,
    qs = 16,
    _c = 32,
    tg = 64,
    Lt = 128,
    ao = 256,
    Go = 512,
    Ks = 1024,
    Za = 2048,
    io = 4096,
    Xs = 8192,
    hp = 16384,
    WP = Za | Tt | tg | Go | Ks | hp,
    YP = 32767,
    kc = 32768,
    Vr = 65536,
    ng = 131072,
    NC = 1048576,
    rg = 2097152,
    Qs = 4194304,
    ag = 8388608,
    oo = 16777216,
    mp = 33554432,
    ig = Tt | Ks | 0,
    og = In | Tt | qs | _c | Go | io | Xs,
    Dc = Tt | tg | Go | Xs,
    eu = Za | qs,
    so = Qs | ag | rg,
    GP = a.ReactCurrentOwner
  function Zs(e) {
    var n = e,
      i = e
    if (e.alternate) for (; n.return; ) n = n.return
    else {
      var s = n
      do (n = s), (n.flags & (In | io)) !== Ve && (i = n.return), (s = n.return)
      while (s)
    }
    return n.tag === b ? i : null
  }
  function BC(e) {
    if (e.tag === j) {
      var n = e.memoizedState
      if (n === null) {
        var i = e.alternate
        i !== null && (n = i.memoizedState)
      }
      if (n !== null) return n.dehydrated
    }
    return null
  }
  function jC(e) {
    return e.tag === b ? e.stateNode.containerInfo : null
  }
  function qP(e) {
    return Zs(e) === e
  }
  function KP(e) {
    {
      var n = GP.current
      if (n !== null && n.tag === m) {
        var i = n,
          s = i.stateNode
        s._warnedAboutRefsInRender ||
          c(
            '%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.',
            nt(i) || 'A component'
          ),
          (s._warnedAboutRefsInRender = !0)
      }
    }
    var u = Zl(e)
    return u ? Zs(u) === u : !1
  }
  function UC(e) {
    if (Zs(e) !== e) throw new Error('Unable to find node on an unmounted component.')
  }
  function VC(e) {
    var n = e.alternate
    if (!n) {
      var i = Zs(e)
      if (i === null) throw new Error('Unable to find node on an unmounted component.')
      return i !== e ? null : e
    }
    for (var s = e, u = n; ; ) {
      var d = s.return
      if (d === null) break
      var v = d.alternate
      if (v === null) {
        var y = d.return
        if (y !== null) {
          s = u = y
          continue
        }
        break
      }
      if (d.child === v.child) {
        for (var x = d.child; x; ) {
          if (x === s) return UC(d), e
          if (x === u) return UC(d), n
          x = x.sibling
        }
        throw new Error('Unable to find node on an unmounted component.')
      }
      if (s.return !== u.return) (s = d), (u = v)
      else {
        for (var T = !1, _ = d.child; _; ) {
          if (_ === s) {
            ;(T = !0), (s = d), (u = v)
            break
          }
          if (_ === u) {
            ;(T = !0), (u = d), (s = v)
            break
          }
          _ = _.sibling
        }
        if (!T) {
          for (_ = v.child; _; ) {
            if (_ === s) {
              ;(T = !0), (s = v), (u = d)
              break
            }
            if (_ === u) {
              ;(T = !0), (u = v), (s = d)
              break
            }
            _ = _.sibling
          }
          if (!T)
            throw new Error(
              'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'
            )
        }
      }
      if (s.alternate !== u)
        throw new Error(
          "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
        )
    }
    if (s.tag !== b) throw new Error('Unable to find node on an unmounted component.')
    return s.stateNode.current === s ? e : n
  }
  function IC(e) {
    var n = VC(e)
    return n !== null ? HC(n) : null
  }
  function HC(e) {
    if (e.tag === w || e.tag === k) return e
    for (var n = e.child; n !== null; ) {
      var i = HC(n)
      if (i !== null) return i
      n = n.sibling
    }
    return null
  }
  function XP(e) {
    var n = VC(e)
    return n !== null ? WC(n) : null
  }
  function WC(e) {
    if (e.tag === w || e.tag === k) return e
    for (var n = e.child; n !== null; ) {
      if (n.tag !== C) {
        var i = WC(n)
        if (i !== null) return i
      }
      n = n.sibling
    }
    return null
  }
  var YC = r.unstable_scheduleCallback,
    QP = r.unstable_cancelCallback,
    ZP = r.unstable_shouldYield,
    JP = r.unstable_requestPaint,
    dr = r.unstable_now,
    eL = r.unstable_getCurrentPriorityLevel,
    vp = r.unstable_ImmediatePriority,
    sg = r.unstable_UserBlockingPriority,
    Js = r.unstable_NormalPriority,
    tL = r.unstable_LowPriority,
    lg = r.unstable_IdlePriority,
    nL = r.unstable_yieldValue,
    rL = r.unstable_setDisableYieldValue,
    tu = null,
    Ar = null,
    Ee = null,
    Ei = !1,
    Ja = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u'
  function aL(e) {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u') return !1
    var n = __REACT_DEVTOOLS_GLOBAL_HOOK__
    if (n.isDisabled) return !0
    if (!n.supportsFiber)
      return (
        c(
          'The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools'
        ),
        !0
      )
    try {
      Mt && (e = ot({}, e, { getLaneLabelMap: cL, injectProfilingHooks: uL })),
        (tu = n.inject(e)),
        (Ar = n)
    } catch (i) {
      c('React instrumentation encountered an error: %s.', i)
    }
    return !!n.checkDCE
  }
  function iL(e, n) {
    if (Ar && typeof Ar.onScheduleFiberRoot == 'function')
      try {
        Ar.onScheduleFiberRoot(tu, e, n)
      } catch (i) {
        Ei || ((Ei = !0), c('React instrumentation encountered an error: %s', i))
      }
  }
  function oL(e, n) {
    if (Ar && typeof Ar.onCommitFiberRoot == 'function')
      try {
        var i = (e.current.flags & Lt) === Lt
        if (Rt) {
          var s
          switch (n) {
            case Ca:
              s = vp
              break
            case uo:
              s = sg
              break
            case co:
              s = Js
              break
            case wp:
              s = lg
              break
            default:
              s = Js
              break
          }
          Ar.onCommitFiberRoot(tu, e, s, i)
        }
      } catch (u) {
        Ei || ((Ei = !0), c('React instrumentation encountered an error: %s', u))
      }
  }
  function sL(e) {
    if (Ar && typeof Ar.onPostCommitFiberRoot == 'function')
      try {
        Ar.onPostCommitFiberRoot(tu, e)
      } catch (n) {
        Ei || ((Ei = !0), c('React instrumentation encountered an error: %s', n))
      }
  }
  function lL(e) {
    if (Ar && typeof Ar.onCommitFiberUnmount == 'function')
      try {
        Ar.onCommitFiberUnmount(tu, e)
      } catch (n) {
        Ei || ((Ei = !0), c('React instrumentation encountered an error: %s', n))
      }
  }
  function pr(e) {
    if ((typeof nL == 'function' && (rL(e), l(e)), Ar && typeof Ar.setStrictMode == 'function'))
      try {
        Ar.setStrictMode(tu, e)
      } catch (n) {
        Ei || ((Ei = !0), c('React instrumentation encountered an error: %s', n))
      }
  }
  function uL(e) {
    Ee = e
  }
  function cL() {
    {
      for (var e = new Map(), n = 1, i = 0; i < cg; i++) {
        var s = AL(n)
        e.set(n, s), (n *= 2)
      }
      return e
    }
  }
  function fL(e) {
    Ee !== null && typeof Ee.markCommitStarted == 'function' && Ee.markCommitStarted(e)
  }
  function GC() {
    Ee !== null && typeof Ee.markCommitStopped == 'function' && Ee.markCommitStopped()
  }
  function Ac(e) {
    Ee !== null &&
      typeof Ee.markComponentRenderStarted == 'function' &&
      Ee.markComponentRenderStarted(e)
  }
  function nu() {
    Ee !== null &&
      typeof Ee.markComponentRenderStopped == 'function' &&
      Ee.markComponentRenderStopped()
  }
  function dL(e) {
    Ee !== null &&
      typeof Ee.markComponentPassiveEffectMountStarted == 'function' &&
      Ee.markComponentPassiveEffectMountStarted(e)
  }
  function pL() {
    Ee !== null &&
      typeof Ee.markComponentPassiveEffectMountStopped == 'function' &&
      Ee.markComponentPassiveEffectMountStopped()
  }
  function hL(e) {
    Ee !== null &&
      typeof Ee.markComponentPassiveEffectUnmountStarted == 'function' &&
      Ee.markComponentPassiveEffectUnmountStarted(e)
  }
  function mL() {
    Ee !== null &&
      typeof Ee.markComponentPassiveEffectUnmountStopped == 'function' &&
      Ee.markComponentPassiveEffectUnmountStopped()
  }
  function vL(e) {
    Ee !== null &&
      typeof Ee.markComponentLayoutEffectMountStarted == 'function' &&
      Ee.markComponentLayoutEffectMountStarted(e)
  }
  function gL() {
    Ee !== null &&
      typeof Ee.markComponentLayoutEffectMountStopped == 'function' &&
      Ee.markComponentLayoutEffectMountStopped()
  }
  function qC(e) {
    Ee !== null &&
      typeof Ee.markComponentLayoutEffectUnmountStarted == 'function' &&
      Ee.markComponentLayoutEffectUnmountStarted(e)
  }
  function KC() {
    Ee !== null &&
      typeof Ee.markComponentLayoutEffectUnmountStopped == 'function' &&
      Ee.markComponentLayoutEffectUnmountStopped()
  }
  function yL(e, n, i) {
    Ee !== null && typeof Ee.markComponentErrored == 'function' && Ee.markComponentErrored(e, n, i)
  }
  function bL(e, n, i) {
    Ee !== null &&
      typeof Ee.markComponentSuspended == 'function' &&
      Ee.markComponentSuspended(e, n, i)
  }
  function SL(e) {
    Ee !== null &&
      typeof Ee.markLayoutEffectsStarted == 'function' &&
      Ee.markLayoutEffectsStarted(e)
  }
  function xL() {
    Ee !== null && typeof Ee.markLayoutEffectsStopped == 'function' && Ee.markLayoutEffectsStopped()
  }
  function CL(e) {
    Ee !== null &&
      typeof Ee.markPassiveEffectsStarted == 'function' &&
      Ee.markPassiveEffectsStarted(e)
  }
  function wL() {
    Ee !== null &&
      typeof Ee.markPassiveEffectsStopped == 'function' &&
      Ee.markPassiveEffectsStopped()
  }
  function XC(e) {
    Ee !== null && typeof Ee.markRenderStarted == 'function' && Ee.markRenderStarted(e)
  }
  function EL() {
    Ee !== null && typeof Ee.markRenderYielded == 'function' && Ee.markRenderYielded()
  }
  function QC() {
    Ee !== null && typeof Ee.markRenderStopped == 'function' && Ee.markRenderStopped()
  }
  function TL(e) {
    Ee !== null && typeof Ee.markRenderScheduled == 'function' && Ee.markRenderScheduled(e)
  }
  function RL(e, n) {
    Ee !== null &&
      typeof Ee.markForceUpdateScheduled == 'function' &&
      Ee.markForceUpdateScheduled(e, n)
  }
  function ug(e, n) {
    Ee !== null &&
      typeof Ee.markStateUpdateScheduled == 'function' &&
      Ee.markStateUpdateScheduled(e, n)
  }
  var Ie = 0,
    yt = 1,
    Yt = 2,
    Hn = 8,
    Ti = 16,
    ZC = Math.clz32 ? Math.clz32 : DL,
    _L = Math.log,
    kL = Math.LN2
  function DL(e) {
    var n = e >>> 0
    return n === 0 ? 32 : (31 - ((_L(n) / kL) | 0)) | 0
  }
  var cg = 31,
    ue = 0,
    hr = 0,
    Ze = 1,
    ru = 2,
    lo = 4,
    el = 8,
    Ri = 16,
    Oc = 32,
    au = 4194240,
    Mc = 64,
    fg = 128,
    dg = 256,
    pg = 512,
    hg = 1024,
    mg = 2048,
    vg = 4096,
    gg = 8192,
    yg = 16384,
    bg = 32768,
    Sg = 65536,
    xg = 131072,
    Cg = 262144,
    wg = 524288,
    Eg = 1048576,
    Tg = 2097152,
    gp = 130023424,
    iu = 4194304,
    Rg = 8388608,
    _g = 16777216,
    kg = 33554432,
    Dg = 67108864,
    JC = iu,
    Pc = 134217728,
    ew = 268435455,
    Lc = 268435456,
    tl = 536870912,
    Sa = 1073741824
  function AL(e) {
    {
      if (e & Ze) return 'Sync'
      if (e & ru) return 'InputContinuousHydration'
      if (e & lo) return 'InputContinuous'
      if (e & el) return 'DefaultHydration'
      if (e & Ri) return 'Default'
      if (e & Oc) return 'TransitionHydration'
      if (e & au) return 'Transition'
      if (e & gp) return 'Retry'
      if (e & Pc) return 'SelectiveHydration'
      if (e & Lc) return 'IdleHydration'
      if (e & tl) return 'Idle'
      if (e & Sa) return 'Offscreen'
    }
  }
  var vn = -1,
    yp = Mc,
    bp = iu
  function zc(e) {
    switch (nl(e)) {
      case Ze:
        return Ze
      case ru:
        return ru
      case lo:
        return lo
      case el:
        return el
      case Ri:
        return Ri
      case Oc:
        return Oc
      case Mc:
      case fg:
      case dg:
      case pg:
      case hg:
      case mg:
      case vg:
      case gg:
      case yg:
      case bg:
      case Sg:
      case xg:
      case Cg:
      case wg:
      case Eg:
      case Tg:
        return e & au
      case iu:
      case Rg:
      case _g:
      case kg:
      case Dg:
        return e & gp
      case Pc:
        return Pc
      case Lc:
        return Lc
      case tl:
        return tl
      case Sa:
        return Sa
      default:
        return c('Should have found matching lanes. This is a bug in React.'), e
    }
  }
  function Sp(e, n) {
    var i = e.pendingLanes
    if (i === ue) return ue
    var s = ue,
      u = e.suspendedLanes,
      d = e.pingedLanes,
      v = i & ew
    if (v !== ue) {
      var y = v & ~u
      if (y !== ue) s = zc(y)
      else {
        var x = v & d
        x !== ue && (s = zc(x))
      }
    } else {
      var T = i & ~u
      T !== ue ? (s = zc(T)) : d !== ue && (s = zc(d))
    }
    if (s === ue) return ue
    if (n !== ue && n !== s && (n & u) === ue) {
      var _ = nl(s),
        N = nl(n)
      if (_ >= N || (_ === Ri && (N & au) !== ue)) return n
    }
    ;(s & lo) !== ue && (s |= i & Ri)
    var $ = e.entangledLanes
    if ($ !== ue)
      for (var q = e.entanglements, K = s & $; K > 0; ) {
        var re = rl(K),
          De = 1 << re
        ;(s |= q[re]), (K &= ~De)
      }
    return s
  }
  function OL(e, n) {
    for (var i = e.eventTimes, s = vn; n > 0; ) {
      var u = rl(n),
        d = 1 << u,
        v = i[u]
      v > s && (s = v), (n &= ~d)
    }
    return s
  }
  function ML(e, n) {
    switch (e) {
      case Ze:
      case ru:
      case lo:
        return n + 250
      case el:
      case Ri:
      case Oc:
      case Mc:
      case fg:
      case dg:
      case pg:
      case hg:
      case mg:
      case vg:
      case gg:
      case yg:
      case bg:
      case Sg:
      case xg:
      case Cg:
      case wg:
      case Eg:
      case Tg:
        return n + 5e3
      case iu:
      case Rg:
      case _g:
      case kg:
      case Dg:
        return vn
      case Pc:
      case Lc:
      case tl:
      case Sa:
        return vn
      default:
        return c('Should have found matching lanes. This is a bug in React.'), vn
    }
  }
  function PL(e, n) {
    for (
      var i = e.pendingLanes, s = e.suspendedLanes, u = e.pingedLanes, d = e.expirationTimes, v = i;
      v > 0;

    ) {
      var y = rl(v),
        x = 1 << y,
        T = d[y]
      T === vn
        ? ((x & s) === ue || (x & u) !== ue) && (d[y] = ML(x, n))
        : T <= n && (e.expiredLanes |= x),
        (v &= ~x)
    }
  }
  function LL(e) {
    return zc(e.pendingLanes)
  }
  function Ag(e) {
    var n = e.pendingLanes & ~Sa
    return n !== ue ? n : n & Sa ? Sa : ue
  }
  function zL(e) {
    return (e & Ze) !== ue
  }
  function Og(e) {
    return (e & ew) !== ue
  }
  function tw(e) {
    return (e & gp) === e
  }
  function $L(e) {
    var n = Ze | lo | Ri
    return (e & n) === ue
  }
  function FL(e) {
    return (e & au) === e
  }
  function xp(e, n) {
    var i = ru | lo | el | Ri
    return (n & i) !== ue
  }
  function NL(e, n) {
    return (n & e.expiredLanes) !== ue
  }
  function nw(e) {
    return (e & au) !== ue
  }
  function rw() {
    var e = yp
    return (yp <<= 1), (yp & au) === ue && (yp = Mc), e
  }
  function BL() {
    var e = bp
    return (bp <<= 1), (bp & gp) === ue && (bp = iu), e
  }
  function nl(e) {
    return e & -e
  }
  function $c(e) {
    return nl(e)
  }
  function rl(e) {
    return 31 - ZC(e)
  }
  function Mg(e) {
    return rl(e)
  }
  function xa(e, n) {
    return (e & n) !== ue
  }
  function ou(e, n) {
    return (e & n) === n
  }
  function lt(e, n) {
    return e | n
  }
  function Cp(e, n) {
    return e & ~n
  }
  function aw(e, n) {
    return e & n
  }
  function Mee(e) {
    return e
  }
  function jL(e, n) {
    return e !== hr && e < n ? e : n
  }
  function Pg(e) {
    for (var n = [], i = 0; i < cg; i++) n.push(e)
    return n
  }
  function Fc(e, n, i) {
    ;(e.pendingLanes |= n), n !== tl && ((e.suspendedLanes = ue), (e.pingedLanes = ue))
    var s = e.eventTimes,
      u = Mg(n)
    s[u] = i
  }
  function UL(e, n) {
    ;(e.suspendedLanes |= n), (e.pingedLanes &= ~n)
    for (var i = e.expirationTimes, s = n; s > 0; ) {
      var u = rl(s),
        d = 1 << u
      ;(i[u] = vn), (s &= ~d)
    }
  }
  function iw(e, n, i) {
    e.pingedLanes |= e.suspendedLanes & n
  }
  function VL(e, n) {
    var i = e.pendingLanes & ~n
    ;(e.pendingLanes = n),
      (e.suspendedLanes = ue),
      (e.pingedLanes = ue),
      (e.expiredLanes &= n),
      (e.mutableReadLanes &= n),
      (e.entangledLanes &= n)
    for (var s = e.entanglements, u = e.eventTimes, d = e.expirationTimes, v = i; v > 0; ) {
      var y = rl(v),
        x = 1 << y
      ;(s[y] = ue), (u[y] = vn), (d[y] = vn), (v &= ~x)
    }
  }
  function Lg(e, n) {
    for (var i = (e.entangledLanes |= n), s = e.entanglements, u = i; u; ) {
      var d = rl(u),
        v = 1 << d
      ;(v & n) | (s[d] & n) && (s[d] |= n), (u &= ~v)
    }
  }
  function IL(e, n) {
    var i = nl(n),
      s
    switch (i) {
      case lo:
        s = ru
        break
      case Ri:
        s = el
        break
      case Mc:
      case fg:
      case dg:
      case pg:
      case hg:
      case mg:
      case vg:
      case gg:
      case yg:
      case bg:
      case Sg:
      case xg:
      case Cg:
      case wg:
      case Eg:
      case Tg:
      case iu:
      case Rg:
      case _g:
      case kg:
      case Dg:
        s = Oc
        break
      case tl:
        s = Lc
        break
      default:
        s = hr
        break
    }
    return (s & (e.suspendedLanes | n)) !== hr ? hr : s
  }
  function ow(e, n, i) {
    if (Ja)
      for (var s = e.pendingUpdatersLaneMap; i > 0; ) {
        var u = Mg(i),
          d = 1 << u,
          v = s[u]
        v.add(n), (i &= ~d)
      }
  }
  function sw(e, n) {
    if (Ja)
      for (var i = e.pendingUpdatersLaneMap, s = e.memoizedUpdaters; n > 0; ) {
        var u = Mg(n),
          d = 1 << u,
          v = i[u]
        v.size > 0 &&
          (v.forEach(function (y) {
            var x = y.alternate
            ;(x === null || !s.has(x)) && s.add(y)
          }),
          v.clear()),
          (n &= ~d)
      }
  }
  function lw(e, n) {
    return null
  }
  var Ca = Ze,
    uo = lo,
    co = Ri,
    wp = tl,
    Nc = hr
  function ei() {
    return Nc
  }
  function mr(e) {
    Nc = e
  }
  function HL(e, n) {
    var i = Nc
    try {
      return (Nc = e), n()
    } finally {
      Nc = i
    }
  }
  function WL(e, n) {
    return e !== 0 && e < n ? e : n
  }
  function YL(e, n) {
    return e === 0 || e > n ? e : n
  }
  function zg(e, n) {
    return e !== 0 && e < n
  }
  function uw(e) {
    var n = nl(e)
    return zg(Ca, n) ? (zg(uo, n) ? (Og(n) ? co : wp) : uo) : Ca
  }
  function Ep(e) {
    var n = e.current.memoizedState
    return n.isDehydrated
  }
  var cw
  function GL(e) {
    cw = e
  }
  function qL(e) {
    cw(e)
  }
  var $g
  function KL(e) {
    $g = e
  }
  var fw
  function XL(e) {
    fw = e
  }
  var dw
  function QL(e) {
    dw = e
  }
  var pw
  function ZL(e) {
    pw = e
  }
  var Fg = !1,
    Tp = [],
    qo = null,
    Ko = null,
    Xo = null,
    Bc = new Map(),
    jc = new Map(),
    Qo = [],
    JL = [
      'mousedown',
      'mouseup',
      'touchcancel',
      'touchend',
      'touchstart',
      'auxclick',
      'dblclick',
      'pointercancel',
      'pointerdown',
      'pointerup',
      'dragend',
      'dragstart',
      'drop',
      'compositionend',
      'compositionstart',
      'keydown',
      'keypress',
      'keyup',
      'input',
      'textInput',
      'copy',
      'cut',
      'paste',
      'click',
      'change',
      'contextmenu',
      'reset',
      'submit',
    ]
  function ez(e) {
    return JL.indexOf(e) > -1
  }
  function tz(e, n, i, s, u) {
    return {
      blockedOn: e,
      domEventName: n,
      eventSystemFlags: i,
      nativeEvent: u,
      targetContainers: [s],
    }
  }
  function hw(e, n) {
    switch (e) {
      case 'focusin':
      case 'focusout':
        qo = null
        break
      case 'dragenter':
      case 'dragleave':
        Ko = null
        break
      case 'mouseover':
      case 'mouseout':
        Xo = null
        break
      case 'pointerover':
      case 'pointerout': {
        var i = n.pointerId
        Bc.delete(i)
        break
      }
      case 'gotpointercapture':
      case 'lostpointercapture': {
        var s = n.pointerId
        jc.delete(s)
        break
      }
    }
  }
  function Uc(e, n, i, s, u, d) {
    if (e === null || e.nativeEvent !== d) {
      var v = tz(n, i, s, u, d)
      if (n !== null) {
        var y = es(n)
        y !== null && $g(y)
      }
      return v
    }
    e.eventSystemFlags |= s
    var x = e.targetContainers
    return u !== null && x.indexOf(u) === -1 && x.push(u), e
  }
  function nz(e, n, i, s, u) {
    switch (n) {
      case 'focusin': {
        var d = u
        return (qo = Uc(qo, e, n, i, s, d)), !0
      }
      case 'dragenter': {
        var v = u
        return (Ko = Uc(Ko, e, n, i, s, v)), !0
      }
      case 'mouseover': {
        var y = u
        return (Xo = Uc(Xo, e, n, i, s, y)), !0
      }
      case 'pointerover': {
        var x = u,
          T = x.pointerId
        return Bc.set(T, Uc(Bc.get(T) || null, e, n, i, s, x)), !0
      }
      case 'gotpointercapture': {
        var _ = u,
          N = _.pointerId
        return jc.set(N, Uc(jc.get(N) || null, e, n, i, s, _)), !0
      }
    }
    return !1
  }
  function mw(e) {
    var n = ol(e.target)
    if (n !== null) {
      var i = Zs(n)
      if (i !== null) {
        var s = i.tag
        if (s === j) {
          var u = BC(i)
          if (u !== null) {
            ;(e.blockedOn = u),
              pw(e.priority, function () {
                fw(i)
              })
            return
          }
        } else if (s === b) {
          var d = i.stateNode
          if (Ep(d)) {
            e.blockedOn = jC(i)
            return
          }
        }
      }
    }
    e.blockedOn = null
  }
  function rz(e) {
    for (
      var n = dw(), i = { blockedOn: null, target: e, priority: n }, s = 0;
      s < Qo.length && zg(n, Qo[s].priority);
      s++
    );
    Qo.splice(s, 0, i), s === 0 && mw(i)
  }
  function Rp(e) {
    if (e.blockedOn !== null) return !1
    for (var n = e.targetContainers; n.length > 0; ) {
      var i = n[0],
        s = jg(e.domEventName, e.eventSystemFlags, i, e.nativeEvent)
      if (s === null) {
        var u = e.nativeEvent,
          d = new u.constructor(u.type, u)
        DP(d), u.target.dispatchEvent(d), AP()
      } else {
        var v = es(s)
        return v !== null && $g(v), (e.blockedOn = s), !1
      }
      n.shift()
    }
    return !0
  }
  function vw(e, n, i) {
    Rp(e) && i.delete(n)
  }
  function az() {
    ;(Fg = !1),
      qo !== null && Rp(qo) && (qo = null),
      Ko !== null && Rp(Ko) && (Ko = null),
      Xo !== null && Rp(Xo) && (Xo = null),
      Bc.forEach(vw),
      jc.forEach(vw)
  }
  function Vc(e, n) {
    e.blockedOn === n &&
      ((e.blockedOn = null),
      Fg || ((Fg = !0), r.unstable_scheduleCallback(r.unstable_NormalPriority, az)))
  }
  function Ic(e) {
    if (Tp.length > 0) {
      Vc(Tp[0], e)
      for (var n = 1; n < Tp.length; n++) {
        var i = Tp[n]
        i.blockedOn === e && (i.blockedOn = null)
      }
    }
    qo !== null && Vc(qo, e), Ko !== null && Vc(Ko, e), Xo !== null && Vc(Xo, e)
    var s = function (y) {
      return Vc(y, e)
    }
    Bc.forEach(s), jc.forEach(s)
    for (var u = 0; u < Qo.length; u++) {
      var d = Qo[u]
      d.blockedOn === e && (d.blockedOn = null)
    }
    for (; Qo.length > 0; ) {
      var v = Qo[0]
      if (v.blockedOn !== null) break
      mw(v), v.blockedOn === null && Qo.shift()
    }
  }
  var su = a.ReactCurrentBatchConfig,
    Ng = !0
  function gw(e) {
    Ng = !!e
  }
  function iz() {
    return Ng
  }
  function oz(e, n, i) {
    var s = yw(n),
      u
    switch (s) {
      case Ca:
        u = sz
        break
      case uo:
        u = lz
        break
      case co:
      default:
        u = Bg
        break
    }
    return u.bind(null, n, i, e)
  }
  function sz(e, n, i, s) {
    var u = ei(),
      d = su.transition
    su.transition = null
    try {
      mr(Ca), Bg(e, n, i, s)
    } finally {
      mr(u), (su.transition = d)
    }
  }
  function lz(e, n, i, s) {
    var u = ei(),
      d = su.transition
    su.transition = null
    try {
      mr(uo), Bg(e, n, i, s)
    } finally {
      mr(u), (su.transition = d)
    }
  }
  function Bg(e, n, i, s) {
    Ng && uz(e, n, i, s)
  }
  function uz(e, n, i, s) {
    var u = jg(e, n, i, s)
    if (u === null) {
      ey(e, n, s, _p, i), hw(e, s)
      return
    }
    if (nz(u, e, n, i, s)) {
      s.stopPropagation()
      return
    }
    if ((hw(e, s), n & wc && ez(e))) {
      for (; u !== null; ) {
        var d = es(u)
        d !== null && qL(d)
        var v = jg(e, n, i, s)
        if ((v === null && ey(e, n, s, _p, i), v === u)) break
        u = v
      }
      u !== null && s.stopPropagation()
      return
    }
    ey(e, n, s, null, i)
  }
  var _p = null
  function jg(e, n, i, s) {
    _p = null
    var u = Gv(s),
      d = ol(u)
    if (d !== null) {
      var v = Zs(d)
      if (v === null) d = null
      else {
        var y = v.tag
        if (y === j) {
          var x = BC(v)
          if (x !== null) return x
          d = null
        } else if (y === b) {
          var T = v.stateNode
          if (Ep(T)) return jC(v)
          d = null
        } else v !== d && (d = null)
      }
    }
    return (_p = d), null
  }
  function yw(e) {
    switch (e) {
      case 'cancel':
      case 'click':
      case 'close':
      case 'contextmenu':
      case 'copy':
      case 'cut':
      case 'auxclick':
      case 'dblclick':
      case 'dragend':
      case 'dragstart':
      case 'drop':
      case 'focusin':
      case 'focusout':
      case 'input':
      case 'invalid':
      case 'keydown':
      case 'keypress':
      case 'keyup':
      case 'mousedown':
      case 'mouseup':
      case 'paste':
      case 'pause':
      case 'play':
      case 'pointercancel':
      case 'pointerdown':
      case 'pointerup':
      case 'ratechange':
      case 'reset':
      case 'resize':
      case 'seeked':
      case 'submit':
      case 'touchcancel':
      case 'touchend':
      case 'touchstart':
      case 'volumechange':
      case 'change':
      case 'selectionchange':
      case 'textInput':
      case 'compositionstart':
      case 'compositionend':
      case 'compositionupdate':
      case 'beforeblur':
      case 'afterblur':
      case 'beforeinput':
      case 'blur':
      case 'fullscreenchange':
      case 'focus':
      case 'hashchange':
      case 'popstate':
      case 'select':
      case 'selectstart':
        return Ca
      case 'drag':
      case 'dragenter':
      case 'dragexit':
      case 'dragleave':
      case 'dragover':
      case 'mousemove':
      case 'mouseout':
      case 'mouseover':
      case 'pointermove':
      case 'pointerout':
      case 'pointerover':
      case 'scroll':
      case 'toggle':
      case 'touchmove':
      case 'wheel':
      case 'mouseenter':
      case 'mouseleave':
      case 'pointerenter':
      case 'pointerleave':
        return uo
      case 'message': {
        var n = eL()
        switch (n) {
          case vp:
            return Ca
          case sg:
            return uo
          case Js:
          case tL:
            return co
          case lg:
            return wp
          default:
            return co
        }
      }
      default:
        return co
    }
  }
  function cz(e, n, i) {
    return e.addEventListener(n, i, !1), i
  }
  function fz(e, n, i) {
    return e.addEventListener(n, i, !0), i
  }
  function dz(e, n, i, s) {
    return e.addEventListener(n, i, { capture: !0, passive: s }), i
  }
  function pz(e, n, i, s) {
    return e.addEventListener(n, i, { passive: s }), i
  }
  var Hc = null,
    Ug = null,
    Wc = null
  function hz(e) {
    return (Hc = e), (Ug = Sw()), !0
  }
  function mz() {
    ;(Hc = null), (Ug = null), (Wc = null)
  }
  function bw() {
    if (Wc) return Wc
    var e,
      n = Ug,
      i = n.length,
      s,
      u = Sw(),
      d = u.length
    for (e = 0; e < i && n[e] === u[e]; e++);
    var v = i - e
    for (s = 1; s <= v && n[i - s] === u[d - s]; s++);
    var y = s > 1 ? 1 - s : void 0
    return (Wc = u.slice(e, y)), Wc
  }
  function Sw() {
    return 'value' in Hc ? Hc.value : Hc.textContent
  }
  function kp(e) {
    var n,
      i = e.keyCode
    return (
      'charCode' in e ? ((n = e.charCode), n === 0 && i === 13 && (n = 13)) : (n = i),
      n === 10 && (n = 13),
      n >= 32 || n === 13 ? n : 0
    )
  }
  function Dp() {
    return !0
  }
  function xw() {
    return !1
  }
  function wa(e) {
    function n(i, s, u, d, v) {
      ;(this._reactName = i),
        (this._targetInst = u),
        (this.type = s),
        (this.nativeEvent = d),
        (this.target = v),
        (this.currentTarget = null)
      for (var y in e)
        if (e.hasOwnProperty(y)) {
          var x = e[y]
          x ? (this[y] = x(d)) : (this[y] = d[y])
        }
      var T = d.defaultPrevented != null ? d.defaultPrevented : d.returnValue === !1
      return (
        T ? (this.isDefaultPrevented = Dp) : (this.isDefaultPrevented = xw),
        (this.isPropagationStopped = xw),
        this
      )
    }
    return (
      ot(n.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0
          var i = this.nativeEvent
          i &&
            (i.preventDefault
              ? i.preventDefault()
              : typeof i.returnValue != 'unknown' && (i.returnValue = !1),
            (this.isDefaultPrevented = Dp))
        },
        stopPropagation: function () {
          var i = this.nativeEvent
          i &&
            (i.stopPropagation
              ? i.stopPropagation()
              : typeof i.cancelBubble != 'unknown' && (i.cancelBubble = !0),
            (this.isPropagationStopped = Dp))
        },
        persist: function () {},
        isPersistent: Dp,
      }),
      n
    )
  }
  var lu = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (e) {
        return e.timeStamp || Date.now()
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Vg = wa(lu),
    Yc = ot({}, lu, { view: 0, detail: 0 }),
    vz = wa(Yc),
    Ig,
    Hg,
    Gc
  function gz(e) {
    e !== Gc &&
      (Gc && e.type === 'mousemove'
        ? ((Ig = e.screenX - Gc.screenX), (Hg = e.screenY - Gc.screenY))
        : ((Ig = 0), (Hg = 0)),
      (Gc = e))
  }
  var Ap = ot({}, Yc, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Yg,
      button: 0,
      buttons: 0,
      relatedTarget: function (e) {
        return e.relatedTarget === void 0
          ? e.fromElement === e.srcElement
            ? e.toElement
            : e.fromElement
          : e.relatedTarget
      },
      movementX: function (e) {
        return 'movementX' in e ? e.movementX : (gz(e), Ig)
      },
      movementY: function (e) {
        return 'movementY' in e ? e.movementY : Hg
      },
    }),
    Cw = wa(Ap),
    yz = ot({}, Ap, { dataTransfer: 0 }),
    bz = wa(yz),
    Sz = ot({}, Yc, { relatedTarget: 0 }),
    Wg = wa(Sz),
    xz = ot({}, lu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Cz = wa(xz),
    wz = ot({}, lu, {
      clipboardData: function (e) {
        return 'clipboardData' in e ? e.clipboardData : window.clipboardData
      },
    }),
    Ez = wa(wz),
    Tz = ot({}, lu, { data: 0 }),
    ww = wa(Tz),
    Rz = ww,
    _z = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified',
    },
    kz = {
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      45: 'Insert',
      46: 'Delete',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NumLock',
      145: 'ScrollLock',
      224: 'Meta',
    }
  function Dz(e) {
    if (e.key) {
      var n = _z[e.key] || e.key
      if (n !== 'Unidentified') return n
    }
    if (e.type === 'keypress') {
      var i = kp(e)
      return i === 13 ? 'Enter' : String.fromCharCode(i)
    }
    return e.type === 'keydown' || e.type === 'keyup' ? kz[e.keyCode] || 'Unidentified' : ''
  }
  var Az = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
  function Oz(e) {
    var n = this,
      i = n.nativeEvent
    if (i.getModifierState) return i.getModifierState(e)
    var s = Az[e]
    return s ? !!i[s] : !1
  }
  function Yg(e) {
    return Oz
  }
  var Mz = ot({}, Yc, {
      key: Dz,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Yg,
      charCode: function (e) {
        return e.type === 'keypress' ? kp(e) : 0
      },
      keyCode: function (e) {
        return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0
      },
      which: function (e) {
        return e.type === 'keypress'
          ? kp(e)
          : e.type === 'keydown' || e.type === 'keyup'
          ? e.keyCode
          : 0
      },
    }),
    Pz = wa(Mz),
    Lz = ot({}, Ap, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    Ew = wa(Lz),
    zz = ot({}, Yc, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Yg,
    }),
    $z = wa(zz),
    Fz = ot({}, lu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Nz = wa(Fz),
    Bz = ot({}, Ap, {
      deltaX: function (e) {
        return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0
      },
      deltaY: function (e) {
        return 'deltaY' in e
          ? e.deltaY
          : 'wheelDeltaY' in e
          ? -e.wheelDeltaY
          : 'wheelDelta' in e
          ? -e.wheelDelta
          : 0
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    jz = wa(Bz),
    Uz = [9, 13, 27, 32],
    Tw = 229,
    Gg = wt && 'CompositionEvent' in window,
    qc = null
  wt && 'documentMode' in document && (qc = document.documentMode)
  var Vz = wt && 'TextEvent' in window && !qc,
    Rw = wt && (!Gg || (qc && qc > 8 && qc <= 11)),
    _w = 32,
    kw = String.fromCharCode(_w)
  function Iz() {
    Ct('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']),
      Ct('onCompositionEnd', [
        'compositionend',
        'focusout',
        'keydown',
        'keypress',
        'keyup',
        'mousedown',
      ]),
      Ct('onCompositionStart', [
        'compositionstart',
        'focusout',
        'keydown',
        'keypress',
        'keyup',
        'mousedown',
      ]),
      Ct('onCompositionUpdate', [
        'compositionupdate',
        'focusout',
        'keydown',
        'keypress',
        'keyup',
        'mousedown',
      ])
  }
  var Dw = !1
  function Hz(e) {
    return (e.ctrlKey || e.altKey || e.metaKey) && !(e.ctrlKey && e.altKey)
  }
  function Wz(e) {
    switch (e) {
      case 'compositionstart':
        return 'onCompositionStart'
      case 'compositionend':
        return 'onCompositionEnd'
      case 'compositionupdate':
        return 'onCompositionUpdate'
    }
  }
  function Yz(e, n) {
    return e === 'keydown' && n.keyCode === Tw
  }
  function Aw(e, n) {
    switch (e) {
      case 'keyup':
        return Uz.indexOf(n.keyCode) !== -1
      case 'keydown':
        return n.keyCode !== Tw
      case 'keypress':
      case 'mousedown':
      case 'focusout':
        return !0
      default:
        return !1
    }
  }
  function Ow(e) {
    var n = e.detail
    return typeof n == 'object' && 'data' in n ? n.data : null
  }
  function Mw(e) {
    return e.locale === 'ko'
  }
  var uu = !1
  function Gz(e, n, i, s, u) {
    var d, v
    if (
      (Gg
        ? (d = Wz(n))
        : uu
        ? Aw(n, s) && (d = 'onCompositionEnd')
        : Yz(n, s) && (d = 'onCompositionStart'),
      !d)
    )
      return null
    Rw &&
      !Mw(s) &&
      (!uu && d === 'onCompositionStart'
        ? (uu = hz(u))
        : d === 'onCompositionEnd' && uu && (v = bw()))
    var y = zp(i, d)
    if (y.length > 0) {
      var x = new ww(d, n, null, s, u)
      if ((e.push({ event: x, listeners: y }), v)) x.data = v
      else {
        var T = Ow(s)
        T !== null && (x.data = T)
      }
    }
  }
  function qz(e, n) {
    switch (e) {
      case 'compositionend':
        return Ow(n)
      case 'keypress':
        var i = n.which
        return i !== _w ? null : ((Dw = !0), kw)
      case 'textInput':
        var s = n.data
        return s === kw && Dw ? null : s
      default:
        return null
    }
  }
  function Kz(e, n) {
    if (uu) {
      if (e === 'compositionend' || (!Gg && Aw(e, n))) {
        var i = bw()
        return mz(), (uu = !1), i
      }
      return null
    }
    switch (e) {
      case 'paste':
        return null
      case 'keypress':
        if (!Hz(n)) {
          if (n.char && n.char.length > 1) return n.char
          if (n.which) return String.fromCharCode(n.which)
        }
        return null
      case 'compositionend':
        return Rw && !Mw(n) ? null : n.data
      default:
        return null
    }
  }
  function Xz(e, n, i, s, u) {
    var d
    if ((Vz ? (d = qz(n, s)) : (d = Kz(n, s)), !d)) return null
    var v = zp(i, 'onBeforeInput')
    if (v.length > 0) {
      var y = new Rz('onBeforeInput', 'beforeinput', null, s, u)
      e.push({ event: y, listeners: v }), (y.data = d)
    }
  }
  function Qz(e, n, i, s, u, d, v) {
    Gz(e, n, i, s, u), Xz(e, n, i, s, u)
  }
  var Zz = {
    'color': !0,
    'date': !0,
    'datetime': !0,
    'datetime-local': !0,
    'email': !0,
    'month': !0,
    'number': !0,
    'password': !0,
    'range': !0,
    'search': !0,
    'tel': !0,
    'text': !0,
    'time': !0,
    'url': !0,
    'week': !0,
  }
  function Pw(e) {
    var n = e && e.nodeName && e.nodeName.toLowerCase()
    return n === 'input' ? !!Zz[e.type] : n === 'textarea'
  }
  /**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */ function Jz(e) {
    if (!wt) return !1
    var n = 'on' + e,
      i = n in document
    if (!i) {
      var s = document.createElement('div')
      s.setAttribute(n, 'return;'), (i = typeof s[n] == 'function')
    }
    return i
  }
  function e$() {
    Ct('onChange', [
      'change',
      'click',
      'focusin',
      'focusout',
      'input',
      'keydown',
      'keyup',
      'selectionchange',
    ])
  }
  function Lw(e, n, i, s) {
    OC(s)
    var u = zp(n, 'onChange')
    if (u.length > 0) {
      var d = new Vg('onChange', 'change', null, i, s)
      e.push({ event: d, listeners: u })
    }
  }
  var Kc = null,
    Xc = null
  function t$(e) {
    var n = e.nodeName && e.nodeName.toLowerCase()
    return n === 'select' || (n === 'input' && e.type === 'file')
  }
  function n$(e) {
    var n = []
    Lw(n, Xc, e, Gv(e)), zC(r$, n)
  }
  function r$(e) {
    Zw(e, 0)
  }
  function Op(e) {
    var n = mu(e)
    if (A(n)) return e
  }
  function a$(e, n) {
    if (e === 'change') return n
  }
  var zw = !1
  wt && (zw = Jz('input') && (!document.documentMode || document.documentMode > 9))
  function i$(e, n) {
    ;(Kc = e), (Xc = n), Kc.attachEvent('onpropertychange', Fw)
  }
  function $w() {
    Kc && (Kc.detachEvent('onpropertychange', Fw), (Kc = null), (Xc = null))
  }
  function Fw(e) {
    e.propertyName === 'value' && Op(Xc) && n$(e)
  }
  function o$(e, n, i) {
    e === 'focusin' ? ($w(), i$(n, i)) : e === 'focusout' && $w()
  }
  function s$(e, n) {
    if (e === 'selectionchange' || e === 'keyup' || e === 'keydown') return Op(Xc)
  }
  function l$(e) {
    var n = e.nodeName
    return n && n.toLowerCase() === 'input' && (e.type === 'checkbox' || e.type === 'radio')
  }
  function u$(e, n) {
    if (e === 'click') return Op(n)
  }
  function c$(e, n) {
    if (e === 'input' || e === 'change') return Op(n)
  }
  function f$(e) {
    var n = e._wrapperState
    !n || !n.controlled || e.type !== 'number' || We(e, 'number', e.value)
  }
  function d$(e, n, i, s, u, d, v) {
    var y = i ? mu(i) : window,
      x,
      T
    if (
      (t$(y) ? (x = a$) : Pw(y) ? (zw ? (x = c$) : ((x = s$), (T = o$))) : l$(y) && (x = u$), x)
    ) {
      var _ = x(n, i)
      if (_) {
        Lw(e, _, s, u)
        return
      }
    }
    T && T(n, y, i), n === 'focusout' && f$(y)
  }
  function p$() {
    xe('onMouseEnter', ['mouseout', 'mouseover']),
      xe('onMouseLeave', ['mouseout', 'mouseover']),
      xe('onPointerEnter', ['pointerout', 'pointerover']),
      xe('onPointerLeave', ['pointerout', 'pointerover'])
  }
  function h$(e, n, i, s, u, d, v) {
    var y = n === 'mouseover' || n === 'pointerover',
      x = n === 'mouseout' || n === 'pointerout'
    if (y && !OP(s)) {
      var T = s.relatedTarget || s.fromElement
      if (T && (ol(T) || df(T))) return
    }
    if (!(!x && !y)) {
      var _
      if (u.window === u) _ = u
      else {
        var N = u.ownerDocument
        N ? (_ = N.defaultView || N.parentWindow) : (_ = window)
      }
      var $, q
      if (x) {
        var K = s.relatedTarget || s.toElement
        if ((($ = i), (q = K ? ol(K) : null), q !== null)) {
          var re = Zs(q)
          ;(q !== re || (q.tag !== w && q.tag !== k)) && (q = null)
        }
      } else ($ = null), (q = i)
      if ($ !== q) {
        var De = Cw,
          je = 'onMouseLeave',
          Fe = 'onMouseEnter',
          St = 'mouse'
        ;(n === 'pointerout' || n === 'pointerover') &&
          ((De = Ew), (je = 'onPointerLeave'), (Fe = 'onPointerEnter'), (St = 'pointer'))
        var ht = $ == null ? _ : mu($),
          H = q == null ? _ : mu(q),
          ae = new De(je, St + 'leave', $, s, u)
        ;(ae.target = ht), (ae.relatedTarget = H)
        var W = null,
          fe = ol(u)
        if (fe === i) {
          var Ae = new De(Fe, St + 'enter', q, s, u)
          ;(Ae.target = H), (Ae.relatedTarget = ht), (W = Ae)
        }
        N$(e, ae, W, $, q)
      }
    }
  }
  function m$(e, n) {
    return (e === n && (e !== 0 || 1 / e === 1 / n)) || (e !== e && n !== n)
  }
  var Ea = typeof Object.is == 'function' ? Object.is : m$
  function Qc(e, n) {
    if (Ea(e, n)) return !0
    if (typeof e != 'object' || e === null || typeof n != 'object' || n === null) return !1
    var i = Object.keys(e),
      s = Object.keys(n)
    if (i.length !== s.length) return !1
    for (var u = 0; u < i.length; u++) {
      var d = i[u]
      if (!Zt.call(n, d) || !Ea(e[d], n[d])) return !1
    }
    return !0
  }
  function Nw(e) {
    for (; e && e.firstChild; ) e = e.firstChild
    return e
  }
  function v$(e) {
    for (; e; ) {
      if (e.nextSibling) return e.nextSibling
      e = e.parentNode
    }
  }
  function Bw(e, n) {
    for (var i = Nw(e), s = 0, u = 0; i; ) {
      if (i.nodeType === no) {
        if (((u = s + i.textContent.length), s <= n && u >= n)) return { node: i, offset: n - s }
        s = u
      }
      i = Nw(v$(i))
    }
  }
  function g$(e) {
    var n = e.ownerDocument,
      i = (n && n.defaultView) || window,
      s = i.getSelection && i.getSelection()
    if (!s || s.rangeCount === 0) return null
    var u = s.anchorNode,
      d = s.anchorOffset,
      v = s.focusNode,
      y = s.focusOffset
    try {
      u.nodeType, v.nodeType
    } catch {
      return null
    }
    return y$(e, u, d, v, y)
  }
  function y$(e, n, i, s, u) {
    var d = 0,
      v = -1,
      y = -1,
      x = 0,
      T = 0,
      _ = e,
      N = null
    e: for (;;) {
      for (
        var $ = null;
        _ === n && (i === 0 || _.nodeType === no) && (v = d + i),
          _ === s && (u === 0 || _.nodeType === no) && (y = d + u),
          _.nodeType === no && (d += _.nodeValue.length),
          ($ = _.firstChild) !== null;

      )
        (N = _), (_ = $)
      for (;;) {
        if (_ === e) break e
        if (
          (N === n && ++x === i && (v = d),
          N === s && ++T === u && (y = d),
          ($ = _.nextSibling) !== null)
        )
          break
        ;(_ = N), (N = _.parentNode)
      }
      _ = $
    }
    return v === -1 || y === -1 ? null : { start: v, end: y }
  }
  function b$(e, n) {
    var i = e.ownerDocument || document,
      s = (i && i.defaultView) || window
    if (s.getSelection) {
      var u = s.getSelection(),
        d = e.textContent.length,
        v = Math.min(n.start, d),
        y = n.end === void 0 ? v : Math.min(n.end, d)
      if (!u.extend && v > y) {
        var x = y
        ;(y = v), (v = x)
      }
      var T = Bw(e, v),
        _ = Bw(e, y)
      if (T && _) {
        if (
          u.rangeCount === 1 &&
          u.anchorNode === T.node &&
          u.anchorOffset === T.offset &&
          u.focusNode === _.node &&
          u.focusOffset === _.offset
        )
          return
        var N = i.createRange()
        N.setStart(T.node, T.offset),
          u.removeAllRanges(),
          v > y
            ? (u.addRange(N), u.extend(_.node, _.offset))
            : (N.setEnd(_.node, _.offset), u.addRange(N))
      }
    }
  }
  function jw(e) {
    return e && e.nodeType === no
  }
  function Uw(e, n) {
    return !e || !n
      ? !1
      : e === n
      ? !0
      : jw(e)
      ? !1
      : jw(n)
      ? Uw(e, n.parentNode)
      : 'contains' in e
      ? e.contains(n)
      : e.compareDocumentPosition
      ? !!(e.compareDocumentPosition(n) & 16)
      : !1
  }
  function S$(e) {
    return e && e.ownerDocument && Uw(e.ownerDocument.documentElement, e)
  }
  function x$(e) {
    try {
      return typeof e.contentWindow.location.href == 'string'
    } catch {
      return !1
    }
  }
  function Vw() {
    for (var e = window, n = F(); n instanceof e.HTMLIFrameElement; ) {
      if (x$(n)) e = n.contentWindow
      else return n
      n = F(e.document)
    }
    return n
  }
  function qg(e) {
    var n = e && e.nodeName && e.nodeName.toLowerCase()
    return (
      n &&
      ((n === 'input' &&
        (e.type === 'text' ||
          e.type === 'search' ||
          e.type === 'tel' ||
          e.type === 'url' ||
          e.type === 'password')) ||
        n === 'textarea' ||
        e.contentEditable === 'true')
    )
  }
  function C$() {
    var e = Vw()
    return { focusedElem: e, selectionRange: qg(e) ? E$(e) : null }
  }
  function w$(e) {
    var n = Vw(),
      i = e.focusedElem,
      s = e.selectionRange
    if (n !== i && S$(i)) {
      s !== null && qg(i) && T$(i, s)
      for (var u = [], d = i; (d = d.parentNode); )
        d.nodeType === ra && u.push({ element: d, left: d.scrollLeft, top: d.scrollTop })
      typeof i.focus == 'function' && i.focus()
      for (var v = 0; v < u.length; v++) {
        var y = u[v]
        ;(y.element.scrollLeft = y.left), (y.element.scrollTop = y.top)
      }
    }
  }
  function E$(e) {
    var n
    return (
      'selectionStart' in e ? (n = { start: e.selectionStart, end: e.selectionEnd }) : (n = g$(e)),
      n || { start: 0, end: 0 }
    )
  }
  function T$(e, n) {
    var i = n.start,
      s = n.end
    s === void 0 && (s = i),
      'selectionStart' in e
        ? ((e.selectionStart = i), (e.selectionEnd = Math.min(s, e.value.length)))
        : b$(e, n)
  }
  var R$ = wt && 'documentMode' in document && document.documentMode <= 11
  function _$() {
    Ct('onSelect', [
      'focusout',
      'contextmenu',
      'dragend',
      'focusin',
      'keydown',
      'keyup',
      'mousedown',
      'mouseup',
      'selectionchange',
    ])
  }
  var cu = null,
    Kg = null,
    Zc = null,
    Xg = !1
  function k$(e) {
    if ('selectionStart' in e && qg(e)) return { start: e.selectionStart, end: e.selectionEnd }
    var n = (e.ownerDocument && e.ownerDocument.defaultView) || window,
      i = n.getSelection()
    return {
      anchorNode: i.anchorNode,
      anchorOffset: i.anchorOffset,
      focusNode: i.focusNode,
      focusOffset: i.focusOffset,
    }
  }
  function D$(e) {
    return e.window === e ? e.document : e.nodeType === ro ? e : e.ownerDocument
  }
  function Iw(e, n, i) {
    var s = D$(i)
    if (!(Xg || cu == null || cu !== F(s))) {
      var u = k$(cu)
      if (!Zc || !Qc(Zc, u)) {
        Zc = u
        var d = zp(Kg, 'onSelect')
        if (d.length > 0) {
          var v = new Vg('onSelect', 'select', null, n, i)
          e.push({ event: v, listeners: d }), (v.target = cu)
        }
      }
    }
  }
  function A$(e, n, i, s, u, d, v) {
    var y = i ? mu(i) : window
    switch (n) {
      case 'focusin':
        ;(Pw(y) || y.contentEditable === 'true') && ((cu = y), (Kg = i), (Zc = null))
        break
      case 'focusout':
        ;(cu = null), (Kg = null), (Zc = null)
        break
      case 'mousedown':
        Xg = !0
        break
      case 'contextmenu':
      case 'mouseup':
      case 'dragend':
        ;(Xg = !1), Iw(e, s, u)
        break
      case 'selectionchange':
        if (R$) break
      case 'keydown':
      case 'keyup':
        Iw(e, s, u)
    }
  }
  function Mp(e, n) {
    var i = {}
    return (
      (i[e.toLowerCase()] = n.toLowerCase()),
      (i['Webkit' + e] = 'webkit' + n),
      (i['Moz' + e] = 'moz' + n),
      i
    )
  }
  var fu = {
      animationend: Mp('Animation', 'AnimationEnd'),
      animationiteration: Mp('Animation', 'AnimationIteration'),
      animationstart: Mp('Animation', 'AnimationStart'),
      transitionend: Mp('Transition', 'TransitionEnd'),
    },
    Qg = {},
    Hw = {}
  wt &&
    ((Hw = document.createElement('div').style),
    'AnimationEvent' in window ||
      (delete fu.animationend.animation,
      delete fu.animationiteration.animation,
      delete fu.animationstart.animation),
    'TransitionEvent' in window || delete fu.transitionend.transition)
  function Pp(e) {
    if (Qg[e]) return Qg[e]
    if (!fu[e]) return e
    var n = fu[e]
    for (var i in n) if (n.hasOwnProperty(i) && i in Hw) return (Qg[e] = n[i])
    return e
  }
  var Ww = Pp('animationend'),
    Yw = Pp('animationiteration'),
    Gw = Pp('animationstart'),
    qw = Pp('transitionend'),
    Kw = new Map(),
    Xw = [
      'abort',
      'auxClick',
      'cancel',
      'canPlay',
      'canPlayThrough',
      'click',
      'close',
      'contextMenu',
      'copy',
      'cut',
      'drag',
      'dragEnd',
      'dragEnter',
      'dragExit',
      'dragLeave',
      'dragOver',
      'dragStart',
      'drop',
      'durationChange',
      'emptied',
      'encrypted',
      'ended',
      'error',
      'gotPointerCapture',
      'input',
      'invalid',
      'keyDown',
      'keyPress',
      'keyUp',
      'load',
      'loadedData',
      'loadedMetadata',
      'loadStart',
      'lostPointerCapture',
      'mouseDown',
      'mouseMove',
      'mouseOut',
      'mouseOver',
      'mouseUp',
      'paste',
      'pause',
      'play',
      'playing',
      'pointerCancel',
      'pointerDown',
      'pointerMove',
      'pointerOut',
      'pointerOver',
      'pointerUp',
      'progress',
      'rateChange',
      'reset',
      'resize',
      'seeked',
      'seeking',
      'stalled',
      'submit',
      'suspend',
      'timeUpdate',
      'touchCancel',
      'touchEnd',
      'touchStart',
      'volumeChange',
      'scroll',
      'toggle',
      'touchMove',
      'waiting',
      'wheel',
    ]
  function Zo(e, n) {
    Kw.set(e, n), Ct(n, [e])
  }
  function O$() {
    for (var e = 0; e < Xw.length; e++) {
      var n = Xw[e],
        i = n.toLowerCase(),
        s = n[0].toUpperCase() + n.slice(1)
      Zo(i, 'on' + s)
    }
    Zo(Ww, 'onAnimationEnd'),
      Zo(Yw, 'onAnimationIteration'),
      Zo(Gw, 'onAnimationStart'),
      Zo('dblclick', 'onDoubleClick'),
      Zo('focusin', 'onFocus'),
      Zo('focusout', 'onBlur'),
      Zo(qw, 'onTransitionEnd')
  }
  function M$(e, n, i, s, u, d, v) {
    var y = Kw.get(n)
    if (y !== void 0) {
      var x = Vg,
        T = n
      switch (n) {
        case 'keypress':
          if (kp(s) === 0) return
        case 'keydown':
        case 'keyup':
          x = Pz
          break
        case 'focusin':
          ;(T = 'focus'), (x = Wg)
          break
        case 'focusout':
          ;(T = 'blur'), (x = Wg)
          break
        case 'beforeblur':
        case 'afterblur':
          x = Wg
          break
        case 'click':
          if (s.button === 2) return
        case 'auxclick':
        case 'dblclick':
        case 'mousedown':
        case 'mousemove':
        case 'mouseup':
        case 'mouseout':
        case 'mouseover':
        case 'contextmenu':
          x = Cw
          break
        case 'drag':
        case 'dragend':
        case 'dragenter':
        case 'dragexit':
        case 'dragleave':
        case 'dragover':
        case 'dragstart':
        case 'drop':
          x = bz
          break
        case 'touchcancel':
        case 'touchend':
        case 'touchmove':
        case 'touchstart':
          x = $z
          break
        case Ww:
        case Yw:
        case Gw:
          x = Cz
          break
        case qw:
          x = Nz
          break
        case 'scroll':
          x = vz
          break
        case 'wheel':
          x = jz
          break
        case 'copy':
        case 'cut':
        case 'paste':
          x = Ez
          break
        case 'gotpointercapture':
        case 'lostpointercapture':
        case 'pointercancel':
        case 'pointerdown':
        case 'pointermove':
        case 'pointerout':
        case 'pointerover':
        case 'pointerup':
          x = Ew
          break
      }
      var _ = (d & wc) !== 0
      {
        var N = !_ && n === 'scroll',
          $ = $$(i, y, s.type, _, N)
        if ($.length > 0) {
          var q = new x(y, T, null, s, u)
          e.push({ event: q, listeners: $ })
        }
      }
    }
  }
  O$(), p$(), e$(), _$(), Iz()
  function P$(e, n, i, s, u, d, v) {
    M$(e, n, i, s, u, d)
    var y = (d & kP) === 0
    y && (h$(e, n, i, s, u), d$(e, n, i, s, u), A$(e, n, i, s, u), Qz(e, n, i, s, u))
  }
  var Jc = [
      'abort',
      'canplay',
      'canplaythrough',
      'durationchange',
      'emptied',
      'encrypted',
      'ended',
      'error',
      'loadeddata',
      'loadedmetadata',
      'loadstart',
      'pause',
      'play',
      'playing',
      'progress',
      'ratechange',
      'resize',
      'seeked',
      'seeking',
      'stalled',
      'suspend',
      'timeupdate',
      'volumechange',
      'waiting',
    ],
    Zg = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(Jc))
  function Qw(e, n, i) {
    var s = e.type || 'unknown-event'
    ;(e.currentTarget = i), jP(s, n, void 0, e), (e.currentTarget = null)
  }
  function L$(e, n, i) {
    var s
    if (i)
      for (var u = n.length - 1; u >= 0; u--) {
        var d = n[u],
          v = d.instance,
          y = d.currentTarget,
          x = d.listener
        if (v !== s && e.isPropagationStopped()) return
        Qw(e, x, y), (s = v)
      }
    else
      for (var T = 0; T < n.length; T++) {
        var _ = n[T],
          N = _.instance,
          $ = _.currentTarget,
          q = _.listener
        if (N !== s && e.isPropagationStopped()) return
        Qw(e, q, $), (s = N)
      }
  }
  function Zw(e, n) {
    for (var i = (n & wc) !== 0, s = 0; s < e.length; s++) {
      var u = e[s],
        d = u.event,
        v = u.listeners
      L$(d, v, i)
    }
    UP()
  }
  function z$(e, n, i, s, u) {
    var d = Gv(i),
      v = []
    P$(v, e, s, i, d, n), Zw(v, n)
  }
  function Sn(e, n) {
    Zg.has(e) ||
      c(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        e
      )
    var i = !1,
      s = f5(n),
      u = B$(e, i)
    s.has(u) || (Jw(n, e, Yv, i), s.add(u))
  }
  function Jg(e, n, i) {
    Zg.has(e) &&
      !n &&
      c(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        e
      )
    var s = 0
    n && (s |= wc), Jw(i, e, s, n)
  }
  var Lp = '_reactListening' + Math.random().toString(36).slice(2)
  function ef(e) {
    if (!e[Lp]) {
      ;(e[Lp] = !0),
        _t.forEach(function (i) {
          i !== 'selectionchange' && (Zg.has(i) || Jg(i, !1, e), Jg(i, !0, e))
        })
      var n = e.nodeType === ro ? e : e.ownerDocument
      n !== null && (n[Lp] || ((n[Lp] = !0), Jg('selectionchange', !1, n)))
    }
  }
  function Jw(e, n, i, s, u) {
    var d = oz(e, n, i),
      v = void 0
    Xv && (n === 'touchstart' || n === 'touchmove' || n === 'wheel') && (v = !0),
      (e = e),
      s
        ? v !== void 0
          ? dz(e, n, d, v)
          : fz(e, n, d)
        : v !== void 0
        ? pz(e, n, d, v)
        : cz(e, n, d)
  }
  function eE(e, n) {
    return e === n || (e.nodeType === Vn && e.parentNode === n)
  }
  function ey(e, n, i, s, u) {
    var d = s
    if (!(n & DC) && !(n & Yv)) {
      var v = u
      if (s !== null) {
        var y = s
        e: for (;;) {
          if (y === null) return
          var x = y.tag
          if (x === b || x === C) {
            var T = y.stateNode.containerInfo
            if (eE(T, v)) break
            if (x === C)
              for (var _ = y.return; _ !== null; ) {
                var N = _.tag
                if (N === b || N === C) {
                  var $ = _.stateNode.containerInfo
                  if (eE($, v)) return
                }
                _ = _.return
              }
            for (; T !== null; ) {
              var q = ol(T)
              if (q === null) return
              var K = q.tag
              if (K === w || K === k) {
                y = d = q
                continue e
              }
              T = T.parentNode
            }
          }
          y = y.return
        }
      }
    }
    zC(function () {
      return z$(e, n, i, d)
    })
  }
  function tf(e, n, i) {
    return { instance: e, listener: n, currentTarget: i }
  }
  function $$(e, n, i, s, u, d) {
    for (
      var v = n !== null ? n + 'Capture' : null, y = s ? v : n, x = [], T = e, _ = null;
      T !== null;

    ) {
      var N = T,
        $ = N.stateNode,
        q = N.tag
      if (q === w && $ !== null && ((_ = $), y !== null)) {
        var K = Tc(T, y)
        K != null && x.push(tf(T, K, _))
      }
      if (u) break
      T = T.return
    }
    return x
  }
  function zp(e, n) {
    for (var i = n + 'Capture', s = [], u = e; u !== null; ) {
      var d = u,
        v = d.stateNode,
        y = d.tag
      if (y === w && v !== null) {
        var x = v,
          T = Tc(u, i)
        T != null && s.unshift(tf(u, T, x))
        var _ = Tc(u, n)
        _ != null && s.push(tf(u, _, x))
      }
      u = u.return
    }
    return s
  }
  function du(e) {
    if (e === null) return null
    do e = e.return
    while (e && e.tag !== w)
    return e || null
  }
  function F$(e, n) {
    for (var i = e, s = n, u = 0, d = i; d; d = du(d)) u++
    for (var v = 0, y = s; y; y = du(y)) v++
    for (; u - v > 0; ) (i = du(i)), u--
    for (; v - u > 0; ) (s = du(s)), v--
    for (var x = u; x--; ) {
      if (i === s || (s !== null && i === s.alternate)) return i
      ;(i = du(i)), (s = du(s))
    }
    return null
  }
  function tE(e, n, i, s, u) {
    for (var d = n._reactName, v = [], y = i; y !== null && y !== s; ) {
      var x = y,
        T = x.alternate,
        _ = x.stateNode,
        N = x.tag
      if (T !== null && T === s) break
      if (N === w && _ !== null) {
        var $ = _
        if (u) {
          var q = Tc(y, d)
          q != null && v.unshift(tf(y, q, $))
        } else if (!u) {
          var K = Tc(y, d)
          K != null && v.push(tf(y, K, $))
        }
      }
      y = y.return
    }
    v.length !== 0 && e.push({ event: n, listeners: v })
  }
  function N$(e, n, i, s, u) {
    var d = s && u ? F$(s, u) : null
    s !== null && tE(e, n, s, d, !1), u !== null && i !== null && tE(e, i, u, d, !0)
  }
  function B$(e, n) {
    return e + '__' + (n ? 'capture' : 'bubble')
  }
  var aa = !1,
    nf = 'dangerouslySetInnerHTML',
    $p = 'suppressContentEditableWarning',
    Jo = 'suppressHydrationWarning',
    nE = 'autoFocus',
    al = 'children',
    il = 'style',
    Fp = '__html',
    ty,
    Np,
    rf,
    rE,
    Bp,
    aE,
    iE
  ;(ty = { dialog: !0, webview: !0 }),
    (Np = function (e, n) {
      xP(e, n),
        CP(e, n),
        _P(e, n, { registrationNameDependencies: zt, possibleRegistrationNames: Qt })
    }),
    (aE = wt && !document.documentMode),
    (rf = function (e, n, i) {
      if (!aa) {
        var s = jp(i),
          u = jp(n)
        u !== s &&
          ((aa = !0),
          c(
            'Prop `%s` did not match. Server: %s Client: %s',
            e,
            JSON.stringify(u),
            JSON.stringify(s)
          ))
      }
    }),
    (rE = function (e) {
      if (!aa) {
        aa = !0
        var n = []
        e.forEach(function (i) {
          n.push(i)
        }),
          c('Extra attributes from the server: %s', n)
      }
    }),
    (Bp = function (e, n) {
      n === !1
        ? c(
            'Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
            e,
            e,
            e
          )
        : c(
            'Expected `%s` listener to be a function, instead got a value of `%s` type.',
            e,
            typeof n
          )
    }),
    (iE = function (e, n) {
      var i =
        e.namespaceURI === to
          ? e.ownerDocument.createElement(e.tagName)
          : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName)
      return (i.innerHTML = n), i.innerHTML
    })
  var j$ = /\r\n?/g,
    U$ = /\u0000|\uFFFD/g
  function jp(e) {
    gn(e)
    var n = typeof e == 'string' ? e : '' + e
    return n
      .replace(
        j$,
        `
`
      )
      .replace(U$, '')
  }
  function Up(e, n, i, s) {
    var u = jp(n),
      d = jp(e)
    if (
      d !== u &&
      (s && (aa || ((aa = !0), c('Text content did not match. Server: "%s" Client: "%s"', d, u))),
      i && ee)
    )
      throw new Error('Text content does not match server-rendered HTML.')
  }
  function oE(e) {
    return e.nodeType === ro ? e : e.ownerDocument
  }
  function V$() {}
  function Vp(e) {
    e.onclick = V$
  }
  function I$(e, n, i, s, u) {
    for (var d in s)
      if (s.hasOwnProperty(d)) {
        var v = s[d]
        if (d === il) v && Object.freeze(v), wC(n, v)
        else if (d === nf) {
          var y = v ? v[Fp] : void 0
          y != null && yC(n, y)
        } else if (d === al)
          if (typeof v == 'string') {
            var x = e !== 'textarea' || v !== ''
            x && cp(n, v)
          } else typeof v == 'number' && cp(n, '' + v)
        else
          d === $p ||
            d === Jo ||
            d === nE ||
            (zt.hasOwnProperty(d)
              ? v != null &&
                (typeof v != 'function' && Bp(d, v), d === 'onScroll' && Sn('scroll', n))
              : v != null && Qn(n, d, v, u))
      }
  }
  function H$(e, n, i, s) {
    for (var u = 0; u < n.length; u += 2) {
      var d = n[u],
        v = n[u + 1]
      d === il ? wC(e, v) : d === nf ? yC(e, v) : d === al ? cp(e, v) : Qn(e, d, v, s)
    }
  }
  function W$(e, n, i, s) {
    var u,
      d = oE(i),
      v,
      y = s
    if ((y === to && (y = jv(e)), y === to)) {
      if (
        ((u = Gs(e, n)),
        !u &&
          e !== e.toLowerCase() &&
          c(
            '<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.',
            e
          ),
        e === 'script')
      ) {
        var x = d.createElement('div')
        x.innerHTML = '<script></script>'
        var T = x.firstChild
        v = x.removeChild(T)
      } else if (typeof n.is == 'string') v = d.createElement(e, { is: n.is })
      else if (((v = d.createElement(e)), e === 'select')) {
        var _ = v
        n.multiple ? (_.multiple = !0) : n.size && (_.size = n.size)
      }
    } else v = d.createElementNS(y, e)
    return (
      y === to &&
        !u &&
        Object.prototype.toString.call(v) === '[object HTMLUnknownElement]' &&
        !Zt.call(ty, e) &&
        ((ty[e] = !0),
        c(
          'The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.',
          e
        )),
      v
    )
  }
  function Y$(e, n) {
    return oE(n).createTextNode(e)
  }
  function G$(e, n, i, s) {
    var u = Gs(n, i)
    Np(n, i)
    var d
    switch (n) {
      case 'dialog':
        Sn('cancel', e), Sn('close', e), (d = i)
        break
      case 'iframe':
      case 'object':
      case 'embed':
        Sn('load', e), (d = i)
        break
      case 'video':
      case 'audio':
        for (var v = 0; v < Jc.length; v++) Sn(Jc[v], e)
        d = i
        break
      case 'source':
        Sn('error', e), (d = i)
        break
      case 'img':
      case 'image':
      case 'link':
        Sn('error', e), Sn('load', e), (d = i)
        break
      case 'details':
        Sn('toggle', e), (d = i)
        break
      case 'input':
        O(e, i), (d = S(e, i)), Sn('invalid', e)
        break
      case 'option':
        dn(e, i), (d = i)
        break
      case 'select':
        xc(e, i), (d = Sc(e, i)), Sn('invalid', e)
        break
      case 'textarea':
        mC(e, i), (d = Nv(e, i)), Sn('invalid', e)
        break
      default:
        d = i
    }
    switch ((Wv(n, d), I$(n, e, s, d, u), n)) {
      case 'input':
        Qa(e), de(e, i, !1)
        break
      case 'textarea':
        Qa(e), gC(e)
        break
      case 'option':
        bn(e, i)
        break
      case 'select':
        Fv(e, i)
        break
      default:
        typeof d.onClick == 'function' && Vp(e)
        break
    }
  }
  function q$(e, n, i, s, u) {
    Np(n, s)
    var d = null,
      v,
      y
    switch (n) {
      case 'input':
        ;(v = S(e, i)), (y = S(e, s)), (d = [])
        break
      case 'select':
        ;(v = Sc(e, i)), (y = Sc(e, s)), (d = [])
        break
      case 'textarea':
        ;(v = Nv(e, i)), (y = Nv(e, s)), (d = [])
        break
      default:
        ;(v = i), (y = s), typeof v.onClick != 'function' && typeof y.onClick == 'function' && Vp(e)
        break
    }
    Wv(n, y)
    var x,
      T,
      _ = null
    for (x in v)
      if (!(y.hasOwnProperty(x) || !v.hasOwnProperty(x) || v[x] == null))
        if (x === il) {
          var N = v[x]
          for (T in N) N.hasOwnProperty(T) && (_ || (_ = {}), (_[T] = ''))
        } else
          x === nf ||
            x === al ||
            x === $p ||
            x === Jo ||
            x === nE ||
            (zt.hasOwnProperty(x) ? d || (d = []) : (d = d || []).push(x, null))
    for (x in y) {
      var $ = y[x],
        q = v != null ? v[x] : void 0
      if (!(!y.hasOwnProperty(x) || $ === q || ($ == null && q == null)))
        if (x === il)
          if (($ && Object.freeze($), q)) {
            for (T in q)
              q.hasOwnProperty(T) && (!$ || !$.hasOwnProperty(T)) && (_ || (_ = {}), (_[T] = ''))
            for (T in $) $.hasOwnProperty(T) && q[T] !== $[T] && (_ || (_ = {}), (_[T] = $[T]))
          } else _ || (d || (d = []), d.push(x, _)), (_ = $)
        else if (x === nf) {
          var K = $ ? $[Fp] : void 0,
            re = q ? q[Fp] : void 0
          K != null && re !== K && (d = d || []).push(x, K)
        } else
          x === al
            ? (typeof $ == 'string' || typeof $ == 'number') && (d = d || []).push(x, '' + $)
            : x === $p ||
              x === Jo ||
              (zt.hasOwnProperty(x)
                ? ($ != null &&
                    (typeof $ != 'function' && Bp(x, $), x === 'onScroll' && Sn('scroll', e)),
                  !d && q !== $ && (d = []))
                : (d = d || []).push(x, $))
    }
    return _ && (pP(_, y[il]), (d = d || []).push(il, _)), d
  }
  function K$(e, n, i, s, u) {
    i === 'input' && u.type === 'radio' && u.name != null && G(e, u)
    var d = Gs(i, s),
      v = Gs(i, u)
    switch ((H$(e, n, d, v), i)) {
      case 'input':
        Z(e, u)
        break
      case 'textarea':
        vC(e, u)
        break
      case 'select':
        HM(e, u)
        break
    }
  }
  function X$(e) {
    {
      var n = e.toLowerCase()
      return (fp.hasOwnProperty(n) && fp[n]) || null
    }
  }
  function Q$(e, n, i, s, u, d, v) {
    var y, x
    switch (((y = Gs(n, i)), Np(n, i), n)) {
      case 'dialog':
        Sn('cancel', e), Sn('close', e)
        break
      case 'iframe':
      case 'object':
      case 'embed':
        Sn('load', e)
        break
      case 'video':
      case 'audio':
        for (var T = 0; T < Jc.length; T++) Sn(Jc[T], e)
        break
      case 'source':
        Sn('error', e)
        break
      case 'img':
      case 'image':
      case 'link':
        Sn('error', e), Sn('load', e)
        break
      case 'details':
        Sn('toggle', e)
        break
      case 'input':
        O(e, i), Sn('invalid', e)
        break
      case 'option':
        dn(e, i)
        break
      case 'select':
        xc(e, i), Sn('invalid', e)
        break
      case 'textarea':
        mC(e, i), Sn('invalid', e)
        break
    }
    Wv(n, i)
    {
      x = new Set()
      for (var _ = e.attributes, N = 0; N < _.length; N++) {
        var $ = _[N].name.toLowerCase()
        switch ($) {
          case 'value':
            break
          case 'checked':
            break
          case 'selected':
            break
          default:
            x.add(_[N].name)
        }
      }
    }
    var q = null
    for (var K in i)
      if (i.hasOwnProperty(K)) {
        var re = i[K]
        if (K === al)
          typeof re == 'string'
            ? e.textContent !== re && (i[Jo] !== !0 && Up(e.textContent, re, d, v), (q = [al, re]))
            : typeof re == 'number' &&
              e.textContent !== '' + re &&
              (i[Jo] !== !0 && Up(e.textContent, re, d, v), (q = [al, '' + re]))
        else if (zt.hasOwnProperty(K))
          re != null && (typeof re != 'function' && Bp(K, re), K === 'onScroll' && Sn('scroll', e))
        else if (v && typeof y == 'boolean') {
          var De = void 0,
            je = y && Pe ? null : ln(K)
          if (i[Jo] !== !0) {
            if (!(K === $p || K === Jo || K === 'value' || K === 'checked' || K === 'selected')) {
              if (K === nf) {
                var Fe = e.innerHTML,
                  St = re ? re[Fp] : void 0
                if (St != null) {
                  var ht = iE(e, St)
                  ht !== Fe && rf(K, Fe, ht)
                }
              } else if (K === il) {
                if ((x.delete(K), aE)) {
                  var H = fP(re)
                  ;(De = e.getAttribute('style')), H !== De && rf(K, De, H)
                }
              } else if (y && !Pe)
                x.delete(K.toLowerCase()), (De = Mn(e, K, re)), re !== De && rf(K, De, re)
              else if (!Ce(K, je, y) && !$e(K, re, je, y)) {
                var ae = !1
                if (je !== null) x.delete(je.attributeName), (De = Et(e, K, re, je))
                else {
                  var W = s
                  if ((W === to && (W = jv(n)), W === to)) x.delete(K.toLowerCase())
                  else {
                    var fe = X$(K)
                    fe !== null && fe !== K && ((ae = !0), x.delete(fe)), x.delete(K)
                  }
                  De = Mn(e, K, re)
                }
                var Ae = Pe
                !Ae && re !== De && !ae && rf(K, De, re)
              }
            }
          }
        }
      }
    switch ((v && x.size > 0 && i[Jo] !== !0 && rE(x), n)) {
      case 'input':
        Qa(e), de(e, i, !0)
        break
      case 'textarea':
        Qa(e), gC(e)
        break
      case 'select':
      case 'option':
        break
      default:
        typeof i.onClick == 'function' && Vp(e)
        break
    }
    return q
  }
  function Z$(e, n, i) {
    var s = e.nodeValue !== n
    return s
  }
  function ny(e, n) {
    {
      if (aa) return
      ;(aa = !0),
        c(
          'Did not expect server HTML to contain a <%s> in <%s>.',
          n.nodeName.toLowerCase(),
          e.nodeName.toLowerCase()
        )
    }
  }
  function ry(e, n) {
    {
      if (aa) return
      ;(aa = !0),
        c(
          'Did not expect server HTML to contain the text node "%s" in <%s>.',
          n.nodeValue,
          e.nodeName.toLowerCase()
        )
    }
  }
  function ay(e, n, i) {
    {
      if (aa) return
      ;(aa = !0),
        c('Expected server HTML to contain a matching <%s> in <%s>.', n, e.nodeName.toLowerCase())
    }
  }
  function iy(e, n) {
    {
      if (n === '' || aa) return
      ;(aa = !0),
        c(
          'Expected server HTML to contain a matching text node for "%s" in <%s>.',
          n,
          e.nodeName.toLowerCase()
        )
    }
  }
  function J$(e, n, i) {
    switch (n) {
      case 'input':
        Ue(e, i)
        return
      case 'textarea':
        YM(e, i)
        return
      case 'select':
        WM(e, i)
        return
    }
  }
  var af = function () {},
    of = function () {}
  {
    var e2 = [
        'address',
        'applet',
        'area',
        'article',
        'aside',
        'base',
        'basefont',
        'bgsound',
        'blockquote',
        'body',
        'br',
        'button',
        'caption',
        'center',
        'col',
        'colgroup',
        'dd',
        'details',
        'dir',
        'div',
        'dl',
        'dt',
        'embed',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'frame',
        'frameset',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'head',
        'header',
        'hgroup',
        'hr',
        'html',
        'iframe',
        'img',
        'input',
        'isindex',
        'li',
        'link',
        'listing',
        'main',
        'marquee',
        'menu',
        'menuitem',
        'meta',
        'nav',
        'noembed',
        'noframes',
        'noscript',
        'object',
        'ol',
        'p',
        'param',
        'plaintext',
        'pre',
        'script',
        'section',
        'select',
        'source',
        'style',
        'summary',
        'table',
        'tbody',
        'td',
        'template',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'title',
        'tr',
        'track',
        'ul',
        'wbr',
        'xmp',
      ],
      sE = [
        'applet',
        'caption',
        'html',
        'table',
        'td',
        'th',
        'marquee',
        'object',
        'template',
        'foreignObject',
        'desc',
        'title',
      ],
      t2 = sE.concat(['button']),
      n2 = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'],
      lE = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null,
      }
    of = function (e, n) {
      var i = ot({}, e || lE),
        s = { tag: n }
      return (
        sE.indexOf(n) !== -1 &&
          ((i.aTagInScope = null), (i.buttonTagInScope = null), (i.nobrTagInScope = null)),
        t2.indexOf(n) !== -1 && (i.pTagInButtonScope = null),
        e2.indexOf(n) !== -1 &&
          n !== 'address' &&
          n !== 'div' &&
          n !== 'p' &&
          ((i.listItemTagAutoclosing = null), (i.dlItemTagAutoclosing = null)),
        (i.current = s),
        n === 'form' && (i.formTag = s),
        n === 'a' && (i.aTagInScope = s),
        n === 'button' && (i.buttonTagInScope = s),
        n === 'nobr' && (i.nobrTagInScope = s),
        n === 'p' && (i.pTagInButtonScope = s),
        n === 'li' && (i.listItemTagAutoclosing = s),
        (n === 'dd' || n === 'dt') && (i.dlItemTagAutoclosing = s),
        i
      )
    }
    var r2 = function (e, n) {
        switch (n) {
          case 'select':
            return e === 'option' || e === 'optgroup' || e === '#text'
          case 'optgroup':
            return e === 'option' || e === '#text'
          case 'option':
            return e === '#text'
          case 'tr':
            return e === 'th' || e === 'td' || e === 'style' || e === 'script' || e === 'template'
          case 'tbody':
          case 'thead':
          case 'tfoot':
            return e === 'tr' || e === 'style' || e === 'script' || e === 'template'
          case 'colgroup':
            return e === 'col' || e === 'template'
          case 'table':
            return (
              e === 'caption' ||
              e === 'colgroup' ||
              e === 'tbody' ||
              e === 'tfoot' ||
              e === 'thead' ||
              e === 'style' ||
              e === 'script' ||
              e === 'template'
            )
          case 'head':
            return (
              e === 'base' ||
              e === 'basefont' ||
              e === 'bgsound' ||
              e === 'link' ||
              e === 'meta' ||
              e === 'title' ||
              e === 'noscript' ||
              e === 'noframes' ||
              e === 'style' ||
              e === 'script' ||
              e === 'template'
            )
          case 'html':
            return e === 'head' || e === 'body' || e === 'frameset'
          case 'frameset':
            return e === 'frame'
          case '#document':
            return e === 'html'
        }
        switch (e) {
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return n !== 'h1' && n !== 'h2' && n !== 'h3' && n !== 'h4' && n !== 'h5' && n !== 'h6'
          case 'rp':
          case 'rt':
            return n2.indexOf(n) === -1
          case 'body':
          case 'caption':
          case 'col':
          case 'colgroup':
          case 'frameset':
          case 'frame':
          case 'head':
          case 'html':
          case 'tbody':
          case 'td':
          case 'tfoot':
          case 'th':
          case 'thead':
          case 'tr':
            return n == null
        }
        return !0
      },
      a2 = function (e, n) {
        switch (e) {
          case 'address':
          case 'article':
          case 'aside':
          case 'blockquote':
          case 'center':
          case 'details':
          case 'dialog':
          case 'dir':
          case 'div':
          case 'dl':
          case 'fieldset':
          case 'figcaption':
          case 'figure':
          case 'footer':
          case 'header':
          case 'hgroup':
          case 'main':
          case 'menu':
          case 'nav':
          case 'ol':
          case 'p':
          case 'section':
          case 'summary':
          case 'ul':
          case 'pre':
          case 'listing':
          case 'table':
          case 'hr':
          case 'xmp':
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return n.pTagInButtonScope
          case 'form':
            return n.formTag || n.pTagInButtonScope
          case 'li':
            return n.listItemTagAutoclosing
          case 'dd':
          case 'dt':
            return n.dlItemTagAutoclosing
          case 'button':
            return n.buttonTagInScope
          case 'a':
            return n.aTagInScope
          case 'nobr':
            return n.nobrTagInScope
        }
        return null
      },
      uE = {}
    af = function (e, n, i) {
      i = i || lE
      var s = i.current,
        u = s && s.tag
      n != null &&
        (e != null && c('validateDOMNesting: when childText is passed, childTag should be null'),
        (e = '#text'))
      var d = r2(e, u) ? null : s,
        v = d ? null : a2(e, i),
        y = d || v
      if (y) {
        var x = y.tag,
          T = !!d + '|' + e + '|' + x
        if (!uE[T]) {
          uE[T] = !0
          var _ = e,
            N = ''
          if (
            (e === '#text'
              ? /\S/.test(n)
                ? (_ = 'Text nodes')
                : ((_ = 'Whitespace text nodes'),
                  (N =
                    " Make sure you don't have any extra whitespace between tags on each line of your source code."))
              : (_ = '<' + e + '>'),
            d)
          ) {
            var $ = ''
            x === 'table' &&
              e === 'tr' &&
              ($ +=
                ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.'),
              c('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', _, x, N, $)
          } else c('validateDOMNesting(...): %s cannot appear as a descendant of <%s>.', _, x)
        }
      }
    }
  }
  var Ip = 'suppressHydrationWarning',
    Hp = '$',
    Wp = '/$',
    sf = '$?',
    lf = '$!',
    i2 = 'style',
    oy = null,
    sy = null
  function o2(e) {
    var n,
      i,
      s = e.nodeType
    switch (s) {
      case ro:
      case Vv: {
        n = s === ro ? '#document' : '#fragment'
        var u = e.documentElement
        i = u ? u.namespaceURI : Uv(null, '')
        break
      }
      default: {
        var d = s === Vn ? e.parentNode : e,
          v = d.namespaceURI || null
        ;(n = d.tagName), (i = Uv(v, n))
        break
      }
    }
    {
      var y = n.toLowerCase(),
        x = of(null, y)
      return { namespace: i, ancestorInfo: x }
    }
  }
  function s2(e, n, i) {
    {
      var s = e,
        u = Uv(s.namespace, n),
        d = of(s.ancestorInfo, n)
      return { namespace: u, ancestorInfo: d }
    }
  }
  function Pee(e) {
    return e
  }
  function l2(e) {
    ;(oy = iz()), (sy = C$())
    var n = null
    return gw(!1), n
  }
  function u2(e) {
    w$(sy), gw(oy), (oy = null), (sy = null)
  }
  function c2(e, n, i, s, u) {
    var d
    {
      var v = s
      if (
        (af(e, null, v.ancestorInfo),
        typeof n.children == 'string' || typeof n.children == 'number')
      ) {
        var y = '' + n.children,
          x = of(v.ancestorInfo, e)
        af(null, y, x)
      }
      d = v.namespace
    }
    var T = W$(e, n, i, d)
    return ff(u, T), my(T, n), T
  }
  function f2(e, n) {
    e.appendChild(n)
  }
  function d2(e, n, i, s, u) {
    switch ((G$(e, n, i, s), n)) {
      case 'button':
      case 'input':
      case 'select':
      case 'textarea':
        return !!i.autoFocus
      case 'img':
        return !0
      default:
        return !1
    }
  }
  function p2(e, n, i, s, u, d) {
    {
      var v = d
      if (
        typeof s.children != typeof i.children &&
        (typeof s.children == 'string' || typeof s.children == 'number')
      ) {
        var y = '' + s.children,
          x = of(v.ancestorInfo, n)
        af(null, y, x)
      }
    }
    return q$(e, n, i, s)
  }
  function ly(e, n) {
    return (
      e === 'textarea' ||
      e === 'noscript' ||
      typeof n.children == 'string' ||
      typeof n.children == 'number' ||
      (typeof n.dangerouslySetInnerHTML == 'object' &&
        n.dangerouslySetInnerHTML !== null &&
        n.dangerouslySetInnerHTML.__html != null)
    )
  }
  function h2(e, n, i, s) {
    {
      var u = i
      af(null, e, u.ancestorInfo)
    }
    var d = Y$(e, n)
    return ff(s, d), d
  }
  function m2() {
    var e = window.event
    return e === void 0 ? co : yw(e.type)
  }
  var uy = typeof setTimeout == 'function' ? setTimeout : void 0,
    v2 = typeof clearTimeout == 'function' ? clearTimeout : void 0,
    cy = -1,
    cE = typeof Promise == 'function' ? Promise : void 0,
    g2 =
      typeof queueMicrotask == 'function'
        ? queueMicrotask
        : typeof cE < 'u'
        ? function (e) {
            return cE.resolve(null).then(e).catch(y2)
          }
        : uy
  function y2(e) {
    setTimeout(function () {
      throw e
    })
  }
  function b2(e, n, i, s) {
    switch (n) {
      case 'button':
      case 'input':
      case 'select':
      case 'textarea':
        i.autoFocus && e.focus()
        return
      case 'img': {
        i.src && (e.src = i.src)
        return
      }
    }
  }
  function S2(e, n, i, s, u, d) {
    K$(e, n, i, s, u), my(e, u)
  }
  function fE(e) {
    cp(e, '')
  }
  function x2(e, n, i) {
    e.nodeValue = i
  }
  function C2(e, n) {
    e.appendChild(n)
  }
  function w2(e, n) {
    var i
    e.nodeType === Vn ? ((i = e.parentNode), i.insertBefore(n, e)) : ((i = e), i.appendChild(n))
    var s = e._reactRootContainer
    s == null && i.onclick === null && Vp(i)
  }
  function E2(e, n, i) {
    e.insertBefore(n, i)
  }
  function T2(e, n, i) {
    e.nodeType === Vn ? e.parentNode.insertBefore(n, i) : e.insertBefore(n, i)
  }
  function R2(e, n) {
    e.removeChild(n)
  }
  function _2(e, n) {
    e.nodeType === Vn ? e.parentNode.removeChild(n) : e.removeChild(n)
  }
  function fy(e, n) {
    var i = n,
      s = 0
    do {
      var u = i.nextSibling
      if ((e.removeChild(i), u && u.nodeType === Vn)) {
        var d = u.data
        if (d === Wp)
          if (s === 0) {
            e.removeChild(u), Ic(n)
            return
          } else s--
        else (d === Hp || d === sf || d === lf) && s++
      }
      i = u
    } while (i)
    Ic(n)
  }
  function k2(e, n) {
    e.nodeType === Vn ? fy(e.parentNode, n) : e.nodeType === ra && fy(e, n), Ic(e)
  }
  function D2(e) {
    e = e
    var n = e.style
    typeof n.setProperty == 'function'
      ? n.setProperty('display', 'none', 'important')
      : (n.display = 'none')
  }
  function A2(e) {
    e.nodeValue = ''
  }
  function O2(e, n) {
    e = e
    var i = n[i2],
      s = i != null && i.hasOwnProperty('display') ? i.display : null
    e.style.display = Iv('display', s)
  }
  function M2(e, n) {
    e.nodeValue = n
  }
  function P2(e) {
    e.nodeType === ra
      ? (e.textContent = '')
      : e.nodeType === ro && e.documentElement && e.removeChild(e.documentElement)
  }
  function L2(e, n, i) {
    return e.nodeType !== ra || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e
  }
  function z2(e, n) {
    return n === '' || e.nodeType !== no ? null : e
  }
  function $2(e) {
    return e.nodeType !== Vn ? null : e
  }
  function dE(e) {
    return e.data === sf
  }
  function dy(e) {
    return e.data === lf
  }
  function F2(e) {
    var n = e.nextSibling && e.nextSibling.dataset,
      i,
      s,
      u
    return n && ((i = n.dgst), (s = n.msg), (u = n.stck)), { message: s, digest: i, stack: u }
  }
  function N2(e, n) {
    e._reactRetry = n
  }
  function Yp(e) {
    for (; e != null; e = e.nextSibling) {
      var n = e.nodeType
      if (n === ra || n === no) break
      if (n === Vn) {
        var i = e.data
        if (i === Hp || i === lf || i === sf) break
        if (i === Wp) return null
      }
    }
    return e
  }
  function uf(e) {
    return Yp(e.nextSibling)
  }
  function B2(e) {
    return Yp(e.firstChild)
  }
  function j2(e) {
    return Yp(e.firstChild)
  }
  function U2(e) {
    return Yp(e.nextSibling)
  }
  function V2(e, n, i, s, u, d, v) {
    ff(d, e), my(e, i)
    var y
    {
      var x = u
      y = x.namespace
    }
    var T = (d.mode & yt) !== Ie
    return Q$(e, n, i, y, s, T, v)
  }
  function I2(e, n, i, s) {
    return ff(i, e), i.mode & yt, Z$(e, n)
  }
  function H2(e, n) {
    ff(n, e)
  }
  function W2(e) {
    for (var n = e.nextSibling, i = 0; n; ) {
      if (n.nodeType === Vn) {
        var s = n.data
        if (s === Wp) {
          if (i === 0) return uf(n)
          i--
        } else (s === Hp || s === lf || s === sf) && i++
      }
      n = n.nextSibling
    }
    return null
  }
  function pE(e) {
    for (var n = e.previousSibling, i = 0; n; ) {
      if (n.nodeType === Vn) {
        var s = n.data
        if (s === Hp || s === lf || s === sf) {
          if (i === 0) return n
          i--
        } else s === Wp && i++
      }
      n = n.previousSibling
    }
    return null
  }
  function Y2(e) {
    Ic(e)
  }
  function G2(e) {
    Ic(e)
  }
  function q2(e) {
    return e !== 'head' && e !== 'body'
  }
  function K2(e, n, i, s) {
    var u = !0
    Up(n.nodeValue, i, s, u)
  }
  function X2(e, n, i, s, u, d) {
    if (n[Ip] !== !0) {
      var v = !0
      Up(s.nodeValue, u, d, v)
    }
  }
  function Q2(e, n) {
    n.nodeType === ra ? ny(e, n) : n.nodeType === Vn || ry(e, n)
  }
  function Z2(e, n) {
    {
      var i = e.parentNode
      i !== null && (n.nodeType === ra ? ny(i, n) : n.nodeType === Vn || ry(i, n))
    }
  }
  function J2(e, n, i, s, u) {
    ;(u || n[Ip] !== !0) && (s.nodeType === ra ? ny(i, s) : s.nodeType === Vn || ry(i, s))
  }
  function e5(e, n, i) {
    ay(e, n)
  }
  function t5(e, n) {
    iy(e, n)
  }
  function n5(e, n, i) {
    {
      var s = e.parentNode
      s !== null && ay(s, n)
    }
  }
  function r5(e, n) {
    {
      var i = e.parentNode
      i !== null && iy(i, n)
    }
  }
  function a5(e, n, i, s, u, d) {
    ;(d || n[Ip] !== !0) && ay(i, s)
  }
  function i5(e, n, i, s, u) {
    ;(u || n[Ip] !== !0) && iy(i, s)
  }
  function o5(e) {
    c(
      'An error occurred during hydration. The server HTML was replaced with client content in <%s>.',
      e.nodeName.toLowerCase()
    )
  }
  function s5(e) {
    ef(e)
  }
  var pu = Math.random().toString(36).slice(2),
    hu = '__reactFiber$' + pu,
    py = '__reactProps$' + pu,
    cf = '__reactContainer$' + pu,
    hy = '__reactEvents$' + pu,
    l5 = '__reactListeners$' + pu,
    u5 = '__reactHandles$' + pu
  function c5(e) {
    delete e[hu], delete e[py], delete e[hy], delete e[l5], delete e[u5]
  }
  function ff(e, n) {
    n[hu] = e
  }
  function Gp(e, n) {
    n[cf] = e
  }
  function hE(e) {
    e[cf] = null
  }
  function df(e) {
    return !!e[cf]
  }
  function ol(e) {
    var n = e[hu]
    if (n) return n
    for (var i = e.parentNode; i; ) {
      if (((n = i[cf] || i[hu]), n)) {
        var s = n.alternate
        if (n.child !== null || (s !== null && s.child !== null))
          for (var u = pE(e); u !== null; ) {
            var d = u[hu]
            if (d) return d
            u = pE(u)
          }
        return n
      }
      ;(e = i), (i = e.parentNode)
    }
    return null
  }
  function es(e) {
    var n = e[hu] || e[cf]
    return n && (n.tag === w || n.tag === k || n.tag === j || n.tag === b) ? n : null
  }
  function mu(e) {
    if (e.tag === w || e.tag === k) return e.stateNode
    throw new Error('getNodeFromInstance: Invalid argument.')
  }
  function qp(e) {
    return e[py] || null
  }
  function my(e, n) {
    e[py] = n
  }
  function f5(e) {
    var n = e[hy]
    return n === void 0 && (n = e[hy] = new Set()), n
  }
  var mE = {},
    vE = a.ReactDebugCurrentFrame
  function Kp(e) {
    if (e) {
      var n = e._owner,
        i = Ci(e.type, e._source, n ? n.type : null)
      vE.setExtraStackFrame(i)
    } else vE.setExtraStackFrame(null)
  }
  function ti(e, n, i, s, u) {
    {
      var d = Function.call.bind(Zt)
      for (var v in e)
        if (d(e, v)) {
          var y = void 0
          try {
            if (typeof e[v] != 'function') {
              var x = Error(
                (s || 'React class') +
                  ': ' +
                  i +
                  ' type `' +
                  v +
                  '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                  typeof e[v] +
                  '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
              )
              throw ((x.name = 'Invariant Violation'), x)
            }
            y = e[v](n, v, s, i, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED')
          } catch (T) {
            y = T
          }
          y &&
            !(y instanceof Error) &&
            (Kp(u),
            c(
              '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
              s || 'React class',
              i,
              v,
              typeof y
            ),
            Kp(null)),
            y instanceof Error &&
              !(y.message in mE) &&
              ((mE[y.message] = !0), Kp(u), c('Failed %s type: %s', i, y.message), Kp(null))
        }
    }
  }
  var vy = [],
    Xp
  Xp = []
  var fo = -1
  function ts(e) {
    return { current: e }
  }
  function Or(e, n) {
    if (fo < 0) {
      c('Unexpected pop.')
      return
    }
    n !== Xp[fo] && c('Unexpected Fiber popped.'),
      (e.current = vy[fo]),
      (vy[fo] = null),
      (Xp[fo] = null),
      fo--
  }
  function Mr(e, n, i) {
    fo++, (vy[fo] = e.current), (Xp[fo] = i), (e.current = n)
  }
  var gy
  gy = {}
  var Ta = {}
  Object.freeze(Ta)
  var po = ts(Ta),
    _i = ts(!1),
    yy = Ta
  function vu(e, n, i) {
    return i && ki(n) ? yy : po.current
  }
  function gE(e, n, i) {
    {
      var s = e.stateNode
      ;(s.__reactInternalMemoizedUnmaskedChildContext = n),
        (s.__reactInternalMemoizedMaskedChildContext = i)
    }
  }
  function gu(e, n) {
    {
      var i = e.type,
        s = i.contextTypes
      if (!s) return Ta
      var u = e.stateNode
      if (u && u.__reactInternalMemoizedUnmaskedChildContext === n)
        return u.__reactInternalMemoizedMaskedChildContext
      var d = {}
      for (var v in s) d[v] = n[v]
      {
        var y = nt(e) || 'Unknown'
        ti(s, d, 'context', y)
      }
      return u && gE(e, n, d), d
    }
  }
  function Qp() {
    return _i.current
  }
  function ki(e) {
    {
      var n = e.childContextTypes
      return n != null
    }
  }
  function Zp(e) {
    Or(_i, e), Or(po, e)
  }
  function by(e) {
    Or(_i, e), Or(po, e)
  }
  function yE(e, n, i) {
    {
      if (po.current !== Ta)
        throw new Error(
          'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'
        )
      Mr(po, n, e), Mr(_i, i, e)
    }
  }
  function bE(e, n, i) {
    {
      var s = e.stateNode,
        u = n.childContextTypes
      if (typeof s.getChildContext != 'function') {
        {
          var d = nt(e) || 'Unknown'
          gy[d] ||
            ((gy[d] = !0),
            c(
              '%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.',
              d,
              d
            ))
        }
        return i
      }
      var v = s.getChildContext()
      for (var y in v)
        if (!(y in u))
          throw new Error(
            (nt(e) || 'Unknown') +
              '.getChildContext(): key "' +
              y +
              '" is not defined in childContextTypes.'
          )
      {
        var x = nt(e) || 'Unknown'
        ti(u, v, 'child context', x)
      }
      return ot({}, i, v)
    }
  }
  function Jp(e) {
    {
      var n = e.stateNode,
        i = (n && n.__reactInternalMemoizedMergedChildContext) || Ta
      return (yy = po.current), Mr(po, i, e), Mr(_i, _i.current, e), !0
    }
  }
  function SE(e, n, i) {
    {
      var s = e.stateNode
      if (!s)
        throw new Error(
          'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'
        )
      if (i) {
        var u = bE(e, n, yy)
        ;(s.__reactInternalMemoizedMergedChildContext = u),
          Or(_i, e),
          Or(po, e),
          Mr(po, u, e),
          Mr(_i, i, e)
      } else Or(_i, e), Mr(_i, i, e)
    }
  }
  function d5(e) {
    {
      if (!qP(e) || e.tag !== m)
        throw new Error(
          'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'
        )
      var n = e
      do {
        switch (n.tag) {
          case b:
            return n.stateNode.context
          case m: {
            var i = n.type
            if (ki(i)) return n.stateNode.__reactInternalMemoizedMergedChildContext
            break
          }
        }
        n = n.return
      } while (n !== null)
      throw new Error(
        'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'
      )
    }
  }
  var ns = 0,
    eh = 1,
    ho = null,
    Sy = !1,
    xy = !1
  function xE(e) {
    ho === null ? (ho = [e]) : ho.push(e)
  }
  function p5(e) {
    ;(Sy = !0), xE(e)
  }
  function CE() {
    Sy && rs()
  }
  function rs() {
    if (!xy && ho !== null) {
      xy = !0
      var e = 0,
        n = ei()
      try {
        var i = !0,
          s = ho
        for (mr(Ca); e < s.length; e++) {
          var u = s[e]
          do u = u(i)
          while (u !== null)
        }
        ;(ho = null), (Sy = !1)
      } catch (d) {
        throw (ho !== null && (ho = ho.slice(e + 1)), YC(vp, rs), d)
      } finally {
        mr(n), (xy = !1)
      }
    }
    return null
  }
  var yu = [],
    bu = 0,
    th = null,
    nh = 0,
    $a = [],
    Fa = 0,
    sl = null,
    mo = 1,
    vo = ''
  function h5(e) {
    return ul(), (e.flags & NC) !== Ve
  }
  function m5(e) {
    return ul(), nh
  }
  function v5() {
    var e = vo,
      n = mo,
      i = n & ~g5(n)
    return i.toString(32) + e
  }
  function ll(e, n) {
    ul(), (yu[bu++] = nh), (yu[bu++] = th), (th = e), (nh = n)
  }
  function wE(e, n, i) {
    ul(), ($a[Fa++] = mo), ($a[Fa++] = vo), ($a[Fa++] = sl), (sl = e)
    var s = mo,
      u = vo,
      d = rh(s) - 1,
      v = s & ~(1 << d),
      y = i + 1,
      x = rh(n) + d
    if (x > 30) {
      var T = d - (d % 5),
        _ = (1 << T) - 1,
        N = (v & _).toString(32),
        $ = v >> T,
        q = d - T,
        K = rh(n) + q,
        re = y << q,
        De = re | $,
        je = N + u
      ;(mo = (1 << K) | De), (vo = je)
    } else {
      var Fe = y << d,
        St = Fe | v,
        ht = u
      ;(mo = (1 << x) | St), (vo = ht)
    }
  }
  function Cy(e) {
    ul()
    var n = e.return
    if (n !== null) {
      var i = 1,
        s = 0
      ll(e, i), wE(e, i, s)
    }
  }
  function rh(e) {
    return 32 - ZC(e)
  }
  function g5(e) {
    return 1 << (rh(e) - 1)
  }
  function wy(e) {
    for (; e === th; ) (th = yu[--bu]), (yu[bu] = null), (nh = yu[--bu]), (yu[bu] = null)
    for (; e === sl; )
      (sl = $a[--Fa]),
        ($a[Fa] = null),
        (vo = $a[--Fa]),
        ($a[Fa] = null),
        (mo = $a[--Fa]),
        ($a[Fa] = null)
  }
  function y5() {
    return ul(), sl !== null ? { id: mo, overflow: vo } : null
  }
  function b5(e, n) {
    ul(),
      ($a[Fa++] = mo),
      ($a[Fa++] = vo),
      ($a[Fa++] = sl),
      (mo = n.id),
      (vo = n.overflow),
      (sl = e)
  }
  function ul() {
    yr() || c('Expected to be hydrating. This is a bug in React. Please file an issue.')
  }
  var gr = null,
    Na = null,
    ni = !1,
    cl = !1,
    as = null
  function S5() {
    ni && c('We should not be hydrating here. This is a bug in React. Please file a bug.')
  }
  function EE() {
    cl = !0
  }
  function x5() {
    return cl
  }
  function C5(e) {
    var n = e.stateNode.containerInfo
    return (Na = j2(n)), (gr = e), (ni = !0), (as = null), (cl = !1), !0
  }
  function w5(e, n, i) {
    return (Na = U2(n)), (gr = e), (ni = !0), (as = null), (cl = !1), i !== null && b5(e, i), !0
  }
  function TE(e, n) {
    switch (e.tag) {
      case b: {
        Q2(e.stateNode.containerInfo, n)
        break
      }
      case w: {
        var i = (e.mode & yt) !== Ie
        J2(e.type, e.memoizedProps, e.stateNode, n, i)
        break
      }
      case j: {
        var s = e.memoizedState
        s.dehydrated !== null && Z2(s.dehydrated, n)
        break
      }
    }
  }
  function RE(e, n) {
    TE(e, n)
    var i = RB()
    ;(i.stateNode = n), (i.return = e)
    var s = e.deletions
    s === null ? ((e.deletions = [i]), (e.flags |= qs)) : s.push(i)
  }
  function Ey(e, n) {
    {
      if (cl) return
      switch (e.tag) {
        case b: {
          var i = e.stateNode.containerInfo
          switch (n.tag) {
            case w:
              var s = n.type
              n.pendingProps, e5(i, s)
              break
            case k:
              var u = n.pendingProps
              t5(i, u)
              break
          }
          break
        }
        case w: {
          var d = e.type,
            v = e.memoizedProps,
            y = e.stateNode
          switch (n.tag) {
            case w: {
              var x = n.type,
                T = n.pendingProps,
                _ = (e.mode & yt) !== Ie
              a5(d, v, y, x, T, _)
              break
            }
            case k: {
              var N = n.pendingProps,
                $ = (e.mode & yt) !== Ie
              i5(d, v, y, N, $)
              break
            }
          }
          break
        }
        case j: {
          var q = e.memoizedState,
            K = q.dehydrated
          if (K !== null)
            switch (n.tag) {
              case w:
                var re = n.type
                n.pendingProps, n5(K, re)
                break
              case k:
                var De = n.pendingProps
                r5(K, De)
                break
            }
          break
        }
        default:
          return
      }
    }
  }
  function _E(e, n) {
    ;(n.flags = (n.flags & ~io) | In), Ey(e, n)
  }
  function kE(e, n) {
    switch (e.tag) {
      case w: {
        var i = e.type
        e.pendingProps
        var s = L2(n, i)
        return s !== null ? ((e.stateNode = s), (gr = e), (Na = B2(s)), !0) : !1
      }
      case k: {
        var u = e.pendingProps,
          d = z2(n, u)
        return d !== null ? ((e.stateNode = d), (gr = e), (Na = null), !0) : !1
      }
      case j: {
        var v = $2(n)
        if (v !== null) {
          var y = { dehydrated: v, treeContext: y5(), retryLane: Sa }
          e.memoizedState = y
          var x = _B(v)
          return (x.return = e), (e.child = x), (gr = e), (Na = null), !0
        }
        return !1
      }
      default:
        return !1
    }
  }
  function Ty(e) {
    return (e.mode & yt) !== Ie && (e.flags & Lt) === Ve
  }
  function Ry(e) {
    throw new Error(
      'Hydration failed because the initial UI does not match what was rendered on the server.'
    )
  }
  function _y(e) {
    if (ni) {
      var n = Na
      if (!n) {
        Ty(e) && (Ey(gr, e), Ry()), _E(gr, e), (ni = !1), (gr = e)
        return
      }
      var i = n
      if (!kE(e, n)) {
        Ty(e) && (Ey(gr, e), Ry()), (n = uf(i))
        var s = gr
        if (!n || !kE(e, n)) {
          _E(gr, e), (ni = !1), (gr = e)
          return
        }
        RE(s, i)
      }
    }
  }
  function E5(e, n, i) {
    var s = e.stateNode,
      u = !cl,
      d = V2(s, e.type, e.memoizedProps, n, i, e, u)
    return (e.updateQueue = d), d !== null
  }
  function T5(e) {
    var n = e.stateNode,
      i = e.memoizedProps,
      s = I2(n, i, e)
    if (s) {
      var u = gr
      if (u !== null)
        switch (u.tag) {
          case b: {
            var d = u.stateNode.containerInfo,
              v = (u.mode & yt) !== Ie
            K2(d, n, i, v)
            break
          }
          case w: {
            var y = u.type,
              x = u.memoizedProps,
              T = u.stateNode,
              _ = (u.mode & yt) !== Ie
            X2(y, x, T, n, i, _)
            break
          }
        }
    }
    return s
  }
  function R5(e) {
    var n = e.memoizedState,
      i = n !== null ? n.dehydrated : null
    if (!i)
      throw new Error(
        'Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.'
      )
    H2(i, e)
  }
  function _5(e) {
    var n = e.memoizedState,
      i = n !== null ? n.dehydrated : null
    if (!i)
      throw new Error(
        'Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.'
      )
    return W2(i)
  }
  function DE(e) {
    for (var n = e.return; n !== null && n.tag !== w && n.tag !== b && n.tag !== j; ) n = n.return
    gr = n
  }
  function ah(e) {
    if (e !== gr) return !1
    if (!ni) return DE(e), (ni = !0), !1
    if (e.tag !== b && (e.tag !== w || (q2(e.type) && !ly(e.type, e.memoizedProps)))) {
      var n = Na
      if (n)
        if (Ty(e)) AE(e), Ry()
        else for (; n; ) RE(e, n), (n = uf(n))
    }
    return DE(e), e.tag === j ? (Na = _5(e)) : (Na = gr ? uf(e.stateNode) : null), !0
  }
  function k5() {
    return ni && Na !== null
  }
  function AE(e) {
    for (var n = Na; n; ) TE(e, n), (n = uf(n))
  }
  function Su() {
    ;(gr = null), (Na = null), (ni = !1), (cl = !1)
  }
  function OE() {
    as !== null && (T1(as), (as = null))
  }
  function yr() {
    return ni
  }
  function ky(e) {
    as === null ? (as = [e]) : as.push(e)
  }
  var D5 = a.ReactCurrentBatchConfig,
    A5 = null
  function O5() {
    return D5.transition
  }
  var ri = {
    recordUnsafeLifecycleWarnings: function (e, n) {},
    flushPendingUnsafeLifecycleWarnings: function () {},
    recordLegacyContextWarning: function (e, n) {},
    flushLegacyContextWarning: function () {},
    discardPendingWarnings: function () {},
  }
  {
    var M5 = function (e) {
        for (var n = null, i = e; i !== null; ) i.mode & Hn && (n = i), (i = i.return)
        return n
      },
      fl = function (e) {
        var n = []
        return (
          e.forEach(function (i) {
            n.push(i)
          }),
          n.sort().join(', ')
        )
      },
      pf = [],
      hf = [],
      mf = [],
      vf = [],
      gf = [],
      yf = [],
      dl = new Set()
    ;(ri.recordUnsafeLifecycleWarnings = function (e, n) {
      dl.has(e.type) ||
        (typeof n.componentWillMount == 'function' &&
          n.componentWillMount.__suppressDeprecationWarning !== !0 &&
          pf.push(e),
        e.mode & Hn && typeof n.UNSAFE_componentWillMount == 'function' && hf.push(e),
        typeof n.componentWillReceiveProps == 'function' &&
          n.componentWillReceiveProps.__suppressDeprecationWarning !== !0 &&
          mf.push(e),
        e.mode & Hn && typeof n.UNSAFE_componentWillReceiveProps == 'function' && vf.push(e),
        typeof n.componentWillUpdate == 'function' &&
          n.componentWillUpdate.__suppressDeprecationWarning !== !0 &&
          gf.push(e),
        e.mode & Hn && typeof n.UNSAFE_componentWillUpdate == 'function' && yf.push(e))
    }),
      (ri.flushPendingUnsafeLifecycleWarnings = function () {
        var e = new Set()
        pf.length > 0 &&
          (pf.forEach(function ($) {
            e.add(nt($) || 'Component'), dl.add($.type)
          }),
          (pf = []))
        var n = new Set()
        hf.length > 0 &&
          (hf.forEach(function ($) {
            n.add(nt($) || 'Component'), dl.add($.type)
          }),
          (hf = []))
        var i = new Set()
        mf.length > 0 &&
          (mf.forEach(function ($) {
            i.add(nt($) || 'Component'), dl.add($.type)
          }),
          (mf = []))
        var s = new Set()
        vf.length > 0 &&
          (vf.forEach(function ($) {
            s.add(nt($) || 'Component'), dl.add($.type)
          }),
          (vf = []))
        var u = new Set()
        gf.length > 0 &&
          (gf.forEach(function ($) {
            u.add(nt($) || 'Component'), dl.add($.type)
          }),
          (gf = []))
        var d = new Set()
        if (
          (yf.length > 0 &&
            (yf.forEach(function ($) {
              d.add(nt($) || 'Component'), dl.add($.type)
            }),
            (yf = [])),
          n.size > 0)
        ) {
          var v = fl(n)
          c(
            `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
            v
          )
        }
        if (s.size > 0) {
          var y = fl(s)
          c(
            `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`,
            y
          )
        }
        if (d.size > 0) {
          var x = fl(d)
          c(
            `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
            x
          )
        }
        if (e.size > 0) {
          var T = fl(e)
          f(
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
            T
          )
        }
        if (i.size > 0) {
          var _ = fl(i)
          f(
            `componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
            _
          )
        }
        if (u.size > 0) {
          var N = fl(u)
          f(
            `componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
            N
          )
        }
      })
    var ih = new Map(),
      ME = new Set()
    ;(ri.recordLegacyContextWarning = function (e, n) {
      var i = M5(e)
      if (i === null) {
        c(
          'Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.'
        )
        return
      }
      if (!ME.has(e.type)) {
        var s = ih.get(i)
        ;(e.type.contextTypes != null ||
          e.type.childContextTypes != null ||
          (n !== null && typeof n.getChildContext == 'function')) &&
          (s === void 0 && ((s = []), ih.set(i, s)), s.push(e))
      }
    }),
      (ri.flushLegacyContextWarning = function () {
        ih.forEach(function (e, n) {
          if (e.length !== 0) {
            var i = e[0],
              s = new Set()
            e.forEach(function (d) {
              s.add(nt(d) || 'Component'), ME.add(d.type)
            })
            var u = fl(s)
            try {
              mn(i),
                c(
                  `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`,
                  u
                )
            } finally {
              Un()
            }
          }
        })
      }),
      (ri.discardPendingWarnings = function () {
        ;(pf = []), (hf = []), (mf = []), (vf = []), (gf = []), (yf = []), (ih = new Map())
      })
  }
  function ai(e, n) {
    if (e && e.defaultProps) {
      var i = ot({}, n),
        s = e.defaultProps
      for (var u in s) i[u] === void 0 && (i[u] = s[u])
      return i
    }
    return n
  }
  var Dy = ts(null),
    Ay
  Ay = {}
  var oh = null,
    xu = null,
    Oy = null,
    sh = !1
  function lh() {
    ;(oh = null), (xu = null), (Oy = null), (sh = !1)
  }
  function PE() {
    sh = !0
  }
  function LE() {
    sh = !1
  }
  function zE(e, n, i) {
    Mr(Dy, n._currentValue, e),
      (n._currentValue = i),
      n._currentRenderer !== void 0 &&
        n._currentRenderer !== null &&
        n._currentRenderer !== Ay &&
        c(
          'Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.'
        ),
      (n._currentRenderer = Ay)
  }
  function My(e, n) {
    var i = Dy.current
    Or(Dy, n), (e._currentValue = i)
  }
  function Py(e, n, i) {
    for (var s = e; s !== null; ) {
      var u = s.alternate
      if (
        (ou(s.childLanes, n)
          ? u !== null && !ou(u.childLanes, n) && (u.childLanes = lt(u.childLanes, n))
          : ((s.childLanes = lt(s.childLanes, n)),
            u !== null && (u.childLanes = lt(u.childLanes, n))),
        s === i)
      )
        break
      s = s.return
    }
    s !== i &&
      c(
        'Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.'
      )
  }
  function P5(e, n, i) {
    L5(e, n, i)
  }
  function L5(e, n, i) {
    var s = e.child
    for (s !== null && (s.return = e); s !== null; ) {
      var u = void 0,
        d = s.dependencies
      if (d !== null) {
        u = s.child
        for (var v = d.firstContext; v !== null; ) {
          if (v.context === n) {
            if (s.tag === m) {
              var y = $c(i),
                x = go(vn, y)
              x.tag = ch
              var T = s.updateQueue
              if (T !== null) {
                var _ = T.shared,
                  N = _.pending
                N === null ? (x.next = x) : ((x.next = N.next), (N.next = x)), (_.pending = x)
              }
            }
            s.lanes = lt(s.lanes, i)
            var $ = s.alternate
            $ !== null && ($.lanes = lt($.lanes, i)), Py(s.return, i, e), (d.lanes = lt(d.lanes, i))
            break
          }
          v = v.next
        }
      } else if (s.tag === z) u = s.type === e.type ? null : s.child
      else if (s.tag === le) {
        var q = s.return
        if (q === null)
          throw new Error(
            'We just came from a parent so we must have had a parent. This is a bug in React.'
          )
        q.lanes = lt(q.lanes, i)
        var K = q.alternate
        K !== null && (K.lanes = lt(K.lanes, i)), Py(q, i, e), (u = s.sibling)
      } else u = s.child
      if (u !== null) u.return = s
      else
        for (u = s; u !== null; ) {
          if (u === e) {
            u = null
            break
          }
          var re = u.sibling
          if (re !== null) {
            ;(re.return = u.return), (u = re)
            break
          }
          u = u.return
        }
      s = u
    }
  }
  function Cu(e, n) {
    ;(oh = e), (xu = null), (Oy = null)
    var i = e.dependencies
    if (i !== null) {
      var s = i.firstContext
      s !== null && (xa(i.lanes, n) && Mf(), (i.firstContext = null))
    }
  }
  function Wn(e) {
    sh &&
      c(
        'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
      )
    var n = e._currentValue
    if (Oy !== e) {
      var i = { context: e, memoizedValue: n, next: null }
      if (xu === null) {
        if (oh === null)
          throw new Error(
            'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
          )
        ;(xu = i), (oh.dependencies = { lanes: ue, firstContext: i })
      } else xu = xu.next = i
    }
    return n
  }
  var pl = null
  function Ly(e) {
    pl === null ? (pl = [e]) : pl.push(e)
  }
  function z5() {
    if (pl !== null) {
      for (var e = 0; e < pl.length; e++) {
        var n = pl[e],
          i = n.interleaved
        if (i !== null) {
          n.interleaved = null
          var s = i.next,
            u = n.pending
          if (u !== null) {
            var d = u.next
            ;(u.next = s), (i.next = d)
          }
          n.pending = i
        }
      }
      pl = null
    }
  }
  function $E(e, n, i, s) {
    var u = n.interleaved
    return (
      u === null ? ((i.next = i), Ly(n)) : ((i.next = u.next), (u.next = i)),
      (n.interleaved = i),
      uh(e, s)
    )
  }
  function $5(e, n, i, s) {
    var u = n.interleaved
    u === null ? ((i.next = i), Ly(n)) : ((i.next = u.next), (u.next = i)), (n.interleaved = i)
  }
  function F5(e, n, i, s) {
    var u = n.interleaved
    return (
      u === null ? ((i.next = i), Ly(n)) : ((i.next = u.next), (u.next = i)),
      (n.interleaved = i),
      uh(e, s)
    )
  }
  function ia(e, n) {
    return uh(e, n)
  }
  var N5 = uh
  function uh(e, n) {
    e.lanes = lt(e.lanes, n)
    var i = e.alternate
    i !== null && (i.lanes = lt(i.lanes, n)), i === null && (e.flags & (In | io)) !== Ve && F1(e)
    for (var s = e, u = e.return; u !== null; )
      (u.childLanes = lt(u.childLanes, n)),
        (i = u.alternate),
        i !== null ? (i.childLanes = lt(i.childLanes, n)) : (u.flags & (In | io)) !== Ve && F1(e),
        (s = u),
        (u = u.return)
    if (s.tag === b) {
      var d = s.stateNode
      return d
    } else return null
  }
  var FE = 0,
    NE = 1,
    ch = 2,
    zy = 3,
    fh = !1,
    $y,
    dh
  ;($y = !1), (dh = null)
  function Fy(e) {
    var n = {
      baseState: e.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: ue },
      effects: null,
    }
    e.updateQueue = n
  }
  function BE(e, n) {
    var i = n.updateQueue,
      s = e.updateQueue
    if (i === s) {
      var u = {
        baseState: s.baseState,
        firstBaseUpdate: s.firstBaseUpdate,
        lastBaseUpdate: s.lastBaseUpdate,
        shared: s.shared,
        effects: s.effects,
      }
      n.updateQueue = u
    }
  }
  function go(e, n) {
    var i = { eventTime: e, lane: n, tag: FE, payload: null, callback: null, next: null }
    return i
  }
  function is(e, n, i) {
    var s = e.updateQueue
    if (s === null) return null
    var u = s.shared
    if (
      (dh === u &&
        !$y &&
        (c(
          'An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.'
        ),
        ($y = !0)),
      NN())
    ) {
      var d = u.pending
      return (
        d === null ? (n.next = n) : ((n.next = d.next), (d.next = n)), (u.pending = n), N5(e, i)
      )
    } else return F5(e, u, n, i)
  }
  function ph(e, n, i) {
    var s = n.updateQueue
    if (s !== null) {
      var u = s.shared
      if (nw(i)) {
        var d = u.lanes
        d = aw(d, e.pendingLanes)
        var v = lt(d, i)
        ;(u.lanes = v), Lg(e, v)
      }
    }
  }
  function Ny(e, n) {
    var i = e.updateQueue,
      s = e.alternate
    if (s !== null) {
      var u = s.updateQueue
      if (i === u) {
        var d = null,
          v = null,
          y = i.firstBaseUpdate
        if (y !== null) {
          var x = y
          do {
            var T = {
              eventTime: x.eventTime,
              lane: x.lane,
              tag: x.tag,
              payload: x.payload,
              callback: x.callback,
              next: null,
            }
            v === null ? (d = v = T) : ((v.next = T), (v = T)), (x = x.next)
          } while (x !== null)
          v === null ? (d = v = n) : ((v.next = n), (v = n))
        } else d = v = n
        ;(i = {
          baseState: u.baseState,
          firstBaseUpdate: d,
          lastBaseUpdate: v,
          shared: u.shared,
          effects: u.effects,
        }),
          (e.updateQueue = i)
        return
      }
    }
    var _ = i.lastBaseUpdate
    _ === null ? (i.firstBaseUpdate = n) : (_.next = n), (i.lastBaseUpdate = n)
  }
  function B5(e, n, i, s, u, d) {
    switch (i.tag) {
      case NE: {
        var v = i.payload
        if (typeof v == 'function') {
          PE()
          var y = v.call(d, s, u)
          {
            if (e.mode & Hn) {
              pr(!0)
              try {
                v.call(d, s, u)
              } finally {
                pr(!1)
              }
            }
            LE()
          }
          return y
        }
        return v
      }
      case zy:
        e.flags = (e.flags & ~Vr) | Lt
      case FE: {
        var x = i.payload,
          T
        if (typeof x == 'function') {
          PE(), (T = x.call(d, s, u))
          {
            if (e.mode & Hn) {
              pr(!0)
              try {
                x.call(d, s, u)
              } finally {
                pr(!1)
              }
            }
            LE()
          }
        } else T = x
        return T == null ? s : ot({}, s, T)
      }
      case ch:
        return (fh = !0), s
    }
    return s
  }
  function hh(e, n, i, s) {
    var u = e.updateQueue
    ;(fh = !1), (dh = u.shared)
    var d = u.firstBaseUpdate,
      v = u.lastBaseUpdate,
      y = u.shared.pending
    if (y !== null) {
      u.shared.pending = null
      var x = y,
        T = x.next
      ;(x.next = null), v === null ? (d = T) : (v.next = T), (v = x)
      var _ = e.alternate
      if (_ !== null) {
        var N = _.updateQueue,
          $ = N.lastBaseUpdate
        $ !== v && ($ === null ? (N.firstBaseUpdate = T) : ($.next = T), (N.lastBaseUpdate = x))
      }
    }
    if (d !== null) {
      var q = u.baseState,
        K = ue,
        re = null,
        De = null,
        je = null,
        Fe = d
      do {
        var St = Fe.lane,
          ht = Fe.eventTime
        if (ou(s, St)) {
          if (je !== null) {
            var ae = {
              eventTime: ht,
              lane: hr,
              tag: Fe.tag,
              payload: Fe.payload,
              callback: Fe.callback,
              next: null,
            }
            je = je.next = ae
          }
          q = B5(e, u, Fe, q, n, i)
          var W = Fe.callback
          if (W !== null && Fe.lane !== hr) {
            e.flags |= tg
            var fe = u.effects
            fe === null ? (u.effects = [Fe]) : fe.push(Fe)
          }
        } else {
          var H = {
            eventTime: ht,
            lane: St,
            tag: Fe.tag,
            payload: Fe.payload,
            callback: Fe.callback,
            next: null,
          }
          je === null ? ((De = je = H), (re = q)) : (je = je.next = H), (K = lt(K, St))
        }
        if (((Fe = Fe.next), Fe === null)) {
          if (((y = u.shared.pending), y === null)) break
          var Ae = y,
            we = Ae.next
          ;(Ae.next = null), (Fe = we), (u.lastBaseUpdate = Ae), (u.shared.pending = null)
        }
      } while (!0)
      je === null && (re = q), (u.baseState = re), (u.firstBaseUpdate = De), (u.lastBaseUpdate = je)
      var Ye = u.shared.interleaved
      if (Ye !== null) {
        var tt = Ye
        do (K = lt(K, tt.lane)), (tt = tt.next)
        while (tt !== Ye)
      } else d === null && (u.shared.lanes = ue)
      Hf(K), (e.lanes = K), (e.memoizedState = q)
    }
    dh = null
  }
  function j5(e, n) {
    if (typeof e != 'function')
      throw new Error(
        'Invalid argument passed as callback. Expected a function. Instead ' + ('received: ' + e)
      )
    e.call(n)
  }
  function jE() {
    fh = !1
  }
  function mh() {
    return fh
  }
  function UE(e, n, i) {
    var s = n.effects
    if (((n.effects = null), s !== null))
      for (var u = 0; u < s.length; u++) {
        var d = s[u],
          v = d.callback
        v !== null && ((d.callback = null), j5(v, i))
      }
  }
  var By = {},
    VE = new t.Component().refs,
    jy,
    Uy,
    Vy,
    Iy,
    Hy,
    IE,
    vh,
    Wy,
    Yy,
    Gy
  {
    ;(jy = new Set()),
      (Uy = new Set()),
      (Vy = new Set()),
      (Iy = new Set()),
      (Wy = new Set()),
      (Hy = new Set()),
      (Yy = new Set()),
      (Gy = new Set())
    var HE = new Set()
    ;(vh = function (e, n) {
      if (!(e === null || typeof e == 'function')) {
        var i = n + '_' + e
        HE.has(i) ||
          (HE.add(i),
          c(
            '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
            n,
            e
          ))
      }
    }),
      (IE = function (e, n) {
        if (n === void 0) {
          var i = kt(e) || 'Component'
          Hy.has(i) ||
            (Hy.add(i),
            c(
              '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.',
              i
            ))
        }
      }),
      Object.defineProperty(By, '_processChildContext', {
        enumerable: !1,
        value: function () {
          throw new Error(
            "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)."
          )
        },
      }),
      Object.freeze(By)
  }
  function qy(e, n, i, s) {
    var u = e.memoizedState,
      d = i(s, u)
    {
      if (e.mode & Hn) {
        pr(!0)
        try {
          d = i(s, u)
        } finally {
          pr(!1)
        }
      }
      IE(n, d)
    }
    var v = d == null ? u : ot({}, u, d)
    if (((e.memoizedState = v), e.lanes === ue)) {
      var y = e.updateQueue
      y.baseState = v
    }
  }
  var Ky = {
    isMounted: KP,
    enqueueSetState: function (e, n, i) {
      var s = Zl(e),
        u = Wr(),
        d = ps(s),
        v = go(u, d)
      ;(v.payload = n), i != null && (vh(i, 'setState'), (v.callback = i))
      var y = is(s, v, d)
      y !== null && (or(y, s, d, u), ph(y, s, d)), ug(s, d)
    },
    enqueueReplaceState: function (e, n, i) {
      var s = Zl(e),
        u = Wr(),
        d = ps(s),
        v = go(u, d)
      ;(v.tag = NE), (v.payload = n), i != null && (vh(i, 'replaceState'), (v.callback = i))
      var y = is(s, v, d)
      y !== null && (or(y, s, d, u), ph(y, s, d)), ug(s, d)
    },
    enqueueForceUpdate: function (e, n) {
      var i = Zl(e),
        s = Wr(),
        u = ps(i),
        d = go(s, u)
      ;(d.tag = ch), n != null && (vh(n, 'forceUpdate'), (d.callback = n))
      var v = is(i, d, u)
      v !== null && (or(v, i, u, s), ph(v, i, u)), RL(i, u)
    },
  }
  function WE(e, n, i, s, u, d, v) {
    var y = e.stateNode
    if (typeof y.shouldComponentUpdate == 'function') {
      var x = y.shouldComponentUpdate(s, d, v)
      {
        if (e.mode & Hn) {
          pr(!0)
          try {
            x = y.shouldComponentUpdate(s, d, v)
          } finally {
            pr(!1)
          }
        }
        x === void 0 &&
          c(
            '%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.',
            kt(n) || 'Component'
          )
      }
      return x
    }
    return n.prototype && n.prototype.isPureReactComponent ? !Qc(i, s) || !Qc(u, d) : !0
  }
  function U5(e, n, i) {
    var s = e.stateNode
    {
      var u = kt(n) || 'Component',
        d = s.render
      d ||
        (n.prototype && typeof n.prototype.render == 'function'
          ? c(
              '%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?',
              u
            )
          : c(
              '%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.',
              u
            )),
        s.getInitialState &&
          !s.getInitialState.isReactClassApproved &&
          !s.state &&
          c(
            'getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?',
            u
          ),
        s.getDefaultProps &&
          !s.getDefaultProps.isReactClassApproved &&
          c(
            'getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.',
            u
          ),
        s.propTypes &&
          c(
            'propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.',
            u
          ),
        s.contextType &&
          c(
            'contextType was defined as an instance property on %s. Use a static property to define contextType instead.',
            u
          ),
        s.contextTypes &&
          c(
            'contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.',
            u
          ),
        n.contextType &&
          n.contextTypes &&
          !Yy.has(n) &&
          (Yy.add(n),
          c(
            '%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.',
            u
          )),
        typeof s.componentShouldUpdate == 'function' &&
          c(
            '%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.',
            u
          ),
        n.prototype &&
          n.prototype.isPureReactComponent &&
          typeof s.shouldComponentUpdate < 'u' &&
          c(
            '%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.',
            kt(n) || 'A pure component'
          ),
        typeof s.componentDidUnmount == 'function' &&
          c(
            '%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?',
            u
          ),
        typeof s.componentDidReceiveProps == 'function' &&
          c(
            '%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
            u
          ),
        typeof s.componentWillRecieveProps == 'function' &&
          c(
            '%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
            u
          ),
        typeof s.UNSAFE_componentWillRecieveProps == 'function' &&
          c(
            '%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',
            u
          )
      var v = s.props !== i
      s.props !== void 0 &&
        v &&
        c(
          "%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
          u,
          u
        ),
        s.defaultProps &&
          c(
            'Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.',
            u,
            u
          ),
        typeof s.getSnapshotBeforeUpdate == 'function' &&
          typeof s.componentDidUpdate != 'function' &&
          !Vy.has(n) &&
          (Vy.add(n),
          c(
            '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.',
            kt(n)
          )),
        typeof s.getDerivedStateFromProps == 'function' &&
          c(
            '%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
            u
          ),
        typeof s.getDerivedStateFromError == 'function' &&
          c(
            '%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
            u
          ),
        typeof n.getSnapshotBeforeUpdate == 'function' &&
          c(
            '%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.',
            u
          )
      var y = s.state
      y && (typeof y != 'object' || Pt(y)) && c('%s.state: must be set to an object or null', u),
        typeof s.getChildContext == 'function' &&
          typeof n.childContextTypes != 'object' &&
          c(
            '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().',
            u
          )
    }
  }
  function YE(e, n) {
    ;(n.updater = Ky), (e.stateNode = n), HP(n, e), (n._reactInternalInstance = By)
  }
  function GE(e, n, i) {
    var s = !1,
      u = Ta,
      d = Ta,
      v = n.contextType
    if ('contextType' in n) {
      var y = v === null || (v !== void 0 && v.$$typeof === ve && v._context === void 0)
      if (!y && !Gy.has(n)) {
        Gy.add(n)
        var x = ''
        v === void 0
          ? (x =
              ' However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.')
          : typeof v != 'object'
          ? (x = ' However, it is set to a ' + typeof v + '.')
          : v.$$typeof === se
          ? (x = ' Did you accidentally pass the Context.Provider instead?')
          : v._context !== void 0
          ? (x = ' Did you accidentally pass the Context.Consumer instead?')
          : (x = ' However, it is set to an object with keys {' + Object.keys(v).join(', ') + '}.'),
          c(
            '%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s',
            kt(n) || 'Component',
            x
          )
      }
    }
    if (typeof v == 'object' && v !== null) d = Wn(v)
    else {
      u = vu(e, n, !0)
      var T = n.contextTypes
      ;(s = T != null), (d = s ? gu(e, u) : Ta)
    }
    var _ = new n(i, d)
    if (e.mode & Hn) {
      pr(!0)
      try {
        _ = new n(i, d)
      } finally {
        pr(!1)
      }
    }
    var N = (e.memoizedState = _.state !== null && _.state !== void 0 ? _.state : null)
    YE(e, _)
    {
      if (typeof n.getDerivedStateFromProps == 'function' && N === null) {
        var $ = kt(n) || 'Component'
        Uy.has($) ||
          (Uy.add($),
          c(
            '`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',
            $,
            _.state === null ? 'null' : 'undefined',
            $
          ))
      }
      if (
        typeof n.getDerivedStateFromProps == 'function' ||
        typeof _.getSnapshotBeforeUpdate == 'function'
      ) {
        var q = null,
          K = null,
          re = null
        if (
          (typeof _.componentWillMount == 'function' &&
          _.componentWillMount.__suppressDeprecationWarning !== !0
            ? (q = 'componentWillMount')
            : typeof _.UNSAFE_componentWillMount == 'function' && (q = 'UNSAFE_componentWillMount'),
          typeof _.componentWillReceiveProps == 'function' &&
          _.componentWillReceiveProps.__suppressDeprecationWarning !== !0
            ? (K = 'componentWillReceiveProps')
            : typeof _.UNSAFE_componentWillReceiveProps == 'function' &&
              (K = 'UNSAFE_componentWillReceiveProps'),
          typeof _.componentWillUpdate == 'function' &&
          _.componentWillUpdate.__suppressDeprecationWarning !== !0
            ? (re = 'componentWillUpdate')
            : typeof _.UNSAFE_componentWillUpdate == 'function' &&
              (re = 'UNSAFE_componentWillUpdate'),
          q !== null || K !== null || re !== null)
        ) {
          var De = kt(n) || 'Component',
            je =
              typeof n.getDerivedStateFromProps == 'function'
                ? 'getDerivedStateFromProps()'
                : 'getSnapshotBeforeUpdate()'
          Iy.has(De) ||
            (Iy.add(De),
            c(
              `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`,
              De,
              je,
              q !== null
                ? `
  ` + q
                : '',
              K !== null
                ? `
  ` + K
                : '',
              re !== null
                ? `
  ` + re
                : ''
            ))
        }
      }
    }
    return s && gE(e, u, d), _
  }
  function V5(e, n) {
    var i = n.state
    typeof n.componentWillMount == 'function' && n.componentWillMount(),
      typeof n.UNSAFE_componentWillMount == 'function' && n.UNSAFE_componentWillMount(),
      i !== n.state &&
        (c(
          "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          nt(e) || 'Component'
        ),
        Ky.enqueueReplaceState(n, n.state, null))
  }
  function qE(e, n, i, s) {
    var u = n.state
    if (
      (typeof n.componentWillReceiveProps == 'function' && n.componentWillReceiveProps(i, s),
      typeof n.UNSAFE_componentWillReceiveProps == 'function' &&
        n.UNSAFE_componentWillReceiveProps(i, s),
      n.state !== u)
    ) {
      {
        var d = nt(e) || 'Component'
        jy.has(d) ||
          (jy.add(d),
          c(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            d
          ))
      }
      Ky.enqueueReplaceState(n, n.state, null)
    }
  }
  function Xy(e, n, i, s) {
    U5(e, n, i)
    var u = e.stateNode
    ;(u.props = i), (u.state = e.memoizedState), (u.refs = VE), Fy(e)
    var d = n.contextType
    if (typeof d == 'object' && d !== null) u.context = Wn(d)
    else {
      var v = vu(e, n, !0)
      u.context = gu(e, v)
    }
    {
      if (u.state === i) {
        var y = kt(n) || 'Component'
        Wy.has(y) ||
          (Wy.add(y),
          c(
            "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
            y
          ))
      }
      e.mode & Hn && ri.recordLegacyContextWarning(e, u), ri.recordUnsafeLifecycleWarnings(e, u)
    }
    u.state = e.memoizedState
    var x = n.getDerivedStateFromProps
    if (
      (typeof x == 'function' && (qy(e, n, x, i), (u.state = e.memoizedState)),
      typeof n.getDerivedStateFromProps != 'function' &&
        typeof u.getSnapshotBeforeUpdate != 'function' &&
        (typeof u.UNSAFE_componentWillMount == 'function' ||
          typeof u.componentWillMount == 'function') &&
        (V5(e, u), hh(e, i, u, s), (u.state = e.memoizedState)),
      typeof u.componentDidMount == 'function')
    ) {
      var T = Tt
      ;(T |= Qs), (e.mode & Ti) !== Ie && (T |= oo), (e.flags |= T)
    }
  }
  function I5(e, n, i, s) {
    var u = e.stateNode,
      d = e.memoizedProps
    u.props = d
    var v = u.context,
      y = n.contextType,
      x = Ta
    if (typeof y == 'object' && y !== null) x = Wn(y)
    else {
      var T = vu(e, n, !0)
      x = gu(e, T)
    }
    var _ = n.getDerivedStateFromProps,
      N = typeof _ == 'function' || typeof u.getSnapshotBeforeUpdate == 'function'
    !N &&
      (typeof u.UNSAFE_componentWillReceiveProps == 'function' ||
        typeof u.componentWillReceiveProps == 'function') &&
      (d !== i || v !== x) &&
      qE(e, u, i, x),
      jE()
    var $ = e.memoizedState,
      q = (u.state = $)
    if ((hh(e, i, u, s), (q = e.memoizedState), d === i && $ === q && !Qp() && !mh())) {
      if (typeof u.componentDidMount == 'function') {
        var K = Tt
        ;(K |= Qs), (e.mode & Ti) !== Ie && (K |= oo), (e.flags |= K)
      }
      return !1
    }
    typeof _ == 'function' && (qy(e, n, _, i), (q = e.memoizedState))
    var re = mh() || WE(e, n, d, i, $, q, x)
    if (re) {
      if (
        (!N &&
          (typeof u.UNSAFE_componentWillMount == 'function' ||
            typeof u.componentWillMount == 'function') &&
          (typeof u.componentWillMount == 'function' && u.componentWillMount(),
          typeof u.UNSAFE_componentWillMount == 'function' && u.UNSAFE_componentWillMount()),
        typeof u.componentDidMount == 'function')
      ) {
        var De = Tt
        ;(De |= Qs), (e.mode & Ti) !== Ie && (De |= oo), (e.flags |= De)
      }
    } else {
      if (typeof u.componentDidMount == 'function') {
        var je = Tt
        ;(je |= Qs), (e.mode & Ti) !== Ie && (je |= oo), (e.flags |= je)
      }
      ;(e.memoizedProps = i), (e.memoizedState = q)
    }
    return (u.props = i), (u.state = q), (u.context = x), re
  }
  function H5(e, n, i, s, u) {
    var d = n.stateNode
    BE(e, n)
    var v = n.memoizedProps,
      y = n.type === n.elementType ? v : ai(n.type, v)
    d.props = y
    var x = n.pendingProps,
      T = d.context,
      _ = i.contextType,
      N = Ta
    if (typeof _ == 'object' && _ !== null) N = Wn(_)
    else {
      var $ = vu(n, i, !0)
      N = gu(n, $)
    }
    var q = i.getDerivedStateFromProps,
      K = typeof q == 'function' || typeof d.getSnapshotBeforeUpdate == 'function'
    !K &&
      (typeof d.UNSAFE_componentWillReceiveProps == 'function' ||
        typeof d.componentWillReceiveProps == 'function') &&
      (v !== x || T !== N) &&
      qE(n, d, s, N),
      jE()
    var re = n.memoizedState,
      De = (d.state = re)
    if ((hh(n, s, d, u), (De = n.memoizedState), v === x && re === De && !Qp() && !mh() && !Bt))
      return (
        typeof d.componentDidUpdate == 'function' &&
          (v !== e.memoizedProps || re !== e.memoizedState) &&
          (n.flags |= Tt),
        typeof d.getSnapshotBeforeUpdate == 'function' &&
          (v !== e.memoizedProps || re !== e.memoizedState) &&
          (n.flags |= Ks),
        !1
      )
    typeof q == 'function' && (qy(n, i, q, s), (De = n.memoizedState))
    var je = mh() || WE(n, i, y, s, re, De, N) || Bt
    return (
      je
        ? (!K &&
            (typeof d.UNSAFE_componentWillUpdate == 'function' ||
              typeof d.componentWillUpdate == 'function') &&
            (typeof d.componentWillUpdate == 'function' && d.componentWillUpdate(s, De, N),
            typeof d.UNSAFE_componentWillUpdate == 'function' &&
              d.UNSAFE_componentWillUpdate(s, De, N)),
          typeof d.componentDidUpdate == 'function' && (n.flags |= Tt),
          typeof d.getSnapshotBeforeUpdate == 'function' && (n.flags |= Ks))
        : (typeof d.componentDidUpdate == 'function' &&
            (v !== e.memoizedProps || re !== e.memoizedState) &&
            (n.flags |= Tt),
          typeof d.getSnapshotBeforeUpdate == 'function' &&
            (v !== e.memoizedProps || re !== e.memoizedState) &&
            (n.flags |= Ks),
          (n.memoizedProps = s),
          (n.memoizedState = De)),
      (d.props = s),
      (d.state = De),
      (d.context = N),
      je
    )
  }
  var Qy,
    Zy,
    Jy,
    eb,
    tb,
    KE = function (e, n) {}
  ;(Qy = !1),
    (Zy = !1),
    (Jy = {}),
    (eb = {}),
    (tb = {}),
    (KE = function (e, n) {
      if (
        !(e === null || typeof e != 'object') &&
        !(!e._store || e._store.validated || e.key != null)
      ) {
        if (typeof e._store != 'object')
          throw new Error(
            'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'
          )
        e._store.validated = !0
        var i = nt(n) || 'Component'
        eb[i] ||
          ((eb[i] = !0),
          c(
            'Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'
          ))
      }
    })
  function bf(e, n, i) {
    var s = i.ref
    if (s !== null && typeof s != 'function' && typeof s != 'object') {
      if ((e.mode & Hn || Ke) && !(i._owner && i._self && i._owner.stateNode !== i._self)) {
        var u = nt(e) || 'Component'
        Jy[u] ||
          (c(
            'A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
            s
          ),
          (Jy[u] = !0))
      }
      if (i._owner) {
        var d = i._owner,
          v
        if (d) {
          var y = d
          if (y.tag !== m)
            throw new Error(
              'Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref'
            )
          v = y.stateNode
        }
        if (!v)
          throw new Error(
            'Missing owner for string ref ' +
              s +
              '. This error is likely caused by a bug in React. Please file an issue.'
          )
        var x = v
        en(s, 'ref')
        var T = '' + s
        if (n !== null && n.ref !== null && typeof n.ref == 'function' && n.ref._stringRef === T)
          return n.ref
        var _ = function (N) {
          var $ = x.refs
          $ === VE && ($ = x.refs = {}), N === null ? delete $[T] : ($[T] = N)
        }
        return (_._stringRef = T), _
      } else {
        if (typeof s != 'string')
          throw new Error(
            'Expected ref to be a function, a string, an object returned by React.createRef(), or null.'
          )
        if (!i._owner)
          throw new Error(
            'Element ref was specified as a string (' +
              s +
              `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`
          )
      }
    }
    return s
  }
  function gh(e, n) {
    var i = Object.prototype.toString.call(n)
    throw new Error(
      'Objects are not valid as a React child (found: ' +
        (i === '[object Object]' ? 'object with keys {' + Object.keys(n).join(', ') + '}' : i) +
        '). If you meant to render a collection of children, use an array instead.'
    )
  }
  function yh(e) {
    {
      var n = nt(e) || 'Component'
      if (tb[n]) return
      ;(tb[n] = !0),
        c(
          'Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.'
        )
    }
  }
  function XE(e) {
    var n = e._payload,
      i = e._init
    return i(n)
  }
  function QE(e) {
    function n(H, ae) {
      if (e) {
        var W = H.deletions
        W === null ? ((H.deletions = [ae]), (H.flags |= qs)) : W.push(ae)
      }
    }
    function i(H, ae) {
      if (!e) return null
      for (var W = ae; W !== null; ) n(H, W), (W = W.sibling)
      return null
    }
    function s(H, ae) {
      for (var W = new Map(), fe = ae; fe !== null; )
        fe.key !== null ? W.set(fe.key, fe) : W.set(fe.index, fe), (fe = fe.sibling)
      return W
    }
    function u(H, ae) {
      var W = xl(H, ae)
      return (W.index = 0), (W.sibling = null), W
    }
    function d(H, ae, W) {
      if (((H.index = W), !e)) return (H.flags |= NC), ae
      var fe = H.alternate
      if (fe !== null) {
        var Ae = fe.index
        return Ae < ae ? ((H.flags |= In), ae) : Ae
      } else return (H.flags |= In), ae
    }
    function v(H) {
      return e && H.alternate === null && (H.flags |= In), H
    }
    function y(H, ae, W, fe) {
      if (ae === null || ae.tag !== k) {
        var Ae = k0(W, H.mode, fe)
        return (Ae.return = H), Ae
      } else {
        var we = u(ae, W)
        return (we.return = H), we
      }
    }
    function x(H, ae, W, fe) {
      var Ae = W.type
      if (Ae === ea) return _(H, ae, W.props.children, fe, W.key)
      if (
        ae !== null &&
        (ae.elementType === Ae ||
          U1(ae, W) ||
          (typeof Ae == 'object' && Ae !== null && Ae.$$typeof === Be && XE(Ae) === ae.type))
      ) {
        var we = u(ae, W.props)
        return (
          (we.ref = bf(H, ae, W)),
          (we.return = H),
          (we._debugSource = W._source),
          (we._debugOwner = W._owner),
          we
        )
      }
      var Ye = _0(W, H.mode, fe)
      return (Ye.ref = bf(H, ae, W)), (Ye.return = H), Ye
    }
    function T(H, ae, W, fe) {
      if (
        ae === null ||
        ae.tag !== C ||
        ae.stateNode.containerInfo !== W.containerInfo ||
        ae.stateNode.implementation !== W.implementation
      ) {
        var Ae = D0(W, H.mode, fe)
        return (Ae.return = H), Ae
      } else {
        var we = u(ae, W.children || [])
        return (we.return = H), we
      }
    }
    function _(H, ae, W, fe, Ae) {
      if (ae === null || ae.tag !== D) {
        var we = ms(W, H.mode, fe, Ae)
        return (we.return = H), we
      } else {
        var Ye = u(ae, W)
        return (Ye.return = H), Ye
      }
    }
    function N(H, ae, W) {
      if ((typeof ae == 'string' && ae !== '') || typeof ae == 'number') {
        var fe = k0('' + ae, H.mode, W)
        return (fe.return = H), fe
      }
      if (typeof ae == 'object' && ae !== null) {
        switch (ae.$$typeof) {
          case cr: {
            var Ae = _0(ae, H.mode, W)
            return (Ae.ref = bf(H, null, ae)), (Ae.return = H), Ae
          }
          case jr: {
            var we = D0(ae, H.mode, W)
            return (we.return = H), we
          }
          case Be: {
            var Ye = ae._payload,
              tt = ae._init
            return N(H, tt(Ye), W)
          }
        }
        if (Pt(ae) || Ka(ae)) {
          var qt = ms(ae, H.mode, W, null)
          return (qt.return = H), qt
        }
        gh(H, ae)
      }
      return typeof ae == 'function' && yh(H), null
    }
    function $(H, ae, W, fe) {
      var Ae = ae !== null ? ae.key : null
      if ((typeof W == 'string' && W !== '') || typeof W == 'number')
        return Ae !== null ? null : y(H, ae, '' + W, fe)
      if (typeof W == 'object' && W !== null) {
        switch (W.$$typeof) {
          case cr:
            return W.key === Ae ? x(H, ae, W, fe) : null
          case jr:
            return W.key === Ae ? T(H, ae, W, fe) : null
          case Be: {
            var we = W._payload,
              Ye = W._init
            return $(H, ae, Ye(we), fe)
          }
        }
        if (Pt(W) || Ka(W)) return Ae !== null ? null : _(H, ae, W, fe, null)
        gh(H, W)
      }
      return typeof W == 'function' && yh(H), null
    }
    function q(H, ae, W, fe, Ae) {
      if ((typeof fe == 'string' && fe !== '') || typeof fe == 'number') {
        var we = H.get(W) || null
        return y(ae, we, '' + fe, Ae)
      }
      if (typeof fe == 'object' && fe !== null) {
        switch (fe.$$typeof) {
          case cr: {
            var Ye = H.get(fe.key === null ? W : fe.key) || null
            return x(ae, Ye, fe, Ae)
          }
          case jr: {
            var tt = H.get(fe.key === null ? W : fe.key) || null
            return T(ae, tt, fe, Ae)
          }
          case Be:
            var qt = fe._payload,
              Dt = fe._init
            return q(H, ae, W, Dt(qt), Ae)
        }
        if (Pt(fe) || Ka(fe)) {
          var Bn = H.get(W) || null
          return _(ae, Bn, fe, Ae, null)
        }
        gh(ae, fe)
      }
      return typeof fe == 'function' && yh(ae), null
    }
    function K(H, ae, W) {
      {
        if (typeof H != 'object' || H === null) return ae
        switch (H.$$typeof) {
          case cr:
          case jr:
            KE(H, W)
            var fe = H.key
            if (typeof fe != 'string') break
            if (ae === null) {
              ;(ae = new Set()), ae.add(fe)
              break
            }
            if (!ae.has(fe)) {
              ae.add(fe)
              break
            }
            c(
              'Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.',
              fe
            )
            break
          case Be:
            var Ae = H._payload,
              we = H._init
            K(we(Ae), ae, W)
            break
        }
      }
      return ae
    }
    function re(H, ae, W, fe) {
      for (var Ae = null, we = 0; we < W.length; we++) {
        var Ye = W[we]
        Ae = K(Ye, Ae, H)
      }
      for (
        var tt = null, qt = null, Dt = ae, Bn = 0, At = 0, zn = null;
        Dt !== null && At < W.length;
        At++
      ) {
        Dt.index > At ? ((zn = Dt), (Dt = null)) : (zn = Dt.sibling)
        var Lr = $(H, Dt, W[At], fe)
        if (Lr === null) {
          Dt === null && (Dt = zn)
          break
        }
        e && Dt && Lr.alternate === null && n(H, Dt),
          (Bn = d(Lr, Bn, At)),
          qt === null ? (tt = Lr) : (qt.sibling = Lr),
          (qt = Lr),
          (Dt = zn)
      }
      if (At === W.length) {
        if ((i(H, Dt), yr())) {
          var Tr = At
          ll(H, Tr)
        }
        return tt
      }
      if (Dt === null) {
        for (; At < W.length; At++) {
          var _a = N(H, W[At], fe)
          _a !== null &&
            ((Bn = d(_a, Bn, At)), qt === null ? (tt = _a) : (qt.sibling = _a), (qt = _a))
        }
        if (yr()) {
          var Yr = At
          ll(H, Yr)
        }
        return tt
      }
      for (var Gr = s(H, Dt); At < W.length; At++) {
        var zr = q(Gr, H, At, W[At], fe)
        zr !== null &&
          (e && zr.alternate !== null && Gr.delete(zr.key === null ? At : zr.key),
          (Bn = d(zr, Bn, At)),
          qt === null ? (tt = zr) : (qt.sibling = zr),
          (qt = zr))
      }
      if (
        (e &&
          Gr.forEach(function (Bu) {
            return n(H, Bu)
          }),
        yr())
      ) {
        var wo = At
        ll(H, wo)
      }
      return tt
    }
    function De(H, ae, W, fe) {
      var Ae = Ka(W)
      if (typeof Ae != 'function')
        throw new Error(
          'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'
        )
      {
        typeof Symbol == 'function' &&
          W[Symbol.toStringTag] === 'Generator' &&
          (Zy ||
            c(
              'Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.'
            ),
          (Zy = !0)),
          W.entries === Ae &&
            (Qy ||
              c(
                'Using Maps as children is not supported. Use an array of keyed ReactElements instead.'
              ),
            (Qy = !0))
        var we = Ae.call(W)
        if (we)
          for (var Ye = null, tt = we.next(); !tt.done; tt = we.next()) {
            var qt = tt.value
            Ye = K(qt, Ye, H)
          }
      }
      var Dt = Ae.call(W)
      if (Dt == null) throw new Error('An iterable object provided no iterator.')
      for (
        var Bn = null, At = null, zn = ae, Lr = 0, Tr = 0, _a = null, Yr = Dt.next();
        zn !== null && !Yr.done;
        Tr++, Yr = Dt.next()
      ) {
        zn.index > Tr ? ((_a = zn), (zn = null)) : (_a = zn.sibling)
        var Gr = $(H, zn, Yr.value, fe)
        if (Gr === null) {
          zn === null && (zn = _a)
          break
        }
        e && zn && Gr.alternate === null && n(H, zn),
          (Lr = d(Gr, Lr, Tr)),
          At === null ? (Bn = Gr) : (At.sibling = Gr),
          (At = Gr),
          (zn = _a)
      }
      if (Yr.done) {
        if ((i(H, zn), yr())) {
          var zr = Tr
          ll(H, zr)
        }
        return Bn
      }
      if (zn === null) {
        for (; !Yr.done; Tr++, Yr = Dt.next()) {
          var wo = N(H, Yr.value, fe)
          wo !== null &&
            ((Lr = d(wo, Lr, Tr)), At === null ? (Bn = wo) : (At.sibling = wo), (At = wo))
        }
        if (yr()) {
          var Bu = Tr
          ll(H, Bu)
        }
        return Bn
      }
      for (var Kf = s(H, zn); !Yr.done; Tr++, Yr = Dt.next()) {
        var $i = q(Kf, H, Tr, Yr.value, fe)
        $i !== null &&
          (e && $i.alternate !== null && Kf.delete($i.key === null ? Tr : $i.key),
          (Lr = d($i, Lr, Tr)),
          At === null ? (Bn = $i) : (At.sibling = $i),
          (At = $i))
      }
      if (
        (e &&
          Kf.forEach(function (aj) {
            return n(H, aj)
          }),
        yr())
      ) {
        var rj = Tr
        ll(H, rj)
      }
      return Bn
    }
    function je(H, ae, W, fe) {
      if (ae !== null && ae.tag === k) {
        i(H, ae.sibling)
        var Ae = u(ae, W)
        return (Ae.return = H), Ae
      }
      i(H, ae)
      var we = k0(W, H.mode, fe)
      return (we.return = H), we
    }
    function Fe(H, ae, W, fe) {
      for (var Ae = W.key, we = ae; we !== null; ) {
        if (we.key === Ae) {
          var Ye = W.type
          if (Ye === ea) {
            if (we.tag === D) {
              i(H, we.sibling)
              var tt = u(we, W.props.children)
              return (tt.return = H), (tt._debugSource = W._source), (tt._debugOwner = W._owner), tt
            }
          } else if (
            we.elementType === Ye ||
            U1(we, W) ||
            (typeof Ye == 'object' && Ye !== null && Ye.$$typeof === Be && XE(Ye) === we.type)
          ) {
            i(H, we.sibling)
            var qt = u(we, W.props)
            return (
              (qt.ref = bf(H, we, W)),
              (qt.return = H),
              (qt._debugSource = W._source),
              (qt._debugOwner = W._owner),
              qt
            )
          }
          i(H, we)
          break
        } else n(H, we)
        we = we.sibling
      }
      if (W.type === ea) {
        var Dt = ms(W.props.children, H.mode, fe, W.key)
        return (Dt.return = H), Dt
      } else {
        var Bn = _0(W, H.mode, fe)
        return (Bn.ref = bf(H, ae, W)), (Bn.return = H), Bn
      }
    }
    function St(H, ae, W, fe) {
      for (var Ae = W.key, we = ae; we !== null; ) {
        if (we.key === Ae)
          if (
            we.tag === C &&
            we.stateNode.containerInfo === W.containerInfo &&
            we.stateNode.implementation === W.implementation
          ) {
            i(H, we.sibling)
            var Ye = u(we, W.children || [])
            return (Ye.return = H), Ye
          } else {
            i(H, we)
            break
          }
        else n(H, we)
        we = we.sibling
      }
      var tt = D0(W, H.mode, fe)
      return (tt.return = H), tt
    }
    function ht(H, ae, W, fe) {
      var Ae = typeof W == 'object' && W !== null && W.type === ea && W.key === null
      if ((Ae && (W = W.props.children), typeof W == 'object' && W !== null)) {
        switch (W.$$typeof) {
          case cr:
            return v(Fe(H, ae, W, fe))
          case jr:
            return v(St(H, ae, W, fe))
          case Be:
            var we = W._payload,
              Ye = W._init
            return ht(H, ae, Ye(we), fe)
        }
        if (Pt(W)) return re(H, ae, W, fe)
        if (Ka(W)) return De(H, ae, W, fe)
        gh(H, W)
      }
      return (typeof W == 'string' && W !== '') || typeof W == 'number'
        ? v(je(H, ae, '' + W, fe))
        : (typeof W == 'function' && yh(H), i(H, ae))
    }
    return ht
  }
  var wu = QE(!0),
    ZE = QE(!1)
  function W5(e, n) {
    if (e !== null && n.child !== e.child) throw new Error('Resuming work not yet implemented.')
    if (n.child !== null) {
      var i = n.child,
        s = xl(i, i.pendingProps)
      for (n.child = s, s.return = n; i.sibling !== null; )
        (i = i.sibling), (s = s.sibling = xl(i, i.pendingProps)), (s.return = n)
      s.sibling = null
    }
  }
  function Y5(e, n) {
    for (var i = e.child; i !== null; ) xB(i, n), (i = i.sibling)
  }
  var Sf = {},
    os = ts(Sf),
    xf = ts(Sf),
    bh = ts(Sf)
  function Sh(e) {
    if (e === Sf)
      throw new Error(
        'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'
      )
    return e
  }
  function JE() {
    var e = Sh(bh.current)
    return e
  }
  function nb(e, n) {
    Mr(bh, n, e), Mr(xf, e, e), Mr(os, Sf, e)
    var i = o2(n)
    Or(os, e), Mr(os, i, e)
  }
  function Eu(e) {
    Or(os, e), Or(xf, e), Or(bh, e)
  }
  function rb() {
    var e = Sh(os.current)
    return e
  }
  function eT(e) {
    Sh(bh.current)
    var n = Sh(os.current),
      i = s2(n, e.type)
    n !== i && (Mr(xf, e, e), Mr(os, i, e))
  }
  function ab(e) {
    xf.current === e && (Or(os, e), Or(xf, e))
  }
  var G5 = 0,
    tT = 1,
    nT = 1,
    Cf = 2,
    ii = ts(G5)
  function ib(e, n) {
    return (e & n) !== 0
  }
  function Tu(e) {
    return e & tT
  }
  function ob(e, n) {
    return (e & tT) | n
  }
  function q5(e, n) {
    return e | n
  }
  function ss(e, n) {
    Mr(ii, n, e)
  }
  function Ru(e) {
    Or(ii, e)
  }
  function K5(e, n) {
    var i = e.memoizedState
    return i !== null ? i.dehydrated !== null : (e.memoizedProps, !0)
  }
  function xh(e) {
    for (var n = e; n !== null; ) {
      if (n.tag === j) {
        var i = n.memoizedState
        if (i !== null) {
          var s = i.dehydrated
          if (s === null || dE(s) || dy(s)) return n
        }
      } else if (n.tag === pe && n.memoizedProps.revealOrder !== void 0) {
        var u = (n.flags & Lt) !== Ve
        if (u) return n
      } else if (n.child !== null) {
        ;(n.child.return = n), (n = n.child)
        continue
      }
      if (n === e) return null
      for (; n.sibling === null; ) {
        if (n.return === null || n.return === e) return null
        n = n.return
      }
      ;(n.sibling.return = n.return), (n = n.sibling)
    }
    return null
  }
  var oa = 0,
    Jn = 1,
    Di = 2,
    er = 4,
    br = 8,
    sb = []
  function lb() {
    for (var e = 0; e < sb.length; e++) {
      var n = sb[e]
      n._workInProgressVersionPrimary = null
    }
    sb.length = 0
  }
  function X5(e, n) {
    var i = n._getVersion,
      s = i(n._source)
    e.mutableSourceEagerHydrationData == null
      ? (e.mutableSourceEagerHydrationData = [n, s])
      : e.mutableSourceEagerHydrationData.push(n, s)
  }
  var Re = a.ReactCurrentDispatcher,
    wf = a.ReactCurrentBatchConfig,
    ub,
    _u
  ub = new Set()
  var hl = ue,
    Gt = null,
    tr = null,
    nr = null,
    Ch = !1,
    Ef = !1,
    Tf = 0,
    Q5 = 0,
    Z5 = 25,
    oe = null,
    Ba = null,
    ls = -1,
    cb = !1
  function Ft() {
    {
      var e = oe
      Ba === null ? (Ba = [e]) : Ba.push(e)
    }
  }
  function ye() {
    {
      var e = oe
      Ba !== null && (ls++, Ba[ls] !== e && J5(e))
    }
  }
  function ku(e) {
    e != null &&
      !Pt(e) &&
      c(
        '%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.',
        oe,
        typeof e
      )
  }
  function J5(e) {
    {
      var n = nt(Gt)
      if (!ub.has(n) && (ub.add(n), Ba !== null)) {
        for (var i = '', s = 30, u = 0; u <= ls; u++) {
          for (var d = Ba[u], v = u === ls ? e : d, y = u + 1 + '. ' + d; y.length < s; ) y += ' '
          ;(y +=
            v +
            `
`),
            (i += y)
        }
        c(
          `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
          n,
          i
        )
      }
    }
  }
  function Pr() {
    throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`)
  }
  function fb(e, n) {
    if (cb) return !1
    if (n === null)
      return (
        c(
          '%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.',
          oe
        ),
        !1
      )
    e.length !== n.length &&
      c(
        `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
        oe,
        '[' + n.join(', ') + ']',
        '[' + e.join(', ') + ']'
      )
    for (var i = 0; i < n.length && i < e.length; i++) if (!Ea(e[i], n[i])) return !1
    return !0
  }
  function Du(e, n, i, s, u, d) {
    ;(hl = d),
      (Gt = n),
      (Ba = e !== null ? e._debugHookTypes : null),
      (ls = -1),
      (cb = e !== null && e.type !== n.type),
      (n.memoizedState = null),
      (n.updateQueue = null),
      (n.lanes = ue),
      e !== null && e.memoizedState !== null
        ? (Re.current = ET)
        : Ba !== null
        ? (Re.current = wT)
        : (Re.current = CT)
    var v = i(s, u)
    if (Ef) {
      var y = 0
      do {
        if (((Ef = !1), (Tf = 0), y >= Z5))
          throw new Error(
            'Too many re-renders. React limits the number of renders to prevent an infinite loop.'
          )
        ;(y += 1),
          (cb = !1),
          (tr = null),
          (nr = null),
          (n.updateQueue = null),
          (ls = -1),
          (Re.current = TT),
          (v = i(s, u))
      } while (Ef)
    }
    ;(Re.current = zh), (n._debugHookTypes = Ba)
    var x = tr !== null && tr.next !== null
    if (
      ((hl = ue),
      (Gt = null),
      (tr = null),
      (nr = null),
      (oe = null),
      (Ba = null),
      (ls = -1),
      e !== null &&
        (e.flags & so) !== (n.flags & so) &&
        (e.mode & yt) !== Ie &&
        c('Internal React error: Expected static flag was missing. Please notify the React team.'),
      (Ch = !1),
      x)
    )
      throw new Error(
        'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.'
      )
    return v
  }
  function Au() {
    var e = Tf !== 0
    return (Tf = 0), e
  }
  function rT(e, n, i) {
    ;(n.updateQueue = e.updateQueue),
      (n.mode & Ti) !== Ie ? (n.flags &= ~(mp | oo | Za | Tt)) : (n.flags &= ~(Za | Tt)),
      (e.lanes = Cp(e.lanes, i))
  }
  function aT() {
    if (((Re.current = zh), Ch)) {
      for (var e = Gt.memoizedState; e !== null; ) {
        var n = e.queue
        n !== null && (n.pending = null), (e = e.next)
      }
      Ch = !1
    }
    ;(hl = ue),
      (Gt = null),
      (tr = null),
      (nr = null),
      (Ba = null),
      (ls = -1),
      (oe = null),
      (gT = !1),
      (Ef = !1),
      (Tf = 0)
  }
  function Ai() {
    var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
    return nr === null ? (Gt.memoizedState = nr = e) : (nr = nr.next = e), nr
  }
  function ja() {
    var e
    if (tr === null) {
      var n = Gt.alternate
      n !== null ? (e = n.memoizedState) : (e = null)
    } else e = tr.next
    var i
    if ((nr === null ? (i = Gt.memoizedState) : (i = nr.next), i !== null))
      (nr = i), (i = nr.next), (tr = e)
    else {
      if (e === null) throw new Error('Rendered more hooks than during the previous render.')
      tr = e
      var s = {
        memoizedState: tr.memoizedState,
        baseState: tr.baseState,
        baseQueue: tr.baseQueue,
        queue: tr.queue,
        next: null,
      }
      nr === null ? (Gt.memoizedState = nr = s) : (nr = nr.next = s)
    }
    return nr
  }
  function iT() {
    return { lastEffect: null, stores: null }
  }
  function db(e, n) {
    return typeof n == 'function' ? n(e) : n
  }
  function pb(e, n, i) {
    var s = Ai(),
      u
    i !== void 0 ? (u = i(n)) : (u = n), (s.memoizedState = s.baseState = u)
    var d = {
      pending: null,
      interleaved: null,
      lanes: ue,
      dispatch: null,
      lastRenderedReducer: e,
      lastRenderedState: u,
    }
    s.queue = d
    var v = (d.dispatch = rF.bind(null, Gt, d))
    return [s.memoizedState, v]
  }
  function hb(e, n, i) {
    var s = ja(),
      u = s.queue
    if (u === null)
      throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.')
    u.lastRenderedReducer = e
    var d = tr,
      v = d.baseQueue,
      y = u.pending
    if (y !== null) {
      if (v !== null) {
        var x = v.next,
          T = y.next
        ;(v.next = T), (y.next = x)
      }
      d.baseQueue !== v &&
        c('Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.'),
        (d.baseQueue = v = y),
        (u.pending = null)
    }
    if (v !== null) {
      var _ = v.next,
        N = d.baseState,
        $ = null,
        q = null,
        K = null,
        re = _
      do {
        var De = re.lane
        if (ou(hl, De)) {
          if (K !== null) {
            var Fe = {
              lane: hr,
              action: re.action,
              hasEagerState: re.hasEagerState,
              eagerState: re.eagerState,
              next: null,
            }
            K = K.next = Fe
          }
          if (re.hasEagerState) N = re.eagerState
          else {
            var St = re.action
            N = e(N, St)
          }
        } else {
          var je = {
            lane: De,
            action: re.action,
            hasEagerState: re.hasEagerState,
            eagerState: re.eagerState,
            next: null,
          }
          K === null ? ((q = K = je), ($ = N)) : (K = K.next = je),
            (Gt.lanes = lt(Gt.lanes, De)),
            Hf(De)
        }
        re = re.next
      } while (re !== null && re !== _)
      K === null ? ($ = N) : (K.next = q),
        Ea(N, s.memoizedState) || Mf(),
        (s.memoizedState = N),
        (s.baseState = $),
        (s.baseQueue = K),
        (u.lastRenderedState = N)
    }
    var ht = u.interleaved
    if (ht !== null) {
      var H = ht
      do {
        var ae = H.lane
        ;(Gt.lanes = lt(Gt.lanes, ae)), Hf(ae), (H = H.next)
      } while (H !== ht)
    } else v === null && (u.lanes = ue)
    var W = u.dispatch
    return [s.memoizedState, W]
  }
  function mb(e, n, i) {
    var s = ja(),
      u = s.queue
    if (u === null)
      throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.')
    u.lastRenderedReducer = e
    var d = u.dispatch,
      v = u.pending,
      y = s.memoizedState
    if (v !== null) {
      u.pending = null
      var x = v.next,
        T = x
      do {
        var _ = T.action
        ;(y = e(y, _)), (T = T.next)
      } while (T !== x)
      Ea(y, s.memoizedState) || Mf(),
        (s.memoizedState = y),
        s.baseQueue === null && (s.baseState = y),
        (u.lastRenderedState = y)
    }
    return [y, d]
  }
  function Lee(e, n, i) {}
  function zee(e, n, i) {}
  function vb(e, n, i) {
    var s = Gt,
      u = Ai(),
      d,
      v = yr()
    if (v) {
      if (i === void 0)
        throw new Error(
          'Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.'
        )
      ;(d = i()),
        _u ||
          (d !== i() &&
            (c('The result of getServerSnapshot should be cached to avoid an infinite loop'),
            (_u = !0)))
    } else {
      if (((d = n()), !_u)) {
        var y = n()
        Ea(d, y) ||
          (c('The result of getSnapshot should be cached to avoid an infinite loop'), (_u = !0))
      }
      var x = Jh()
      if (x === null)
        throw new Error(
          'Expected a work-in-progress root. This is a bug in React. Please file an issue.'
        )
      xp(x, hl) || oT(s, n, d)
    }
    u.memoizedState = d
    var T = { value: d, getSnapshot: n }
    return (
      (u.queue = T),
      _h(lT.bind(null, s, T, e), [e]),
      (s.flags |= Za),
      Rf(Jn | br, sT.bind(null, s, T, d, n), void 0, null),
      d
    )
  }
  function wh(e, n, i) {
    var s = Gt,
      u = ja(),
      d = n()
    if (!_u) {
      var v = n()
      Ea(d, v) ||
        (c('The result of getSnapshot should be cached to avoid an infinite loop'), (_u = !0))
    }
    var y = u.memoizedState,
      x = !Ea(y, d)
    x && ((u.memoizedState = d), Mf())
    var T = u.queue
    if (
      (kf(lT.bind(null, s, T, e), [e]),
      T.getSnapshot !== n || x || (nr !== null && nr.memoizedState.tag & Jn))
    ) {
      ;(s.flags |= Za), Rf(Jn | br, sT.bind(null, s, T, d, n), void 0, null)
      var _ = Jh()
      if (_ === null)
        throw new Error(
          'Expected a work-in-progress root. This is a bug in React. Please file an issue.'
        )
      xp(_, hl) || oT(s, n, d)
    }
    return d
  }
  function oT(e, n, i) {
    e.flags |= hp
    var s = { getSnapshot: n, value: i },
      u = Gt.updateQueue
    if (u === null) (u = iT()), (Gt.updateQueue = u), (u.stores = [s])
    else {
      var d = u.stores
      d === null ? (u.stores = [s]) : d.push(s)
    }
  }
  function sT(e, n, i, s) {
    ;(n.value = i), (n.getSnapshot = s), uT(n) && cT(e)
  }
  function lT(e, n, i) {
    var s = function () {
      uT(n) && cT(e)
    }
    return i(s)
  }
  function uT(e) {
    var n = e.getSnapshot,
      i = e.value
    try {
      var s = n()
      return !Ea(i, s)
    } catch {
      return !0
    }
  }
  function cT(e) {
    var n = ia(e, Ze)
    n !== null && or(n, e, Ze, vn)
  }
  function Eh(e) {
    var n = Ai()
    typeof e == 'function' && (e = e()), (n.memoizedState = n.baseState = e)
    var i = {
      pending: null,
      interleaved: null,
      lanes: ue,
      dispatch: null,
      lastRenderedReducer: db,
      lastRenderedState: e,
    }
    n.queue = i
    var s = (i.dispatch = aF.bind(null, Gt, i))
    return [n.memoizedState, s]
  }
  function gb(e) {
    return hb(db)
  }
  function yb(e) {
    return mb(db)
  }
  function Rf(e, n, i, s) {
    var u = { tag: e, create: n, destroy: i, deps: s, next: null },
      d = Gt.updateQueue
    if (d === null) (d = iT()), (Gt.updateQueue = d), (d.lastEffect = u.next = u)
    else {
      var v = d.lastEffect
      if (v === null) d.lastEffect = u.next = u
      else {
        var y = v.next
        ;(v.next = u), (u.next = y), (d.lastEffect = u)
      }
    }
    return u
  }
  function bb(e) {
    var n = Ai()
    {
      var i = { current: e }
      return (n.memoizedState = i), i
    }
  }
  function Th(e) {
    var n = ja()
    return n.memoizedState
  }
  function _f(e, n, i, s) {
    var u = Ai(),
      d = s === void 0 ? null : s
    ;(Gt.flags |= e), (u.memoizedState = Rf(Jn | n, i, void 0, d))
  }
  function Rh(e, n, i, s) {
    var u = ja(),
      d = s === void 0 ? null : s,
      v = void 0
    if (tr !== null) {
      var y = tr.memoizedState
      if (((v = y.destroy), d !== null)) {
        var x = y.deps
        if (fb(d, x)) {
          u.memoizedState = Rf(n, i, v, d)
          return
        }
      }
    }
    ;(Gt.flags |= e), (u.memoizedState = Rf(Jn | n, i, v, d))
  }
  function _h(e, n) {
    return (Gt.mode & Ti) !== Ie ? _f(mp | Za | ag, br, e, n) : _f(Za | ag, br, e, n)
  }
  function kf(e, n) {
    return Rh(Za, br, e, n)
  }
  function Sb(e, n) {
    return _f(Tt, Di, e, n)
  }
  function kh(e, n) {
    return Rh(Tt, Di, e, n)
  }
  function xb(e, n) {
    var i = Tt
    return (i |= Qs), (Gt.mode & Ti) !== Ie && (i |= oo), _f(i, er, e, n)
  }
  function Dh(e, n) {
    return Rh(Tt, er, e, n)
  }
  function fT(e, n) {
    if (typeof n == 'function') {
      var i = n,
        s = e()
      return (
        i(s),
        function () {
          i(null)
        }
      )
    } else if (n != null) {
      var u = n
      u.hasOwnProperty('current') ||
        c(
          'Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.',
          'an object with keys {' + Object.keys(u).join(', ') + '}'
        )
      var d = e()
      return (
        (u.current = d),
        function () {
          u.current = null
        }
      )
    }
  }
  function Cb(e, n, i) {
    typeof n != 'function' &&
      c(
        'Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.',
        n !== null ? typeof n : 'null'
      )
    var s = i != null ? i.concat([e]) : null,
      u = Tt
    return (u |= Qs), (Gt.mode & Ti) !== Ie && (u |= oo), _f(u, er, fT.bind(null, n, e), s)
  }
  function Ah(e, n, i) {
    typeof n != 'function' &&
      c(
        'Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.',
        n !== null ? typeof n : 'null'
      )
    var s = i != null ? i.concat([e]) : null
    return Rh(Tt, er, fT.bind(null, n, e), s)
  }
  function eF(e, n) {}
  var Oh = eF
  function wb(e, n) {
    var i = Ai(),
      s = n === void 0 ? null : n
    return (i.memoizedState = [e, s]), e
  }
  function Mh(e, n) {
    var i = ja(),
      s = n === void 0 ? null : n,
      u = i.memoizedState
    if (u !== null && s !== null) {
      var d = u[1]
      if (fb(s, d)) return u[0]
    }
    return (i.memoizedState = [e, s]), e
  }
  function Eb(e, n) {
    var i = Ai(),
      s = n === void 0 ? null : n,
      u = e()
    return (i.memoizedState = [u, s]), u
  }
  function Ph(e, n) {
    var i = ja(),
      s = n === void 0 ? null : n,
      u = i.memoizedState
    if (u !== null && s !== null) {
      var d = u[1]
      if (fb(s, d)) return u[0]
    }
    var v = e()
    return (i.memoizedState = [v, s]), v
  }
  function Tb(e) {
    var n = Ai()
    return (n.memoizedState = e), e
  }
  function dT(e) {
    var n = ja(),
      i = tr,
      s = i.memoizedState
    return hT(n, s, e)
  }
  function pT(e) {
    var n = ja()
    if (tr === null) return (n.memoizedState = e), e
    var i = tr.memoizedState
    return hT(n, i, e)
  }
  function hT(e, n, i) {
    var s = !$L(hl)
    if (s) {
      if (!Ea(i, n)) {
        var u = rw()
        ;(Gt.lanes = lt(Gt.lanes, u)), Hf(u), (e.baseState = !0)
      }
      return n
    } else return e.baseState && ((e.baseState = !1), Mf()), (e.memoizedState = i), i
  }
  function tF(e, n, i) {
    var s = ei()
    mr(WL(s, uo)), e(!0)
    var u = wf.transition
    wf.transition = {}
    var d = wf.transition
    wf.transition._updatedFibers = new Set()
    try {
      e(!1), n()
    } finally {
      if ((mr(s), (wf.transition = u), u === null && d._updatedFibers)) {
        var v = d._updatedFibers.size
        v > 10 &&
          f(
            'Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.'
          ),
          d._updatedFibers.clear()
      }
    }
  }
  function Rb() {
    var e = Eh(!1),
      n = e[0],
      i = e[1],
      s = tF.bind(null, i),
      u = Ai()
    return (u.memoizedState = s), [n, s]
  }
  function mT() {
    var e = gb(),
      n = e[0],
      i = ja(),
      s = i.memoizedState
    return [n, s]
  }
  function vT() {
    var e = yb(),
      n = e[0],
      i = ja(),
      s = i.memoizedState
    return [n, s]
  }
  var gT = !1
  function nF() {
    return gT
  }
  function _b() {
    var e = Ai(),
      n = Jh(),
      i = n.identifierPrefix,
      s
    if (yr()) {
      var u = v5()
      s = ':' + i + 'R' + u
      var d = Tf++
      d > 0 && (s += 'H' + d.toString(32)), (s += ':')
    } else {
      var v = Q5++
      s = ':' + i + 'r' + v.toString(32) + ':'
    }
    return (e.memoizedState = s), s
  }
  function Lh() {
    var e = ja(),
      n = e.memoizedState
    return n
  }
  function rF(e, n, i) {
    typeof arguments[3] == 'function' &&
      c(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      )
    var s = ps(e),
      u = { lane: s, action: i, hasEagerState: !1, eagerState: null, next: null }
    if (yT(e)) bT(n, u)
    else {
      var d = $E(e, n, u, s)
      if (d !== null) {
        var v = Wr()
        or(d, e, s, v), ST(d, n, s)
      }
    }
    xT(e, s)
  }
  function aF(e, n, i) {
    typeof arguments[3] == 'function' &&
      c(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      )
    var s = ps(e),
      u = { lane: s, action: i, hasEagerState: !1, eagerState: null, next: null }
    if (yT(e)) bT(n, u)
    else {
      var d = e.alternate
      if (e.lanes === ue && (d === null || d.lanes === ue)) {
        var v = n.lastRenderedReducer
        if (v !== null) {
          var y
          ;(y = Re.current), (Re.current = oi)
          try {
            var x = n.lastRenderedState,
              T = v(x, i)
            if (((u.hasEagerState = !0), (u.eagerState = T), Ea(T, x))) {
              $5(e, n, u, s)
              return
            }
          } catch {
          } finally {
            Re.current = y
          }
        }
      }
      var _ = $E(e, n, u, s)
      if (_ !== null) {
        var N = Wr()
        or(_, e, s, N), ST(_, n, s)
      }
    }
    xT(e, s)
  }
  function yT(e) {
    var n = e.alternate
    return e === Gt || (n !== null && n === Gt)
  }
  function bT(e, n) {
    Ef = Ch = !0
    var i = e.pending
    i === null ? (n.next = n) : ((n.next = i.next), (i.next = n)), (e.pending = n)
  }
  function ST(e, n, i) {
    if (nw(i)) {
      var s = n.lanes
      s = aw(s, e.pendingLanes)
      var u = lt(s, i)
      ;(n.lanes = u), Lg(e, u)
    }
  }
  function xT(e, n, i) {
    ug(e, n)
  }
  var zh = {
      readContext: Wn,
      useCallback: Pr,
      useContext: Pr,
      useEffect: Pr,
      useImperativeHandle: Pr,
      useInsertionEffect: Pr,
      useLayoutEffect: Pr,
      useMemo: Pr,
      useReducer: Pr,
      useRef: Pr,
      useState: Pr,
      useDebugValue: Pr,
      useDeferredValue: Pr,
      useTransition: Pr,
      useMutableSource: Pr,
      useSyncExternalStore: Pr,
      useId: Pr,
      unstable_isNewReconciler: ut,
    },
    CT = null,
    wT = null,
    ET = null,
    TT = null,
    Oi = null,
    oi = null,
    $h = null
  {
    var kb = function () {
        c(
          'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
        )
      },
      Je = function () {
        c(
          'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks'
        )
      }
    ;(CT = {
      readContext: function (e) {
        return Wn(e)
      },
      useCallback: function (e, n) {
        return (oe = 'useCallback'), Ft(), ku(n), wb(e, n)
      },
      useContext: function (e) {
        return (oe = 'useContext'), Ft(), Wn(e)
      },
      useEffect: function (e, n) {
        return (oe = 'useEffect'), Ft(), ku(n), _h(e, n)
      },
      useImperativeHandle: function (e, n, i) {
        return (oe = 'useImperativeHandle'), Ft(), ku(i), Cb(e, n, i)
      },
      useInsertionEffect: function (e, n) {
        return (oe = 'useInsertionEffect'), Ft(), ku(n), Sb(e, n)
      },
      useLayoutEffect: function (e, n) {
        return (oe = 'useLayoutEffect'), Ft(), ku(n), xb(e, n)
      },
      useMemo: function (e, n) {
        ;(oe = 'useMemo'), Ft(), ku(n)
        var i = Re.current
        Re.current = Oi
        try {
          return Eb(e, n)
        } finally {
          Re.current = i
        }
      },
      useReducer: function (e, n, i) {
        ;(oe = 'useReducer'), Ft()
        var s = Re.current
        Re.current = Oi
        try {
          return pb(e, n, i)
        } finally {
          Re.current = s
        }
      },
      useRef: function (e) {
        return (oe = 'useRef'), Ft(), bb(e)
      },
      useState: function (e) {
        ;(oe = 'useState'), Ft()
        var n = Re.current
        Re.current = Oi
        try {
          return Eh(e)
        } finally {
          Re.current = n
        }
      },
      useDebugValue: function (e, n) {
        return (oe = 'useDebugValue'), Ft(), void 0
      },
      useDeferredValue: function (e) {
        return (oe = 'useDeferredValue'), Ft(), Tb(e)
      },
      useTransition: function () {
        return (oe = 'useTransition'), Ft(), Rb()
      },
      useMutableSource: function (e, n, i) {
        return (oe = 'useMutableSource'), Ft(), void 0
      },
      useSyncExternalStore: function (e, n, i) {
        return (oe = 'useSyncExternalStore'), Ft(), vb(e, n, i)
      },
      useId: function () {
        return (oe = 'useId'), Ft(), _b()
      },
      unstable_isNewReconciler: ut,
    }),
      (wT = {
        readContext: function (e) {
          return Wn(e)
        },
        useCallback: function (e, n) {
          return (oe = 'useCallback'), ye(), wb(e, n)
        },
        useContext: function (e) {
          return (oe = 'useContext'), ye(), Wn(e)
        },
        useEffect: function (e, n) {
          return (oe = 'useEffect'), ye(), _h(e, n)
        },
        useImperativeHandle: function (e, n, i) {
          return (oe = 'useImperativeHandle'), ye(), Cb(e, n, i)
        },
        useInsertionEffect: function (e, n) {
          return (oe = 'useInsertionEffect'), ye(), Sb(e, n)
        },
        useLayoutEffect: function (e, n) {
          return (oe = 'useLayoutEffect'), ye(), xb(e, n)
        },
        useMemo: function (e, n) {
          ;(oe = 'useMemo'), ye()
          var i = Re.current
          Re.current = Oi
          try {
            return Eb(e, n)
          } finally {
            Re.current = i
          }
        },
        useReducer: function (e, n, i) {
          ;(oe = 'useReducer'), ye()
          var s = Re.current
          Re.current = Oi
          try {
            return pb(e, n, i)
          } finally {
            Re.current = s
          }
        },
        useRef: function (e) {
          return (oe = 'useRef'), ye(), bb(e)
        },
        useState: function (e) {
          ;(oe = 'useState'), ye()
          var n = Re.current
          Re.current = Oi
          try {
            return Eh(e)
          } finally {
            Re.current = n
          }
        },
        useDebugValue: function (e, n) {
          return (oe = 'useDebugValue'), ye(), void 0
        },
        useDeferredValue: function (e) {
          return (oe = 'useDeferredValue'), ye(), Tb(e)
        },
        useTransition: function () {
          return (oe = 'useTransition'), ye(), Rb()
        },
        useMutableSource: function (e, n, i) {
          return (oe = 'useMutableSource'), ye(), void 0
        },
        useSyncExternalStore: function (e, n, i) {
          return (oe = 'useSyncExternalStore'), ye(), vb(e, n, i)
        },
        useId: function () {
          return (oe = 'useId'), ye(), _b()
        },
        unstable_isNewReconciler: ut,
      }),
      (ET = {
        readContext: function (e) {
          return Wn(e)
        },
        useCallback: function (e, n) {
          return (oe = 'useCallback'), ye(), Mh(e, n)
        },
        useContext: function (e) {
          return (oe = 'useContext'), ye(), Wn(e)
        },
        useEffect: function (e, n) {
          return (oe = 'useEffect'), ye(), kf(e, n)
        },
        useImperativeHandle: function (e, n, i) {
          return (oe = 'useImperativeHandle'), ye(), Ah(e, n, i)
        },
        useInsertionEffect: function (e, n) {
          return (oe = 'useInsertionEffect'), ye(), kh(e, n)
        },
        useLayoutEffect: function (e, n) {
          return (oe = 'useLayoutEffect'), ye(), Dh(e, n)
        },
        useMemo: function (e, n) {
          ;(oe = 'useMemo'), ye()
          var i = Re.current
          Re.current = oi
          try {
            return Ph(e, n)
          } finally {
            Re.current = i
          }
        },
        useReducer: function (e, n, i) {
          ;(oe = 'useReducer'), ye()
          var s = Re.current
          Re.current = oi
          try {
            return hb(e, n, i)
          } finally {
            Re.current = s
          }
        },
        useRef: function (e) {
          return (oe = 'useRef'), ye(), Th()
        },
        useState: function (e) {
          ;(oe = 'useState'), ye()
          var n = Re.current
          Re.current = oi
          try {
            return gb(e)
          } finally {
            Re.current = n
          }
        },
        useDebugValue: function (e, n) {
          return (oe = 'useDebugValue'), ye(), Oh()
        },
        useDeferredValue: function (e) {
          return (oe = 'useDeferredValue'), ye(), dT(e)
        },
        useTransition: function () {
          return (oe = 'useTransition'), ye(), mT()
        },
        useMutableSource: function (e, n, i) {
          return (oe = 'useMutableSource'), ye(), void 0
        },
        useSyncExternalStore: function (e, n, i) {
          return (oe = 'useSyncExternalStore'), ye(), wh(e, n)
        },
        useId: function () {
          return (oe = 'useId'), ye(), Lh()
        },
        unstable_isNewReconciler: ut,
      }),
      (TT = {
        readContext: function (e) {
          return Wn(e)
        },
        useCallback: function (e, n) {
          return (oe = 'useCallback'), ye(), Mh(e, n)
        },
        useContext: function (e) {
          return (oe = 'useContext'), ye(), Wn(e)
        },
        useEffect: function (e, n) {
          return (oe = 'useEffect'), ye(), kf(e, n)
        },
        useImperativeHandle: function (e, n, i) {
          return (oe = 'useImperativeHandle'), ye(), Ah(e, n, i)
        },
        useInsertionEffect: function (e, n) {
          return (oe = 'useInsertionEffect'), ye(), kh(e, n)
        },
        useLayoutEffect: function (e, n) {
          return (oe = 'useLayoutEffect'), ye(), Dh(e, n)
        },
        useMemo: function (e, n) {
          ;(oe = 'useMemo'), ye()
          var i = Re.current
          Re.current = $h
          try {
            return Ph(e, n)
          } finally {
            Re.current = i
          }
        },
        useReducer: function (e, n, i) {
          ;(oe = 'useReducer'), ye()
          var s = Re.current
          Re.current = $h
          try {
            return mb(e, n, i)
          } finally {
            Re.current = s
          }
        },
        useRef: function (e) {
          return (oe = 'useRef'), ye(), Th()
        },
        useState: function (e) {
          ;(oe = 'useState'), ye()
          var n = Re.current
          Re.current = $h
          try {
            return yb(e)
          } finally {
            Re.current = n
          }
        },
        useDebugValue: function (e, n) {
          return (oe = 'useDebugValue'), ye(), Oh()
        },
        useDeferredValue: function (e) {
          return (oe = 'useDeferredValue'), ye(), pT(e)
        },
        useTransition: function () {
          return (oe = 'useTransition'), ye(), vT()
        },
        useMutableSource: function (e, n, i) {
          return (oe = 'useMutableSource'), ye(), void 0
        },
        useSyncExternalStore: function (e, n, i) {
          return (oe = 'useSyncExternalStore'), ye(), wh(e, n)
        },
        useId: function () {
          return (oe = 'useId'), ye(), Lh()
        },
        unstable_isNewReconciler: ut,
      }),
      (Oi = {
        readContext: function (e) {
          return kb(), Wn(e)
        },
        useCallback: function (e, n) {
          return (oe = 'useCallback'), Je(), Ft(), wb(e, n)
        },
        useContext: function (e) {
          return (oe = 'useContext'), Je(), Ft(), Wn(e)
        },
        useEffect: function (e, n) {
          return (oe = 'useEffect'), Je(), Ft(), _h(e, n)
        },
        useImperativeHandle: function (e, n, i) {
          return (oe = 'useImperativeHandle'), Je(), Ft(), Cb(e, n, i)
        },
        useInsertionEffect: function (e, n) {
          return (oe = 'useInsertionEffect'), Je(), Ft(), Sb(e, n)
        },
        useLayoutEffect: function (e, n) {
          return (oe = 'useLayoutEffect'), Je(), Ft(), xb(e, n)
        },
        useMemo: function (e, n) {
          ;(oe = 'useMemo'), Je(), Ft()
          var i = Re.current
          Re.current = Oi
          try {
            return Eb(e, n)
          } finally {
            Re.current = i
          }
        },
        useReducer: function (e, n, i) {
          ;(oe = 'useReducer'), Je(), Ft()
          var s = Re.current
          Re.current = Oi
          try {
            return pb(e, n, i)
          } finally {
            Re.current = s
          }
        },
        useRef: function (e) {
          return (oe = 'useRef'), Je(), Ft(), bb(e)
        },
        useState: function (e) {
          ;(oe = 'useState'), Je(), Ft()
          var n = Re.current
          Re.current = Oi
          try {
            return Eh(e)
          } finally {
            Re.current = n
          }
        },
        useDebugValue: function (e, n) {
          return (oe = 'useDebugValue'), Je(), Ft(), void 0
        },
        useDeferredValue: function (e) {
          return (oe = 'useDeferredValue'), Je(), Ft(), Tb(e)
        },
        useTransition: function () {
          return (oe = 'useTransition'), Je(), Ft(), Rb()
        },
        useMutableSource: function (e, n, i) {
          return (oe = 'useMutableSource'), Je(), Ft(), void 0
        },
        useSyncExternalStore: function (e, n, i) {
          return (oe = 'useSyncExternalStore'), Je(), Ft(), vb(e, n, i)
        },
        useId: function () {
          return (oe = 'useId'), Je(), Ft(), _b()
        },
        unstable_isNewReconciler: ut,
      }),
      (oi = {
        readContext: function (e) {
          return kb(), Wn(e)
        },
        useCallback: function (e, n) {
          return (oe = 'useCallback'), Je(), ye(), Mh(e, n)
        },
        useContext: function (e) {
          return (oe = 'useContext'), Je(), ye(), Wn(e)
        },
        useEffect: function (e, n) {
          return (oe = 'useEffect'), Je(), ye(), kf(e, n)
        },
        useImperativeHandle: function (e, n, i) {
          return (oe = 'useImperativeHandle'), Je(), ye(), Ah(e, n, i)
        },
        useInsertionEffect: function (e, n) {
          return (oe = 'useInsertionEffect'), Je(), ye(), kh(e, n)
        },
        useLayoutEffect: function (e, n) {
          return (oe = 'useLayoutEffect'), Je(), ye(), Dh(e, n)
        },
        useMemo: function (e, n) {
          ;(oe = 'useMemo'), Je(), ye()
          var i = Re.current
          Re.current = oi
          try {
            return Ph(e, n)
          } finally {
            Re.current = i
          }
        },
        useReducer: function (e, n, i) {
          ;(oe = 'useReducer'), Je(), ye()
          var s = Re.current
          Re.current = oi
          try {
            return hb(e, n, i)
          } finally {
            Re.current = s
          }
        },
        useRef: function (e) {
          return (oe = 'useRef'), Je(), ye(), Th()
        },
        useState: function (e) {
          ;(oe = 'useState'), Je(), ye()
          var n = Re.current
          Re.current = oi
          try {
            return gb(e)
          } finally {
            Re.current = n
          }
        },
        useDebugValue: function (e, n) {
          return (oe = 'useDebugValue'), Je(), ye(), Oh()
        },
        useDeferredValue: function (e) {
          return (oe = 'useDeferredValue'), Je(), ye(), dT(e)
        },
        useTransition: function () {
          return (oe = 'useTransition'), Je(), ye(), mT()
        },
        useMutableSource: function (e, n, i) {
          return (oe = 'useMutableSource'), Je(), ye(), void 0
        },
        useSyncExternalStore: function (e, n, i) {
          return (oe = 'useSyncExternalStore'), Je(), ye(), wh(e, n)
        },
        useId: function () {
          return (oe = 'useId'), Je(), ye(), Lh()
        },
        unstable_isNewReconciler: ut,
      }),
      ($h = {
        readContext: function (e) {
          return kb(), Wn(e)
        },
        useCallback: function (e, n) {
          return (oe = 'useCallback'), Je(), ye(), Mh(e, n)
        },
        useContext: function (e) {
          return (oe = 'useContext'), Je(), ye(), Wn(e)
        },
        useEffect: function (e, n) {
          return (oe = 'useEffect'), Je(), ye(), kf(e, n)
        },
        useImperativeHandle: function (e, n, i) {
          return (oe = 'useImperativeHandle'), Je(), ye(), Ah(e, n, i)
        },
        useInsertionEffect: function (e, n) {
          return (oe = 'useInsertionEffect'), Je(), ye(), kh(e, n)
        },
        useLayoutEffect: function (e, n) {
          return (oe = 'useLayoutEffect'), Je(), ye(), Dh(e, n)
        },
        useMemo: function (e, n) {
          ;(oe = 'useMemo'), Je(), ye()
          var i = Re.current
          Re.current = oi
          try {
            return Ph(e, n)
          } finally {
            Re.current = i
          }
        },
        useReducer: function (e, n, i) {
          ;(oe = 'useReducer'), Je(), ye()
          var s = Re.current
          Re.current = oi
          try {
            return mb(e, n, i)
          } finally {
            Re.current = s
          }
        },
        useRef: function (e) {
          return (oe = 'useRef'), Je(), ye(), Th()
        },
        useState: function (e) {
          ;(oe = 'useState'), Je(), ye()
          var n = Re.current
          Re.current = oi
          try {
            return yb(e)
          } finally {
            Re.current = n
          }
        },
        useDebugValue: function (e, n) {
          return (oe = 'useDebugValue'), Je(), ye(), Oh()
        },
        useDeferredValue: function (e) {
          return (oe = 'useDeferredValue'), Je(), ye(), pT(e)
        },
        useTransition: function () {
          return (oe = 'useTransition'), Je(), ye(), vT()
        },
        useMutableSource: function (e, n, i) {
          return (oe = 'useMutableSource'), Je(), ye(), void 0
        },
        useSyncExternalStore: function (e, n, i) {
          return (oe = 'useSyncExternalStore'), Je(), ye(), wh(e, n)
        },
        useId: function () {
          return (oe = 'useId'), Je(), ye(), Lh()
        },
        unstable_isNewReconciler: ut,
      })
  }
  var us = r.unstable_now,
    RT = 0,
    Fh = -1,
    Df = -1,
    Nh = -1,
    Db = !1,
    Bh = !1
  function _T() {
    return Db
  }
  function iF() {
    Bh = !0
  }
  function oF() {
    ;(Db = !1), (Bh = !1)
  }
  function sF() {
    ;(Db = Bh), (Bh = !1)
  }
  function kT() {
    return RT
  }
  function DT() {
    RT = us()
  }
  function Ab(e) {
    ;(Df = us()), e.actualStartTime < 0 && (e.actualStartTime = us())
  }
  function AT(e) {
    Df = -1
  }
  function jh(e, n) {
    if (Df >= 0) {
      var i = us() - Df
      ;(e.actualDuration += i), n && (e.selfBaseDuration = i), (Df = -1)
    }
  }
  function Mi(e) {
    if (Fh >= 0) {
      var n = us() - Fh
      Fh = -1
      for (var i = e.return; i !== null; ) {
        switch (i.tag) {
          case b:
            var s = i.stateNode
            s.effectDuration += n
            return
          case B:
            var u = i.stateNode
            u.effectDuration += n
            return
        }
        i = i.return
      }
    }
  }
  function Ob(e) {
    if (Nh >= 0) {
      var n = us() - Nh
      Nh = -1
      for (var i = e.return; i !== null; ) {
        switch (i.tag) {
          case b:
            var s = i.stateNode
            s !== null && (s.passiveEffectDuration += n)
            return
          case B:
            var u = i.stateNode
            u !== null && (u.passiveEffectDuration += n)
            return
        }
        i = i.return
      }
    }
  }
  function Pi() {
    Fh = us()
  }
  function Mb() {
    Nh = us()
  }
  function Pb(e) {
    for (var n = e.child; n; ) (e.actualDuration += n.actualDuration), (n = n.sibling)
  }
  function ml(e, n) {
    return { value: e, source: n, stack: Vo(n), digest: null }
  }
  function Lb(e, n, i) {
    return { value: e, source: null, stack: i ?? null, digest: n ?? null }
  }
  function lF(e, n) {
    return !0
  }
  function zb(e, n) {
    try {
      var i = lF(e, n)
      if (i === !1) return
      var s = n.value,
        u = n.source,
        d = n.stack,
        v = d !== null ? d : ''
      if (s != null && s._suppressLogging) {
        if (e.tag === m) return
        console.error(s)
      }
      var y = u ? nt(u) : null,
        x = y
          ? 'The above error occurred in the <' + y + '> component:'
          : 'The above error occurred in one of your React components:',
        T
      if (e.tag === b)
        T = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`
      else {
        var _ = nt(e) || 'Anonymous'
        T =
          'React will try to recreate this component tree from scratch ' +
          ('using the error boundary you provided, ' + _ + '.')
      }
      var N =
        x +
        `
` +
        v +
        `

` +
        ('' + T)
      console.error(N)
    } catch ($) {
      setTimeout(function () {
        throw $
      })
    }
  }
  var uF = typeof WeakMap == 'function' ? WeakMap : Map
  function OT(e, n, i) {
    var s = go(vn, i)
    ;(s.tag = zy), (s.payload = { element: null })
    var u = n.value
    return (
      (s.callback = function () {
        tB(u), zb(e, n)
      }),
      s
    )
  }
  function $b(e, n, i) {
    var s = go(vn, i)
    s.tag = zy
    var u = e.type.getDerivedStateFromError
    if (typeof u == 'function') {
      var d = n.value
      ;(s.payload = function () {
        return u(d)
      }),
        (s.callback = function () {
          V1(e), zb(e, n)
        })
    }
    var v = e.stateNode
    return (
      v !== null &&
        typeof v.componentDidCatch == 'function' &&
        (s.callback = function () {
          V1(e), zb(e, n), typeof u != 'function' && JN(this)
          var x = n.value,
            T = n.stack
          this.componentDidCatch(x, { componentStack: T !== null ? T : '' }),
            typeof u != 'function' &&
              (xa(e.lanes, Ze) ||
                c(
                  '%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.',
                  nt(e) || 'Unknown'
                ))
        }),
      s
    )
  }
  function MT(e, n, i) {
    var s = e.pingCache,
      u
    if (
      (s === null
        ? ((s = e.pingCache = new uF()), (u = new Set()), s.set(n, u))
        : ((u = s.get(n)), u === void 0 && ((u = new Set()), s.set(n, u))),
      !u.has(i))
    ) {
      u.add(i)
      var d = nB.bind(null, e, n, i)
      Ja && Wf(e, i), n.then(d, d)
    }
  }
  function cF(e, n, i, s) {
    var u = e.updateQueue
    if (u === null) {
      var d = new Set()
      d.add(i), (e.updateQueue = d)
    } else u.add(i)
  }
  function fF(e, n) {
    var i = e.tag
    if ((e.mode & yt) === Ie && (i === h || i === P || i === Y)) {
      var s = e.alternate
      s
        ? ((e.updateQueue = s.updateQueue),
          (e.memoizedState = s.memoizedState),
          (e.lanes = s.lanes))
        : ((e.updateQueue = null), (e.memoizedState = null))
    }
  }
  function PT(e) {
    var n = e
    do {
      if (n.tag === j && K5(n)) return n
      n = n.return
    } while (n !== null)
    return null
  }
  function LT(e, n, i, s, u) {
    if ((e.mode & yt) === Ie) {
      if (e === n) e.flags |= Vr
      else {
        if (((e.flags |= Lt), (i.flags |= ng), (i.flags &= ~(WP | kc)), i.tag === m)) {
          var d = i.alternate
          if (d === null) i.tag = he
          else {
            var v = go(vn, Ze)
            ;(v.tag = ch), is(i, v, Ze)
          }
        }
        i.lanes = lt(i.lanes, Ze)
      }
      return e
    }
    return (e.flags |= Vr), (e.lanes = u), e
  }
  function dF(e, n, i, s, u) {
    if (
      ((i.flags |= kc),
      Ja && Wf(e, u),
      s !== null && typeof s == 'object' && typeof s.then == 'function')
    ) {
      var d = s
      fF(i), yr() && i.mode & yt && EE()
      var v = PT(n)
      if (v !== null) {
        ;(v.flags &= ~ao), LT(v, n, i, e, u), v.mode & yt && MT(e, d, u), cF(v, e, d)
        return
      } else {
        if (!zL(u)) {
          MT(e, d, u), m0()
          return
        }
        var y = new Error(
          'A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.'
        )
        s = y
      }
    } else if (yr() && i.mode & yt) {
      EE()
      var x = PT(n)
      if (x !== null) {
        ;(x.flags & Vr) === Ve && (x.flags |= ao), LT(x, n, i, e, u), ky(ml(s, i))
        return
      }
    }
    ;(s = ml(s, i)), WN(s)
    var T = n
    do {
      switch (T.tag) {
        case b: {
          var _ = s
          T.flags |= Vr
          var N = $c(u)
          T.lanes = lt(T.lanes, N)
          var $ = OT(T, _, N)
          Ny(T, $)
          return
        }
        case m:
          var q = s,
            K = T.type,
            re = T.stateNode
          if (
            (T.flags & Lt) === Ve &&
            (typeof K.getDerivedStateFromError == 'function' ||
              (re !== null && typeof re.componentDidCatch == 'function' && !P1(re)))
          ) {
            T.flags |= Vr
            var De = $c(u)
            T.lanes = lt(T.lanes, De)
            var je = $b(T, q, De)
            Ny(T, je)
            return
          }
          break
      }
      T = T.return
    } while (T !== null)
  }
  function pF() {
    return null
  }
  var Af = a.ReactCurrentOwner,
    si = !1,
    Fb,
    Of,
    Nb,
    Bb,
    jb,
    vl,
    Ub,
    Uh
  ;(Fb = {}), (Of = {}), (Nb = {}), (Bb = {}), (jb = {}), (vl = !1), (Ub = {}), (Uh = {})
  function Ir(e, n, i, s) {
    e === null ? (n.child = ZE(n, null, i, s)) : (n.child = wu(n, e.child, i, s))
  }
  function hF(e, n, i, s) {
    ;(n.child = wu(n, e.child, null, s)), (n.child = wu(n, null, i, s))
  }
  function zT(e, n, i, s, u) {
    if (n.type !== n.elementType) {
      var d = i.propTypes
      d && ti(d, s, 'prop', kt(i))
    }
    var v = i.render,
      y = n.ref,
      x,
      T
    Cu(n, u), Ac(n)
    {
      if (((Af.current = n), kr(!0), (x = Du(e, n, v, s, y, u)), (T = Au()), n.mode & Hn)) {
        pr(!0)
        try {
          ;(x = Du(e, n, v, s, y, u)), (T = Au())
        } finally {
          pr(!1)
        }
      }
      kr(!1)
    }
    return (
      nu(),
      e !== null && !si
        ? (rT(e, n, u), yo(e, n, u))
        : (yr() && T && Cy(n), (n.flags |= Jl), Ir(e, n, x, u), n.child)
    )
  }
  function $T(e, n, i, s, u) {
    if (e === null) {
      var d = i.type
      if (bB(d) && i.compare === null && i.defaultProps === void 0) {
        var v = d
        return (v = Nu(d)), (n.tag = Y), (n.type = v), Hb(n, d), FT(e, n, v, s, u)
      }
      {
        var y = d.propTypes
        y && ti(y, s, 'prop', kt(d))
      }
      var x = R0(i.type, null, s, n, n.mode, u)
      return (x.ref = n.ref), (x.return = n), (n.child = x), x
    }
    {
      var T = i.type,
        _ = T.propTypes
      _ && ti(_, s, 'prop', kt(T))
    }
    var N = e.child,
      $ = Xb(e, u)
    if (!$) {
      var q = N.memoizedProps,
        K = i.compare
      if (((K = K !== null ? K : Qc), K(q, s) && e.ref === n.ref)) return yo(e, n, u)
    }
    n.flags |= Jl
    var re = xl(N, s)
    return (re.ref = n.ref), (re.return = n), (n.child = re), re
  }
  function FT(e, n, i, s, u) {
    if (n.type !== n.elementType) {
      var d = n.elementType
      if (d.$$typeof === Be) {
        var v = d,
          y = v._payload,
          x = v._init
        try {
          d = x(y)
        } catch {
          d = null
        }
        var T = d && d.propTypes
        T && ti(T, s, 'prop', kt(d))
      }
    }
    if (e !== null) {
      var _ = e.memoizedProps
      if (Qc(_, s) && e.ref === n.ref && n.type === e.type)
        if (((si = !1), (n.pendingProps = s = _), Xb(e, u))) (e.flags & ng) !== Ve && (si = !0)
        else return (n.lanes = e.lanes), yo(e, n, u)
    }
    return Vb(e, n, i, s, u)
  }
  function NT(e, n, i) {
    var s = n.pendingProps,
      u = s.children,
      d = e !== null ? e.memoizedState : null
    if (s.mode === 'hidden' || rt)
      if ((n.mode & yt) === Ie) {
        var v = { baseLanes: ue, cachePool: null, transitions: null }
        ;(n.memoizedState = v), em(n, i)
      } else if (xa(i, Sa)) {
        var N = { baseLanes: ue, cachePool: null, transitions: null }
        n.memoizedState = N
        var $ = d !== null ? d.baseLanes : i
        em(n, $)
      } else {
        var y = null,
          x
        if (d !== null) {
          var T = d.baseLanes
          x = lt(T, i)
        } else x = i
        n.lanes = n.childLanes = Sa
        var _ = { baseLanes: x, cachePool: y, transitions: null }
        return (n.memoizedState = _), (n.updateQueue = null), em(n, x), null
      }
    else {
      var q
      d !== null ? ((q = lt(d.baseLanes, i)), (n.memoizedState = null)) : (q = i), em(n, q)
    }
    return Ir(e, n, u, i), n.child
  }
  function mF(e, n, i) {
    var s = n.pendingProps
    return Ir(e, n, s, i), n.child
  }
  function vF(e, n, i) {
    var s = n.pendingProps.children
    return Ir(e, n, s, i), n.child
  }
  function gF(e, n, i) {
    {
      n.flags |= Tt
      {
        var s = n.stateNode
        ;(s.effectDuration = 0), (s.passiveEffectDuration = 0)
      }
    }
    var u = n.pendingProps,
      d = u.children
    return Ir(e, n, d, i), n.child
  }
  function BT(e, n) {
    var i = n.ref
    ;((e === null && i !== null) || (e !== null && e.ref !== i)) &&
      ((n.flags |= Go), (n.flags |= rg))
  }
  function Vb(e, n, i, s, u) {
    if (n.type !== n.elementType) {
      var d = i.propTypes
      d && ti(d, s, 'prop', kt(i))
    }
    var v
    {
      var y = vu(n, i, !0)
      v = gu(n, y)
    }
    var x, T
    Cu(n, u), Ac(n)
    {
      if (((Af.current = n), kr(!0), (x = Du(e, n, i, s, v, u)), (T = Au()), n.mode & Hn)) {
        pr(!0)
        try {
          ;(x = Du(e, n, i, s, v, u)), (T = Au())
        } finally {
          pr(!1)
        }
      }
      kr(!1)
    }
    return (
      nu(),
      e !== null && !si
        ? (rT(e, n, u), yo(e, n, u))
        : (yr() && T && Cy(n), (n.flags |= Jl), Ir(e, n, x, u), n.child)
    )
  }
  function jT(e, n, i, s, u) {
    {
      switch (LB(n)) {
        case !1: {
          var d = n.stateNode,
            v = n.type,
            y = new v(n.memoizedProps, d.context),
            x = y.state
          d.updater.enqueueSetState(d, x, null)
          break
        }
        case !0: {
          ;(n.flags |= Lt), (n.flags |= Vr)
          var T = new Error('Simulated error coming from DevTools'),
            _ = $c(u)
          n.lanes = lt(n.lanes, _)
          var N = $b(n, ml(T, n), _)
          Ny(n, N)
          break
        }
      }
      if (n.type !== n.elementType) {
        var $ = i.propTypes
        $ && ti($, s, 'prop', kt(i))
      }
    }
    var q
    ki(i) ? ((q = !0), Jp(n)) : (q = !1), Cu(n, u)
    var K = n.stateNode,
      re
    K === null
      ? (Ih(e, n), GE(n, i, s), Xy(n, i, s, u), (re = !0))
      : e === null
      ? (re = I5(n, i, s, u))
      : (re = H5(e, n, i, s, u))
    var De = Ib(e, n, i, re, q, u)
    {
      var je = n.stateNode
      re &&
        je.props !== s &&
        (vl ||
          c(
            'It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.',
            nt(n) || 'a component'
          ),
        (vl = !0))
    }
    return De
  }
  function Ib(e, n, i, s, u, d) {
    BT(e, n)
    var v = (n.flags & Lt) !== Ve
    if (!s && !v) return u && SE(n, i, !1), yo(e, n, d)
    var y = n.stateNode
    Af.current = n
    var x
    if (v && typeof i.getDerivedStateFromError != 'function') (x = null), AT()
    else {
      Ac(n)
      {
        if ((kr(!0), (x = y.render()), n.mode & Hn)) {
          pr(!0)
          try {
            y.render()
          } finally {
            pr(!1)
          }
        }
        kr(!1)
      }
      nu()
    }
    return (
      (n.flags |= Jl),
      e !== null && v ? hF(e, n, x, d) : Ir(e, n, x, d),
      (n.memoizedState = y.state),
      u && SE(n, i, !0),
      n.child
    )
  }
  function UT(e) {
    var n = e.stateNode
    n.pendingContext
      ? yE(e, n.pendingContext, n.pendingContext !== n.context)
      : n.context && yE(e, n.context, !1),
      nb(e, n.containerInfo)
  }
  function yF(e, n, i) {
    if ((UT(n), e === null)) throw new Error('Should have a current fiber. This is a bug in React.')
    var s = n.pendingProps,
      u = n.memoizedState,
      d = u.element
    BE(e, n), hh(n, s, null, i)
    var v = n.memoizedState
    n.stateNode
    var y = v.element
    if (u.isDehydrated) {
      var x = {
          element: y,
          isDehydrated: !1,
          cache: v.cache,
          pendingSuspenseBoundaries: v.pendingSuspenseBoundaries,
          transitions: v.transitions,
        },
        T = n.updateQueue
      if (((T.baseState = x), (n.memoizedState = x), n.flags & ao)) {
        var _ = ml(
          new Error(
            'There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.'
          ),
          n
        )
        return VT(e, n, y, i, _)
      } else if (y !== d) {
        var N = ml(
          new Error(
            'This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.'
          ),
          n
        )
        return VT(e, n, y, i, N)
      } else {
        C5(n)
        var $ = ZE(n, null, y, i)
        n.child = $
        for (var q = $; q; ) (q.flags = (q.flags & ~In) | io), (q = q.sibling)
      }
    } else {
      if ((Su(), y === d)) return yo(e, n, i)
      Ir(e, n, y, i)
    }
    return n.child
  }
  function VT(e, n, i, s, u) {
    return Su(), ky(u), (n.flags |= ao), Ir(e, n, i, s), n.child
  }
  function bF(e, n, i) {
    eT(n), e === null && _y(n)
    var s = n.type,
      u = n.pendingProps,
      d = e !== null ? e.memoizedProps : null,
      v = u.children,
      y = ly(s, u)
    return (
      y ? (v = null) : d !== null && ly(s, d) && (n.flags |= _c), BT(e, n), Ir(e, n, v, i), n.child
    )
  }
  function SF(e, n) {
    return e === null && _y(n), null
  }
  function xF(e, n, i, s) {
    Ih(e, n)
    var u = n.pendingProps,
      d = i,
      v = d._payload,
      y = d._init,
      x = y(v)
    n.type = x
    var T = (n.tag = SB(x)),
      _ = ai(x, u),
      N
    switch (T) {
      case h:
        return Hb(n, x), (n.type = x = Nu(x)), (N = Vb(null, n, x, _, s)), N
      case m:
        return (n.type = x = S0(x)), (N = jT(null, n, x, _, s)), N
      case P:
        return (n.type = x = x0(x)), (N = zT(null, n, x, _, s)), N
      case Q: {
        if (n.type !== n.elementType) {
          var $ = x.propTypes
          $ && ti($, _, 'prop', kt(x))
        }
        return (N = $T(null, n, x, ai(x.type, _), s)), N
      }
    }
    var q = ''
    throw (
      (x !== null &&
        typeof x == 'object' &&
        x.$$typeof === Be &&
        (q = ' Did you wrap a component in React.lazy() more than once?'),
      new Error(
        'Element type is invalid. Received a promise that resolves to: ' +
          x +
          '. ' +
          ('Lazy element type must resolve to a class or function.' + q)
      ))
    )
  }
  function CF(e, n, i, s, u) {
    Ih(e, n), (n.tag = m)
    var d
    return (
      ki(i) ? ((d = !0), Jp(n)) : (d = !1),
      Cu(n, u),
      GE(n, i, s),
      Xy(n, i, s, u),
      Ib(null, n, i, !0, d, u)
    )
  }
  function wF(e, n, i, s) {
    Ih(e, n)
    var u = n.pendingProps,
      d
    {
      var v = vu(n, i, !1)
      d = gu(n, v)
    }
    Cu(n, s)
    var y, x
    Ac(n)
    {
      if (i.prototype && typeof i.prototype.render == 'function') {
        var T = kt(i) || 'Unknown'
        Fb[T] ||
          (c(
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
            T,
            T
          ),
          (Fb[T] = !0))
      }
      n.mode & Hn && ri.recordLegacyContextWarning(n, null),
        kr(!0),
        (Af.current = n),
        (y = Du(null, n, i, u, d, s)),
        (x = Au()),
        kr(!1)
    }
    if (
      (nu(),
      (n.flags |= Jl),
      typeof y == 'object' && y !== null && typeof y.render == 'function' && y.$$typeof === void 0)
    ) {
      var _ = kt(i) || 'Unknown'
      Of[_] ||
        (c(
          "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
          _,
          _,
          _
        ),
        (Of[_] = !0))
    }
    if (
      typeof y == 'object' &&
      y !== null &&
      typeof y.render == 'function' &&
      y.$$typeof === void 0
    ) {
      {
        var N = kt(i) || 'Unknown'
        Of[N] ||
          (c(
            "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
            N,
            N,
            N
          ),
          (Of[N] = !0))
      }
      ;(n.tag = m), (n.memoizedState = null), (n.updateQueue = null)
      var $ = !1
      return (
        ki(i) ? (($ = !0), Jp(n)) : ($ = !1),
        (n.memoizedState = y.state !== null && y.state !== void 0 ? y.state : null),
        Fy(n),
        YE(n, y),
        Xy(n, i, u, s),
        Ib(null, n, i, !0, $, s)
      )
    } else {
      if (((n.tag = h), n.mode & Hn)) {
        pr(!0)
        try {
          ;(y = Du(null, n, i, u, d, s)), (x = Au())
        } finally {
          pr(!1)
        }
      }
      return yr() && x && Cy(n), Ir(null, n, y, s), Hb(n, i), n.child
    }
  }
  function Hb(e, n) {
    {
      if (
        (n &&
          n.childContextTypes &&
          c(
            '%s(...): childContextTypes cannot be defined on a function component.',
            n.displayName || n.name || 'Component'
          ),
        e.ref !== null)
      ) {
        var i = '',
          s = za()
        s &&
          (i +=
            `

Check the render method of \`` +
            s +
            '`.')
        var u = s || '',
          d = e._debugSource
        d && (u = d.fileName + ':' + d.lineNumber),
          jb[u] ||
            ((jb[u] = !0),
            c(
              'Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s',
              i
            ))
      }
      if (typeof n.getDerivedStateFromProps == 'function') {
        var v = kt(n) || 'Unknown'
        Bb[v] ||
          (c('%s: Function components do not support getDerivedStateFromProps.', v), (Bb[v] = !0))
      }
      if (typeof n.contextType == 'object' && n.contextType !== null) {
        var y = kt(n) || 'Unknown'
        Nb[y] || (c('%s: Function components do not support contextType.', y), (Nb[y] = !0))
      }
    }
  }
  var Wb = { dehydrated: null, treeContext: null, retryLane: hr }
  function Yb(e) {
    return { baseLanes: e, cachePool: pF(), transitions: null }
  }
  function EF(e, n) {
    var i = null
    return { baseLanes: lt(e.baseLanes, n), cachePool: i, transitions: e.transitions }
  }
  function TF(e, n, i, s) {
    if (n !== null) {
      var u = n.memoizedState
      if (u === null) return !1
    }
    return ib(e, Cf)
  }
  function RF(e, n) {
    return Cp(e.childLanes, n)
  }
  function IT(e, n, i) {
    var s = n.pendingProps
    zB(n) && (n.flags |= Lt)
    var u = ii.current,
      d = !1,
      v = (n.flags & Lt) !== Ve
    if (
      (v || TF(u, e)
        ? ((d = !0), (n.flags &= ~Lt))
        : (e === null || e.memoizedState !== null) && (u = q5(u, nT)),
      (u = Tu(u)),
      ss(n, u),
      e === null)
    ) {
      _y(n)
      var y = n.memoizedState
      if (y !== null) {
        var x = y.dehydrated
        if (x !== null) return OF(n, x)
      }
      var T = s.children,
        _ = s.fallback
      if (d) {
        var N = _F(n, T, _, i),
          $ = n.child
        return ($.memoizedState = Yb(i)), (n.memoizedState = Wb), N
      } else return Gb(n, T)
    } else {
      var q = e.memoizedState
      if (q !== null) {
        var K = q.dehydrated
        if (K !== null) return MF(e, n, v, s, K, q, i)
      }
      if (d) {
        var re = s.fallback,
          De = s.children,
          je = DF(e, n, De, re, i),
          Fe = n.child,
          St = e.child.memoizedState
        return (
          (Fe.memoizedState = St === null ? Yb(i) : EF(St, i)),
          (Fe.childLanes = RF(e, i)),
          (n.memoizedState = Wb),
          je
        )
      } else {
        var ht = s.children,
          H = kF(e, n, ht, i)
        return (n.memoizedState = null), H
      }
    }
  }
  function Gb(e, n, i) {
    var s = e.mode,
      u = { mode: 'visible', children: n },
      d = qb(u, s)
    return (d.return = e), (e.child = d), d
  }
  function _F(e, n, i, s) {
    var u = e.mode,
      d = e.child,
      v = { mode: 'hidden', children: n },
      y,
      x
    return (
      (u & yt) === Ie && d !== null
        ? ((y = d),
          (y.childLanes = ue),
          (y.pendingProps = v),
          e.mode & Yt &&
            ((y.actualDuration = 0),
            (y.actualStartTime = -1),
            (y.selfBaseDuration = 0),
            (y.treeBaseDuration = 0)),
          (x = ms(i, u, s, null)))
        : ((y = qb(v, u)), (x = ms(i, u, s, null))),
      (y.return = e),
      (x.return = e),
      (y.sibling = x),
      (e.child = y),
      x
    )
  }
  function qb(e, n, i) {
    return H1(e, n, ue, null)
  }
  function HT(e, n) {
    return xl(e, n)
  }
  function kF(e, n, i, s) {
    var u = e.child,
      d = u.sibling,
      v = HT(u, { mode: 'visible', children: i })
    if (((n.mode & yt) === Ie && (v.lanes = s), (v.return = n), (v.sibling = null), d !== null)) {
      var y = n.deletions
      y === null ? ((n.deletions = [d]), (n.flags |= qs)) : y.push(d)
    }
    return (n.child = v), v
  }
  function DF(e, n, i, s, u) {
    var d = n.mode,
      v = e.child,
      y = v.sibling,
      x = { mode: 'hidden', children: i },
      T
    if ((d & yt) === Ie && n.child !== v) {
      var _ = n.child
      ;(T = _),
        (T.childLanes = ue),
        (T.pendingProps = x),
        n.mode & Yt &&
          ((T.actualDuration = 0),
          (T.actualStartTime = -1),
          (T.selfBaseDuration = v.selfBaseDuration),
          (T.treeBaseDuration = v.treeBaseDuration)),
        (n.deletions = null)
    } else (T = HT(v, x)), (T.subtreeFlags = v.subtreeFlags & so)
    var N
    return (
      y !== null ? (N = xl(y, s)) : ((N = ms(s, d, u, null)), (N.flags |= In)),
      (N.return = n),
      (T.return = n),
      (T.sibling = N),
      (n.child = T),
      N
    )
  }
  function Vh(e, n, i, s) {
    s !== null && ky(s), wu(n, e.child, null, i)
    var u = n.pendingProps,
      d = u.children,
      v = Gb(n, d)
    return (v.flags |= In), (n.memoizedState = null), v
  }
  function AF(e, n, i, s, u) {
    var d = n.mode,
      v = { mode: 'visible', children: i },
      y = qb(v, d),
      x = ms(s, d, u, null)
    return (
      (x.flags |= In),
      (y.return = n),
      (x.return = n),
      (y.sibling = x),
      (n.child = y),
      (n.mode & yt) !== Ie && wu(n, e.child, null, u),
      x
    )
  }
  function OF(e, n, i) {
    return (
      (e.mode & yt) === Ie
        ? (c(
            'Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.'
          ),
          (e.lanes = Ze))
        : dy(n)
        ? (e.lanes = el)
        : (e.lanes = Sa),
      null
    )
  }
  function MF(e, n, i, s, u, d, v) {
    if (i)
      if (n.flags & ao) {
        n.flags &= ~ao
        var H = Lb(
          new Error(
            'There was an error while hydrating this Suspense boundary. Switched to client rendering.'
          )
        )
        return Vh(e, n, v, H)
      } else {
        if (n.memoizedState !== null) return (n.child = e.child), (n.flags |= Lt), null
        var ae = s.children,
          W = s.fallback,
          fe = AF(e, n, ae, W, v),
          Ae = n.child
        return (Ae.memoizedState = Yb(v)), (n.memoizedState = Wb), fe
      }
    else {
      if ((S5(), (n.mode & yt) === Ie)) return Vh(e, n, v, null)
      if (dy(u)) {
        var y, x, T
        {
          var _ = F2(u)
          ;(y = _.digest), (x = _.message), (T = _.stack)
        }
        var N
        x
          ? (N = new Error(x))
          : (N = new Error(
              'The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.'
            ))
        var $ = Lb(N, y, T)
        return Vh(e, n, v, $)
      }
      var q = xa(v, e.childLanes)
      if (si || q) {
        var K = Jh()
        if (K !== null) {
          var re = IL(K, v)
          if (re !== hr && re !== d.retryLane) {
            d.retryLane = re
            var De = vn
            ia(e, re), or(K, e, re, De)
          }
        }
        m0()
        var je = Lb(
          new Error(
            'This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition.'
          )
        )
        return Vh(e, n, v, je)
      } else if (dE(u)) {
        ;(n.flags |= Lt), (n.child = e.child)
        var Fe = rB.bind(null, e)
        return N2(u, Fe), null
      } else {
        w5(n, u, d.treeContext)
        var St = s.children,
          ht = Gb(n, St)
        return (ht.flags |= io), ht
      }
    }
  }
  function WT(e, n, i) {
    e.lanes = lt(e.lanes, n)
    var s = e.alternate
    s !== null && (s.lanes = lt(s.lanes, n)), Py(e.return, n, i)
  }
  function PF(e, n, i) {
    for (var s = n; s !== null; ) {
      if (s.tag === j) {
        var u = s.memoizedState
        u !== null && WT(s, i, e)
      } else if (s.tag === pe) WT(s, i, e)
      else if (s.child !== null) {
        ;(s.child.return = s), (s = s.child)
        continue
      }
      if (s === e) return
      for (; s.sibling === null; ) {
        if (s.return === null || s.return === e) return
        s = s.return
      }
      ;(s.sibling.return = s.return), (s = s.sibling)
    }
  }
  function LF(e) {
    for (var n = e, i = null; n !== null; ) {
      var s = n.alternate
      s !== null && xh(s) === null && (i = n), (n = n.sibling)
    }
    return i
  }
  function zF(e) {
    if (e !== void 0 && e !== 'forwards' && e !== 'backwards' && e !== 'together' && !Ub[e])
      if (((Ub[e] = !0), typeof e == 'string'))
        switch (e.toLowerCase()) {
          case 'together':
          case 'forwards':
          case 'backwards': {
            c(
              '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
              e,
              e.toLowerCase()
            )
            break
          }
          case 'forward':
          case 'backward': {
            c(
              '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
              e,
              e.toLowerCase()
            )
            break
          }
          default:
            c(
              '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
              e
            )
            break
        }
      else
        c(
          '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
          e
        )
  }
  function $F(e, n) {
    e !== void 0 &&
      !Uh[e] &&
      (e !== 'collapsed' && e !== 'hidden'
        ? ((Uh[e] = !0),
          c(
            '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
            e
          ))
        : n !== 'forwards' &&
          n !== 'backwards' &&
          ((Uh[e] = !0),
          c(
            '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
            e
          )))
  }
  function YT(e, n) {
    {
      var i = Pt(e),
        s = !i && typeof Ka(e) == 'function'
      if (i || s) {
        var u = i ? 'array' : 'iterable'
        return (
          c(
            'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>',
            u,
            n,
            u
          ),
          !1
        )
      }
    }
    return !0
  }
  function FF(e, n) {
    if ((n === 'forwards' || n === 'backwards') && e !== void 0 && e !== null && e !== !1)
      if (Pt(e)) {
        for (var i = 0; i < e.length; i++) if (!YT(e[i], i)) return
      } else {
        var s = Ka(e)
        if (typeof s == 'function') {
          var u = s.call(e)
          if (u)
            for (var d = u.next(), v = 0; !d.done; d = u.next()) {
              if (!YT(d.value, v)) return
              v++
            }
        } else
          c(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            n
          )
      }
  }
  function Kb(e, n, i, s, u) {
    var d = e.memoizedState
    d === null
      ? (e.memoizedState = {
          isBackwards: n,
          rendering: null,
          renderingStartTime: 0,
          last: s,
          tail: i,
          tailMode: u,
        })
      : ((d.isBackwards = n),
        (d.rendering = null),
        (d.renderingStartTime = 0),
        (d.last = s),
        (d.tail = i),
        (d.tailMode = u))
  }
  function GT(e, n, i) {
    var s = n.pendingProps,
      u = s.revealOrder,
      d = s.tail,
      v = s.children
    zF(u), $F(d, u), FF(v, u), Ir(e, n, v, i)
    var y = ii.current,
      x = ib(y, Cf)
    if (x) (y = ob(y, Cf)), (n.flags |= Lt)
    else {
      var T = e !== null && (e.flags & Lt) !== Ve
      T && PF(n, n.child, i), (y = Tu(y))
    }
    if ((ss(n, y), (n.mode & yt) === Ie)) n.memoizedState = null
    else
      switch (u) {
        case 'forwards': {
          var _ = LF(n.child),
            N
          _ === null ? ((N = n.child), (n.child = null)) : ((N = _.sibling), (_.sibling = null)),
            Kb(n, !1, N, _, d)
          break
        }
        case 'backwards': {
          var $ = null,
            q = n.child
          for (n.child = null; q !== null; ) {
            var K = q.alternate
            if (K !== null && xh(K) === null) {
              n.child = q
              break
            }
            var re = q.sibling
            ;(q.sibling = $), ($ = q), (q = re)
          }
          Kb(n, !0, $, null, d)
          break
        }
        case 'together': {
          Kb(n, !1, null, null, void 0)
          break
        }
        default:
          n.memoizedState = null
      }
    return n.child
  }
  function NF(e, n, i) {
    nb(n, n.stateNode.containerInfo)
    var s = n.pendingProps
    return e === null ? (n.child = wu(n, null, s, i)) : Ir(e, n, s, i), n.child
  }
  var qT = !1
  function BF(e, n, i) {
    var s = n.type,
      u = s._context,
      d = n.pendingProps,
      v = n.memoizedProps,
      y = d.value
    {
      'value' in d ||
        qT ||
        ((qT = !0),
        c(
          'The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?'
        ))
      var x = n.type.propTypes
      x && ti(x, d, 'prop', 'Context.Provider')
    }
    if ((zE(n, u, y), v !== null)) {
      var T = v.value
      if (Ea(T, y)) {
        if (v.children === d.children && !Qp()) return yo(e, n, i)
      } else P5(n, u, i)
    }
    var _ = d.children
    return Ir(e, n, _, i), n.child
  }
  var KT = !1
  function jF(e, n, i) {
    var s = n.type
    s._context === void 0
      ? s !== s.Consumer &&
        (KT ||
          ((KT = !0),
          c(
            'Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?'
          )))
      : (s = s._context)
    var u = n.pendingProps,
      d = u.children
    typeof d != 'function' &&
      c(
        "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
      ),
      Cu(n, i)
    var v = Wn(s)
    Ac(n)
    var y
    return (
      (Af.current = n), kr(!0), (y = d(v)), kr(!1), nu(), (n.flags |= Jl), Ir(e, n, y, i), n.child
    )
  }
  function Mf() {
    si = !0
  }
  function Ih(e, n) {
    ;(n.mode & yt) === Ie &&
      e !== null &&
      ((e.alternate = null), (n.alternate = null), (n.flags |= In))
  }
  function yo(e, n, i) {
    return (
      e !== null && (n.dependencies = e.dependencies),
      AT(),
      Hf(n.lanes),
      xa(i, n.childLanes) ? (W5(e, n), n.child) : null
    )
  }
  function UF(e, n, i) {
    {
      var s = n.return
      if (s === null) throw new Error('Cannot swap the root fiber.')
      if (
        ((e.alternate = null),
        (n.alternate = null),
        (i.index = n.index),
        (i.sibling = n.sibling),
        (i.return = n.return),
        (i.ref = n.ref),
        n === s.child)
      )
        s.child = i
      else {
        var u = s.child
        if (u === null) throw new Error('Expected parent to have a child.')
        for (; u.sibling !== n; )
          if (((u = u.sibling), u === null))
            throw new Error('Expected to find the previous sibling.')
        u.sibling = i
      }
      var d = s.deletions
      return d === null ? ((s.deletions = [e]), (s.flags |= qs)) : d.push(e), (i.flags |= In), i
    }
  }
  function Xb(e, n) {
    var i = e.lanes
    return !!xa(i, n)
  }
  function VF(e, n, i) {
    switch (n.tag) {
      case b:
        UT(n), n.stateNode, Su()
        break
      case w:
        eT(n)
        break
      case m: {
        var s = n.type
        ki(s) && Jp(n)
        break
      }
      case C:
        nb(n, n.stateNode.containerInfo)
        break
      case z: {
        var u = n.memoizedProps.value,
          d = n.type._context
        zE(n, d, u)
        break
      }
      case B:
        {
          var v = xa(i, n.childLanes)
          v && (n.flags |= Tt)
          {
            var y = n.stateNode
            ;(y.effectDuration = 0), (y.passiveEffectDuration = 0)
          }
        }
        break
      case j: {
        var x = n.memoizedState
        if (x !== null) {
          if (x.dehydrated !== null) return ss(n, Tu(ii.current)), (n.flags |= Lt), null
          var T = n.child,
            _ = T.childLanes
          if (xa(i, _)) return IT(e, n, i)
          ss(n, Tu(ii.current))
          var N = yo(e, n, i)
          return N !== null ? N.sibling : null
        } else ss(n, Tu(ii.current))
        break
      }
      case pe: {
        var $ = (e.flags & Lt) !== Ve,
          q = xa(i, n.childLanes)
        if ($) {
          if (q) return GT(e, n, i)
          n.flags |= Lt
        }
        var K = n.memoizedState
        if (
          (K !== null && ((K.rendering = null), (K.tail = null), (K.lastEffect = null)),
          ss(n, ii.current),
          q)
        )
          break
        return null
      }
      case me:
      case ge:
        return (n.lanes = ue), NT(e, n, i)
    }
    return yo(e, n, i)
  }
  function XT(e, n, i) {
    if (n._debugNeedsRemount && e !== null)
      return UF(e, n, R0(n.type, n.key, n.pendingProps, n._debugOwner || null, n.mode, n.lanes))
    if (e !== null) {
      var s = e.memoizedProps,
        u = n.pendingProps
      if (s !== u || Qp() || n.type !== e.type) si = !0
      else {
        var d = Xb(e, i)
        if (!d && (n.flags & Lt) === Ve) return (si = !1), VF(e, n, i)
        ;(e.flags & ng) !== Ve ? (si = !0) : (si = !1)
      }
    } else if (((si = !1), yr() && h5(n))) {
      var v = n.index,
        y = m5()
      wE(n, y, v)
    }
    switch (((n.lanes = ue), n.tag)) {
      case g:
        return wF(e, n, n.type, i)
      case ne: {
        var x = n.elementType
        return xF(e, n, x, i)
      }
      case h: {
        var T = n.type,
          _ = n.pendingProps,
          N = n.elementType === T ? _ : ai(T, _)
        return Vb(e, n, T, N, i)
      }
      case m: {
        var $ = n.type,
          q = n.pendingProps,
          K = n.elementType === $ ? q : ai($, q)
        return jT(e, n, $, K, i)
      }
      case b:
        return yF(e, n, i)
      case w:
        return bF(e, n, i)
      case k:
        return SF(e, n)
      case j:
        return IT(e, n, i)
      case C:
        return NF(e, n, i)
      case P: {
        var re = n.type,
          De = n.pendingProps,
          je = n.elementType === re ? De : ai(re, De)
        return zT(e, n, re, je, i)
      }
      case D:
        return mF(e, n, i)
      case E:
        return vF(e, n, i)
      case B:
        return gF(e, n, i)
      case z:
        return BF(e, n, i)
      case M:
        return jF(e, n, i)
      case Q: {
        var Fe = n.type,
          St = n.pendingProps,
          ht = ai(Fe, St)
        if (n.type !== n.elementType) {
          var H = Fe.propTypes
          H && ti(H, ht, 'prop', kt(Fe))
        }
        return (ht = ai(Fe.type, ht)), $T(e, n, Fe, ht, i)
      }
      case Y:
        return FT(e, n, n.type, n.pendingProps, i)
      case he: {
        var ae = n.type,
          W = n.pendingProps,
          fe = n.elementType === ae ? W : ai(ae, W)
        return CF(e, n, ae, fe, i)
      }
      case pe:
        return GT(e, n, i)
      case Ne:
        break
      case me:
        return NT(e, n, i)
    }
    throw new Error(
      'Unknown unit of work tag (' +
        n.tag +
        '). This error is likely caused by a bug in React. Please file an issue.'
    )
  }
  function Ou(e) {
    e.flags |= Tt
  }
  function QT(e) {
    ;(e.flags |= Go), (e.flags |= rg)
  }
  var ZT, Qb, JT, e1
  ;(ZT = function (e, n, i, s) {
    for (var u = n.child; u !== null; ) {
      if (u.tag === w || u.tag === k) f2(e, u.stateNode)
      else if (u.tag !== C) {
        if (u.child !== null) {
          ;(u.child.return = u), (u = u.child)
          continue
        }
      }
      if (u === n) return
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === n) return
        u = u.return
      }
      ;(u.sibling.return = u.return), (u = u.sibling)
    }
  }),
    (Qb = function (e, n) {}),
    (JT = function (e, n, i, s, u) {
      var d = e.memoizedProps
      if (d !== s) {
        var v = n.stateNode,
          y = rb(),
          x = p2(v, i, d, s, u, y)
        ;(n.updateQueue = x), x && Ou(n)
      }
    }),
    (e1 = function (e, n, i, s) {
      i !== s && Ou(n)
    })
  function Pf(e, n) {
    if (!yr())
      switch (e.tailMode) {
        case 'hidden': {
          for (var i = e.tail, s = null; i !== null; )
            i.alternate !== null && (s = i), (i = i.sibling)
          s === null ? (e.tail = null) : (s.sibling = null)
          break
        }
        case 'collapsed': {
          for (var u = e.tail, d = null; u !== null; )
            u.alternate !== null && (d = u), (u = u.sibling)
          d === null
            ? !n && e.tail !== null
              ? (e.tail.sibling = null)
              : (e.tail = null)
            : (d.sibling = null)
          break
        }
      }
  }
  function Sr(e) {
    var n = e.alternate !== null && e.alternate.child === e.child,
      i = ue,
      s = Ve
    if (n) {
      if ((e.mode & Yt) !== Ie) {
        for (var x = e.selfBaseDuration, T = e.child; T !== null; )
          (i = lt(i, lt(T.lanes, T.childLanes))),
            (s |= T.subtreeFlags & so),
            (s |= T.flags & so),
            (x += T.treeBaseDuration),
            (T = T.sibling)
        e.treeBaseDuration = x
      } else
        for (var _ = e.child; _ !== null; )
          (i = lt(i, lt(_.lanes, _.childLanes))),
            (s |= _.subtreeFlags & so),
            (s |= _.flags & so),
            (_.return = e),
            (_ = _.sibling)
      e.subtreeFlags |= s
    } else {
      if ((e.mode & Yt) !== Ie) {
        for (var u = e.actualDuration, d = e.selfBaseDuration, v = e.child; v !== null; )
          (i = lt(i, lt(v.lanes, v.childLanes))),
            (s |= v.subtreeFlags),
            (s |= v.flags),
            (u += v.actualDuration),
            (d += v.treeBaseDuration),
            (v = v.sibling)
        ;(e.actualDuration = u), (e.treeBaseDuration = d)
      } else
        for (var y = e.child; y !== null; )
          (i = lt(i, lt(y.lanes, y.childLanes))),
            (s |= y.subtreeFlags),
            (s |= y.flags),
            (y.return = e),
            (y = y.sibling)
      e.subtreeFlags |= s
    }
    return (e.childLanes = i), n
  }
  function IF(e, n, i) {
    if (k5() && (n.mode & yt) !== Ie && (n.flags & Lt) === Ve)
      return AE(n), Su(), (n.flags |= ao | kc | Vr), !1
    var s = ah(n)
    if (i !== null && i.dehydrated !== null)
      if (e === null) {
        if (!s)
          throw new Error(
            'A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.'
          )
        if ((R5(n), Sr(n), (n.mode & Yt) !== Ie)) {
          var u = i !== null
          if (u) {
            var d = n.child
            d !== null && (n.treeBaseDuration -= d.treeBaseDuration)
          }
        }
        return !1
      } else {
        if (
          (Su(),
          (n.flags & Lt) === Ve && (n.memoizedState = null),
          (n.flags |= Tt),
          Sr(n),
          (n.mode & Yt) !== Ie)
        ) {
          var v = i !== null
          if (v) {
            var y = n.child
            y !== null && (n.treeBaseDuration -= y.treeBaseDuration)
          }
        }
        return !1
      }
    else return OE(), !0
  }
  function t1(e, n, i) {
    var s = n.pendingProps
    switch ((wy(n), n.tag)) {
      case g:
      case ne:
      case Y:
      case h:
      case P:
      case D:
      case E:
      case B:
      case M:
      case Q:
        return Sr(n), null
      case m: {
        var u = n.type
        return ki(u) && Zp(n), Sr(n), null
      }
      case b: {
        var d = n.stateNode
        if (
          (Eu(n),
          by(n),
          lb(),
          d.pendingContext && ((d.context = d.pendingContext), (d.pendingContext = null)),
          e === null || e.child === null)
        ) {
          var v = ah(n)
          if (v) Ou(n)
          else if (e !== null) {
            var y = e.memoizedState
            ;(!y.isDehydrated || (n.flags & ao) !== Ve) && ((n.flags |= Ks), OE())
          }
        }
        return Qb(e, n), Sr(n), null
      }
      case w: {
        ab(n)
        var x = JE(),
          T = n.type
        if (e !== null && n.stateNode != null) JT(e, n, T, s, x), e.ref !== n.ref && QT(n)
        else {
          if (!s) {
            if (n.stateNode === null)
              throw new Error(
                'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
              )
            return Sr(n), null
          }
          var _ = rb(),
            N = ah(n)
          if (N) E5(n, x, _) && Ou(n)
          else {
            var $ = c2(T, s, x, _, n)
            ZT($, n, !1, !1), (n.stateNode = $), d2($, T, s, x) && Ou(n)
          }
          n.ref !== null && QT(n)
        }
        return Sr(n), null
      }
      case k: {
        var q = s
        if (e && n.stateNode != null) {
          var K = e.memoizedProps
          e1(e, n, K, q)
        } else {
          if (typeof q != 'string' && n.stateNode === null)
            throw new Error(
              'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
            )
          var re = JE(),
            De = rb(),
            je = ah(n)
          je ? T5(n) && Ou(n) : (n.stateNode = h2(q, re, De, n))
        }
        return Sr(n), null
      }
      case j: {
        Ru(n)
        var Fe = n.memoizedState
        if (e === null || (e.memoizedState !== null && e.memoizedState.dehydrated !== null)) {
          var St = IF(e, n, Fe)
          if (!St) return n.flags & Vr ? n : null
        }
        if ((n.flags & Lt) !== Ve) return (n.lanes = i), (n.mode & Yt) !== Ie && Pb(n), n
        var ht = Fe !== null,
          H = e !== null && e.memoizedState !== null
        if (ht !== H && ht) {
          var ae = n.child
          if (((ae.flags |= Xs), (n.mode & yt) !== Ie)) {
            var W = e === null && (n.memoizedProps.unstable_avoidThisFallback !== !0 || !qe)
            W || ib(ii.current, nT) ? HN() : m0()
          }
        }
        var fe = n.updateQueue
        if ((fe !== null && (n.flags |= Tt), Sr(n), (n.mode & Yt) !== Ie && ht)) {
          var Ae = n.child
          Ae !== null && (n.treeBaseDuration -= Ae.treeBaseDuration)
        }
        return null
      }
      case C:
        return Eu(n), Qb(e, n), e === null && s5(n.stateNode.containerInfo), Sr(n), null
      case z:
        var we = n.type._context
        return My(we, n), Sr(n), null
      case he: {
        var Ye = n.type
        return ki(Ye) && Zp(n), Sr(n), null
      }
      case pe: {
        Ru(n)
        var tt = n.memoizedState
        if (tt === null) return Sr(n), null
        var qt = (n.flags & Lt) !== Ve,
          Dt = tt.rendering
        if (Dt === null)
          if (qt) Pf(tt, !1)
          else {
            var Bn = YN() && (e === null || (e.flags & Lt) === Ve)
            if (!Bn)
              for (var At = n.child; At !== null; ) {
                var zn = xh(At)
                if (zn !== null) {
                  ;(qt = !0), (n.flags |= Lt), Pf(tt, !1)
                  var Lr = zn.updateQueue
                  return (
                    Lr !== null && ((n.updateQueue = Lr), (n.flags |= Tt)),
                    (n.subtreeFlags = Ve),
                    Y5(n, i),
                    ss(n, ob(ii.current, Cf)),
                    n.child
                  )
                }
                At = At.sibling
              }
            tt.tail !== null &&
              dr() > C1() &&
              ((n.flags |= Lt), (qt = !0), Pf(tt, !1), (n.lanes = JC))
          }
        else {
          if (!qt) {
            var Tr = xh(Dt)
            if (Tr !== null) {
              ;(n.flags |= Lt), (qt = !0)
              var _a = Tr.updateQueue
              if (
                (_a !== null && ((n.updateQueue = _a), (n.flags |= Tt)),
                Pf(tt, !0),
                tt.tail === null && tt.tailMode === 'hidden' && !Dt.alternate && !yr())
              )
                return Sr(n), null
            } else
              dr() * 2 - tt.renderingStartTime > C1() &&
                i !== Sa &&
                ((n.flags |= Lt), (qt = !0), Pf(tt, !1), (n.lanes = JC))
          }
          if (tt.isBackwards) (Dt.sibling = n.child), (n.child = Dt)
          else {
            var Yr = tt.last
            Yr !== null ? (Yr.sibling = Dt) : (n.child = Dt), (tt.last = Dt)
          }
        }
        if (tt.tail !== null) {
          var Gr = tt.tail
          ;(tt.rendering = Gr),
            (tt.tail = Gr.sibling),
            (tt.renderingStartTime = dr()),
            (Gr.sibling = null)
          var zr = ii.current
          return qt ? (zr = ob(zr, Cf)) : (zr = Tu(zr)), ss(n, zr), Gr
        }
        return Sr(n), null
      }
      case Ne:
        break
      case me:
      case ge: {
        h0(n)
        var wo = n.memoizedState,
          Bu = wo !== null
        if (e !== null) {
          var Kf = e.memoizedState,
            $i = Kf !== null
          $i !== Bu && !rt && (n.flags |= Xs)
        }
        return (
          !Bu || (n.mode & yt) === Ie
            ? Sr(n)
            : xa(zi, Sa) && (Sr(n), n.subtreeFlags & (In | Tt) && (n.flags |= Xs)),
          null
        )
      }
      case Oe:
        return null
      case ze:
        return null
    }
    throw new Error(
      'Unknown unit of work tag (' +
        n.tag +
        '). This error is likely caused by a bug in React. Please file an issue.'
    )
  }
  function HF(e, n, i) {
    switch ((wy(n), n.tag)) {
      case m: {
        var s = n.type
        ki(s) && Zp(n)
        var u = n.flags
        return u & Vr ? ((n.flags = (u & ~Vr) | Lt), (n.mode & Yt) !== Ie && Pb(n), n) : null
      }
      case b: {
        n.stateNode, Eu(n), by(n), lb()
        var d = n.flags
        return (d & Vr) !== Ve && (d & Lt) === Ve ? ((n.flags = (d & ~Vr) | Lt), n) : null
      }
      case w:
        return ab(n), null
      case j: {
        Ru(n)
        var v = n.memoizedState
        if (v !== null && v.dehydrated !== null) {
          if (n.alternate === null)
            throw new Error(
              'Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.'
            )
          Su()
        }
        var y = n.flags
        return y & Vr ? ((n.flags = (y & ~Vr) | Lt), (n.mode & Yt) !== Ie && Pb(n), n) : null
      }
      case pe:
        return Ru(n), null
      case C:
        return Eu(n), null
      case z:
        var x = n.type._context
        return My(x, n), null
      case me:
      case ge:
        return h0(n), null
      case Oe:
        return null
      default:
        return null
    }
  }
  function n1(e, n, i) {
    switch ((wy(n), n.tag)) {
      case m: {
        var s = n.type.childContextTypes
        s != null && Zp(n)
        break
      }
      case b: {
        n.stateNode, Eu(n), by(n), lb()
        break
      }
      case w: {
        ab(n)
        break
      }
      case C:
        Eu(n)
        break
      case j:
        Ru(n)
        break
      case pe:
        Ru(n)
        break
      case z:
        var u = n.type._context
        My(u, n)
        break
      case me:
      case ge:
        h0(n)
        break
    }
  }
  var r1 = null
  r1 = new Set()
  var Hh = !1,
    xr = !1,
    WF = typeof WeakSet == 'function' ? WeakSet : Set,
    Le = null,
    Mu = null,
    Pu = null
  function YF(e) {
    Jv(null, function () {
      throw e
    }),
      eg()
  }
  var GF = function (e, n) {
    if (((n.props = e.memoizedProps), (n.state = e.memoizedState), e.mode & Yt))
      try {
        Pi(), n.componentWillUnmount()
      } finally {
        Mi(e)
      }
    else n.componentWillUnmount()
  }
  function a1(e, n) {
    try {
      cs(er, e)
    } catch (i) {
      pn(e, n, i)
    }
  }
  function Zb(e, n, i) {
    try {
      GF(e, i)
    } catch (s) {
      pn(e, n, s)
    }
  }
  function qF(e, n, i) {
    try {
      i.componentDidMount()
    } catch (s) {
      pn(e, n, s)
    }
  }
  function i1(e, n) {
    try {
      s1(e)
    } catch (i) {
      pn(e, n, i)
    }
  }
  function Lu(e, n) {
    var i = e.ref
    if (i !== null)
      if (typeof i == 'function') {
        var s
        try {
          if (Rt && an && e.mode & Yt)
            try {
              Pi(), (s = i(null))
            } finally {
              Mi(e)
            }
          else s = i(null)
        } catch (u) {
          pn(e, n, u)
        }
        typeof s == 'function' &&
          c(
            'Unexpected return value from a callback ref in %s. A callback ref should not return a function.',
            nt(e)
          )
      } else i.current = null
  }
  function Wh(e, n, i) {
    try {
      i()
    } catch (s) {
      pn(e, n, s)
    }
  }
  var o1 = !1
  function KF(e, n) {
    l2(e.containerInfo), (Le = n), XF()
    var i = o1
    return (o1 = !1), i
  }
  function XF() {
    for (; Le !== null; ) {
      var e = Le,
        n = e.child
      ;(e.subtreeFlags & ig) !== Ve && n !== null ? ((n.return = e), (Le = n)) : QF()
    }
  }
  function QF() {
    for (; Le !== null; ) {
      var e = Le
      mn(e)
      try {
        ZF(e)
      } catch (i) {
        pn(e, e.return, i)
      }
      Un()
      var n = e.sibling
      if (n !== null) {
        ;(n.return = e.return), (Le = n)
        return
      }
      Le = e.return
    }
  }
  function ZF(e) {
    var n = e.alternate,
      i = e.flags
    if ((i & Ks) !== Ve) {
      switch ((mn(e), e.tag)) {
        case h:
        case P:
        case Y:
          break
        case m: {
          if (n !== null) {
            var s = n.memoizedProps,
              u = n.memoizedState,
              d = e.stateNode
            e.type === e.elementType &&
              !vl &&
              (d.props !== e.memoizedProps &&
                c(
                  'Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                  nt(e) || 'instance'
                ),
              d.state !== e.memoizedState &&
                c(
                  'Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
                  nt(e) || 'instance'
                ))
            var v = d.getSnapshotBeforeUpdate(e.elementType === e.type ? s : ai(e.type, s), u)
            {
              var y = r1
              v === void 0 &&
                !y.has(e.type) &&
                (y.add(e.type),
                c(
                  '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.',
                  nt(e)
                ))
            }
            d.__reactInternalSnapshotBeforeUpdate = v
          }
          break
        }
        case b: {
          {
            var x = e.stateNode
            P2(x.containerInfo)
          }
          break
        }
        case w:
        case k:
        case C:
        case he:
          break
        default:
          throw new Error(
            'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
          )
      }
      Un()
    }
  }
  function li(e, n, i) {
    var s = n.updateQueue,
      u = s !== null ? s.lastEffect : null
    if (u !== null) {
      var d = u.next,
        v = d
      do {
        if ((v.tag & e) === e) {
          var y = v.destroy
          ;(v.destroy = void 0),
            y !== void 0 &&
              ((e & br) !== oa ? hL(n) : (e & er) !== oa && qC(n),
              (e & Di) !== oa && Yf(!0),
              Wh(n, i, y),
              (e & Di) !== oa && Yf(!1),
              (e & br) !== oa ? mL() : (e & er) !== oa && KC())
        }
        v = v.next
      } while (v !== d)
    }
  }
  function cs(e, n) {
    var i = n.updateQueue,
      s = i !== null ? i.lastEffect : null
    if (s !== null) {
      var u = s.next,
        d = u
      do {
        if ((d.tag & e) === e) {
          ;(e & br) !== oa ? dL(n) : (e & er) !== oa && vL(n)
          var v = d.create
          ;(e & Di) !== oa && Yf(!0),
            (d.destroy = v()),
            (e & Di) !== oa && Yf(!1),
            (e & br) !== oa ? pL() : (e & er) !== oa && gL()
          {
            var y = d.destroy
            if (y !== void 0 && typeof y != 'function') {
              var x = void 0
              ;(d.tag & er) !== Ve
                ? (x = 'useLayoutEffect')
                : (d.tag & Di) !== Ve
                ? (x = 'useInsertionEffect')
                : (x = 'useEffect')
              var T = void 0
              y === null
                ? (T =
                    ' You returned null. If your effect does not require clean up, return undefined (or nothing).')
                : typeof y.then == 'function'
                ? (T =
                    `

It looks like you wrote ` +
                    x +
                    `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` +
                    x +
                    `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching`)
                : (T = ' You returned: ' + y),
                c(
                  '%s must not return anything besides a function, which is used for clean-up.%s',
                  x,
                  T
                )
            }
          }
        }
        d = d.next
      } while (d !== u)
    }
  }
  function JF(e, n) {
    if ((n.flags & Tt) !== Ve)
      switch (n.tag) {
        case B: {
          var i = n.stateNode.passiveEffectDuration,
            s = n.memoizedProps,
            u = s.id,
            d = s.onPostCommit,
            v = kT(),
            y = n.alternate === null ? 'mount' : 'update'
          _T() && (y = 'nested-update'), typeof d == 'function' && d(u, y, i, v)
          var x = n.return
          e: for (; x !== null; ) {
            switch (x.tag) {
              case b:
                var T = x.stateNode
                T.passiveEffectDuration += i
                break e
              case B:
                var _ = x.stateNode
                _.passiveEffectDuration += i
                break e
            }
            x = x.return
          }
          break
        }
      }
  }
  function eN(e, n, i, s) {
    if ((i.flags & Dc) !== Ve)
      switch (i.tag) {
        case h:
        case P:
        case Y: {
          if (!xr)
            if (i.mode & Yt)
              try {
                Pi(), cs(er | Jn, i)
              } finally {
                Mi(i)
              }
            else cs(er | Jn, i)
          break
        }
        case m: {
          var u = i.stateNode
          if (i.flags & Tt && !xr)
            if (n === null)
              if (
                (i.type === i.elementType &&
                  !vl &&
                  (u.props !== i.memoizedProps &&
                    c(
                      'Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                      nt(i) || 'instance'
                    ),
                  u.state !== i.memoizedState &&
                    c(
                      'Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
                      nt(i) || 'instance'
                    )),
                i.mode & Yt)
              )
                try {
                  Pi(), u.componentDidMount()
                } finally {
                  Mi(i)
                }
              else u.componentDidMount()
            else {
              var d = i.elementType === i.type ? n.memoizedProps : ai(i.type, n.memoizedProps),
                v = n.memoizedState
              if (
                (i.type === i.elementType &&
                  !vl &&
                  (u.props !== i.memoizedProps &&
                    c(
                      'Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                      nt(i) || 'instance'
                    ),
                  u.state !== i.memoizedState &&
                    c(
                      'Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
                      nt(i) || 'instance'
                    )),
                i.mode & Yt)
              )
                try {
                  Pi(), u.componentDidUpdate(d, v, u.__reactInternalSnapshotBeforeUpdate)
                } finally {
                  Mi(i)
                }
              else u.componentDidUpdate(d, v, u.__reactInternalSnapshotBeforeUpdate)
            }
          var y = i.updateQueue
          y !== null &&
            (i.type === i.elementType &&
              !vl &&
              (u.props !== i.memoizedProps &&
                c(
                  'Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                  nt(i) || 'instance'
                ),
              u.state !== i.memoizedState &&
                c(
                  'Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
                  nt(i) || 'instance'
                )),
            UE(i, y, u))
          break
        }
        case b: {
          var x = i.updateQueue
          if (x !== null) {
            var T = null
            if (i.child !== null)
              switch (i.child.tag) {
                case w:
                  T = i.child.stateNode
                  break
                case m:
                  T = i.child.stateNode
                  break
              }
            UE(i, x, T)
          }
          break
        }
        case w: {
          var _ = i.stateNode
          if (n === null && i.flags & Tt) {
            var N = i.type,
              $ = i.memoizedProps
            b2(_, N, $)
          }
          break
        }
        case k:
          break
        case C:
          break
        case B: {
          {
            var q = i.memoizedProps,
              K = q.onCommit,
              re = q.onRender,
              De = i.stateNode.effectDuration,
              je = kT(),
              Fe = n === null ? 'mount' : 'update'
            _T() && (Fe = 'nested-update'),
              typeof re == 'function' &&
                re(
                  i.memoizedProps.id,
                  Fe,
                  i.actualDuration,
                  i.treeBaseDuration,
                  i.actualStartTime,
                  je
                )
            {
              typeof K == 'function' && K(i.memoizedProps.id, Fe, De, je), QN(i)
              var St = i.return
              e: for (; St !== null; ) {
                switch (St.tag) {
                  case b:
                    var ht = St.stateNode
                    ht.effectDuration += De
                    break e
                  case B:
                    var H = St.stateNode
                    H.effectDuration += De
                    break e
                }
                St = St.return
              }
            }
          }
          break
        }
        case j: {
          lN(e, i)
          break
        }
        case pe:
        case he:
        case Ne:
        case me:
        case ge:
        case ze:
          break
        default:
          throw new Error(
            'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
          )
      }
    xr || (i.flags & Go && s1(i))
  }
  function tN(e) {
    switch (e.tag) {
      case h:
      case P:
      case Y: {
        if (e.mode & Yt)
          try {
            Pi(), a1(e, e.return)
          } finally {
            Mi(e)
          }
        else a1(e, e.return)
        break
      }
      case m: {
        var n = e.stateNode
        typeof n.componentDidMount == 'function' && qF(e, e.return, n), i1(e, e.return)
        break
      }
      case w: {
        i1(e, e.return)
        break
      }
    }
  }
  function nN(e, n) {
    for (var i = null, s = e; ; ) {
      if (s.tag === w) {
        if (i === null) {
          i = s
          try {
            var u = s.stateNode
            n ? D2(u) : O2(s.stateNode, s.memoizedProps)
          } catch (v) {
            pn(e, e.return, v)
          }
        }
      } else if (s.tag === k) {
        if (i === null)
          try {
            var d = s.stateNode
            n ? A2(d) : M2(d, s.memoizedProps)
          } catch (v) {
            pn(e, e.return, v)
          }
      } else if (!((s.tag === me || s.tag === ge) && s.memoizedState !== null && s !== e)) {
        if (s.child !== null) {
          ;(s.child.return = s), (s = s.child)
          continue
        }
      }
      if (s === e) return
      for (; s.sibling === null; ) {
        if (s.return === null || s.return === e) return
        i === s && (i = null), (s = s.return)
      }
      i === s && (i = null), (s.sibling.return = s.return), (s = s.sibling)
    }
  }
  function s1(e) {
    var n = e.ref
    if (n !== null) {
      var i = e.stateNode,
        s
      switch (e.tag) {
        case w:
          s = i
          break
        default:
          s = i
      }
      if (typeof n == 'function') {
        var u
        if (e.mode & Yt)
          try {
            Pi(), (u = n(s))
          } finally {
            Mi(e)
          }
        else u = n(s)
        typeof u == 'function' &&
          c(
            'Unexpected return value from a callback ref in %s. A callback ref should not return a function.',
            nt(e)
          )
      } else
        n.hasOwnProperty('current') ||
          c(
            'Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().',
            nt(e)
          ),
          (n.current = s)
    }
  }
  function rN(e) {
    var n = e.alternate
    n !== null && (n.return = null), (e.return = null)
  }
  function l1(e) {
    var n = e.alternate
    n !== null && ((e.alternate = null), l1(n))
    {
      if (((e.child = null), (e.deletions = null), (e.sibling = null), e.tag === w)) {
        var i = e.stateNode
        i !== null && c5(i)
      }
      ;(e.stateNode = null),
        (e._debugOwner = null),
        (e.return = null),
        (e.dependencies = null),
        (e.memoizedProps = null),
        (e.memoizedState = null),
        (e.pendingProps = null),
        (e.stateNode = null),
        (e.updateQueue = null)
    }
  }
  function aN(e) {
    for (var n = e.return; n !== null; ) {
      if (u1(n)) return n
      n = n.return
    }
    throw new Error(
      'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
    )
  }
  function u1(e) {
    return e.tag === w || e.tag === b || e.tag === C
  }
  function c1(e) {
    var n = e
    e: for (;;) {
      for (; n.sibling === null; ) {
        if (n.return === null || u1(n.return)) return null
        n = n.return
      }
      for (
        n.sibling.return = n.return, n = n.sibling;
        n.tag !== w && n.tag !== k && n.tag !== le;

      ) {
        if (n.flags & In || n.child === null || n.tag === C) continue e
        ;(n.child.return = n), (n = n.child)
      }
      if (!(n.flags & In)) return n.stateNode
    }
  }
  function iN(e) {
    var n = aN(e)
    switch (n.tag) {
      case w: {
        var i = n.stateNode
        n.flags & _c && (fE(i), (n.flags &= ~_c))
        var s = c1(e)
        e0(e, s, i)
        break
      }
      case b:
      case C: {
        var u = n.stateNode.containerInfo,
          d = c1(e)
        Jb(e, d, u)
        break
      }
      default:
        throw new Error(
          'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.'
        )
    }
  }
  function Jb(e, n, i) {
    var s = e.tag,
      u = s === w || s === k
    if (u) {
      var d = e.stateNode
      n ? T2(i, d, n) : w2(i, d)
    } else if (s !== C) {
      var v = e.child
      if (v !== null) {
        Jb(v, n, i)
        for (var y = v.sibling; y !== null; ) Jb(y, n, i), (y = y.sibling)
      }
    }
  }
  function e0(e, n, i) {
    var s = e.tag,
      u = s === w || s === k
    if (u) {
      var d = e.stateNode
      n ? E2(i, d, n) : C2(i, d)
    } else if (s !== C) {
      var v = e.child
      if (v !== null) {
        e0(v, n, i)
        for (var y = v.sibling; y !== null; ) e0(y, n, i), (y = y.sibling)
      }
    }
  }
  var Cr = null,
    ui = !1
  function oN(e, n, i) {
    {
      var s = n
      e: for (; s !== null; ) {
        switch (s.tag) {
          case w: {
            ;(Cr = s.stateNode), (ui = !1)
            break e
          }
          case b: {
            ;(Cr = s.stateNode.containerInfo), (ui = !0)
            break e
          }
          case C: {
            ;(Cr = s.stateNode.containerInfo), (ui = !0)
            break e
          }
        }
        s = s.return
      }
      if (Cr === null)
        throw new Error(
          'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
        )
      f1(e, n, i), (Cr = null), (ui = !1)
    }
    rN(i)
  }
  function fs(e, n, i) {
    for (var s = i.child; s !== null; ) f1(e, n, s), (s = s.sibling)
  }
  function f1(e, n, i) {
    switch ((lL(i), i.tag)) {
      case w:
        xr || Lu(i, n)
      case k: {
        {
          var s = Cr,
            u = ui
          ;(Cr = null),
            fs(e, n, i),
            (Cr = s),
            (ui = u),
            Cr !== null && (ui ? _2(Cr, i.stateNode) : R2(Cr, i.stateNode))
        }
        return
      }
      case le: {
        Cr !== null && (ui ? k2(Cr, i.stateNode) : fy(Cr, i.stateNode))
        return
      }
      case C: {
        {
          var d = Cr,
            v = ui
          ;(Cr = i.stateNode.containerInfo), (ui = !0), fs(e, n, i), (Cr = d), (ui = v)
        }
        return
      }
      case h:
      case P:
      case Q:
      case Y: {
        if (!xr) {
          var y = i.updateQueue
          if (y !== null) {
            var x = y.lastEffect
            if (x !== null) {
              var T = x.next,
                _ = T
              do {
                var N = _,
                  $ = N.destroy,
                  q = N.tag
                $ !== void 0 &&
                  ((q & Di) !== oa
                    ? Wh(i, n, $)
                    : (q & er) !== oa &&
                      (qC(i), i.mode & Yt ? (Pi(), Wh(i, n, $), Mi(i)) : Wh(i, n, $), KC())),
                  (_ = _.next)
              } while (_ !== T)
            }
          }
        }
        fs(e, n, i)
        return
      }
      case m: {
        if (!xr) {
          Lu(i, n)
          var K = i.stateNode
          typeof K.componentWillUnmount == 'function' && Zb(i, n, K)
        }
        fs(e, n, i)
        return
      }
      case Ne: {
        fs(e, n, i)
        return
      }
      case me: {
        if (i.mode & yt) {
          var re = xr
          ;(xr = re || i.memoizedState !== null), fs(e, n, i), (xr = re)
        } else fs(e, n, i)
        break
      }
      default: {
        fs(e, n, i)
        return
      }
    }
  }
  function sN(e) {
    e.memoizedState
  }
  function lN(e, n) {
    var i = n.memoizedState
    if (i === null) {
      var s = n.alternate
      if (s !== null) {
        var u = s.memoizedState
        if (u !== null) {
          var d = u.dehydrated
          d !== null && G2(d)
        }
      }
    }
  }
  function d1(e) {
    var n = e.updateQueue
    if (n !== null) {
      e.updateQueue = null
      var i = e.stateNode
      i === null && (i = e.stateNode = new WF()),
        n.forEach(function (s) {
          var u = aB.bind(null, e, s)
          if (!i.has(s)) {
            if ((i.add(s), Ja))
              if (Mu !== null && Pu !== null) Wf(Pu, Mu)
              else
                throw Error('Expected finished root and lanes to be set. This is a bug in React.')
            s.then(u, u)
          }
        })
    }
  }
  function uN(e, n, i) {
    ;(Mu = i), (Pu = e), mn(n), p1(n, e), mn(n), (Mu = null), (Pu = null)
  }
  function ci(e, n, i) {
    var s = n.deletions
    if (s !== null)
      for (var u = 0; u < s.length; u++) {
        var d = s[u]
        try {
          oN(e, n, d)
        } catch (x) {
          pn(d, n, x)
        }
      }
    var v = Wo()
    if (n.subtreeFlags & og) for (var y = n.child; y !== null; ) mn(y), p1(y, e), (y = y.sibling)
    mn(v)
  }
  function p1(e, n, i) {
    var s = e.alternate,
      u = e.flags
    switch (e.tag) {
      case h:
      case P:
      case Q:
      case Y: {
        if ((ci(n, e), Li(e), u & Tt)) {
          try {
            li(Di | Jn, e, e.return), cs(Di | Jn, e)
          } catch (Ye) {
            pn(e, e.return, Ye)
          }
          if (e.mode & Yt) {
            try {
              Pi(), li(er | Jn, e, e.return)
            } catch (Ye) {
              pn(e, e.return, Ye)
            }
            Mi(e)
          } else
            try {
              li(er | Jn, e, e.return)
            } catch (Ye) {
              pn(e, e.return, Ye)
            }
        }
        return
      }
      case m: {
        ci(n, e), Li(e), u & Go && s !== null && Lu(s, s.return)
        return
      }
      case w: {
        ci(n, e), Li(e), u & Go && s !== null && Lu(s, s.return)
        {
          if (e.flags & _c) {
            var d = e.stateNode
            try {
              fE(d)
            } catch (Ye) {
              pn(e, e.return, Ye)
            }
          }
          if (u & Tt) {
            var v = e.stateNode
            if (v != null) {
              var y = e.memoizedProps,
                x = s !== null ? s.memoizedProps : y,
                T = e.type,
                _ = e.updateQueue
              if (((e.updateQueue = null), _ !== null))
                try {
                  S2(v, _, T, x, y, e)
                } catch (Ye) {
                  pn(e, e.return, Ye)
                }
            }
          }
        }
        return
      }
      case k: {
        if ((ci(n, e), Li(e), u & Tt)) {
          if (e.stateNode === null)
            throw new Error(
              'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'
            )
          var N = e.stateNode,
            $ = e.memoizedProps,
            q = s !== null ? s.memoizedProps : $
          try {
            x2(N, q, $)
          } catch (Ye) {
            pn(e, e.return, Ye)
          }
        }
        return
      }
      case b: {
        if ((ci(n, e), Li(e), u & Tt && s !== null)) {
          var K = s.memoizedState
          if (K.isDehydrated)
            try {
              Y2(n.containerInfo)
            } catch (Ye) {
              pn(e, e.return, Ye)
            }
        }
        return
      }
      case C: {
        ci(n, e), Li(e)
        return
      }
      case j: {
        ci(n, e), Li(e)
        var re = e.child
        if (re.flags & Xs) {
          var De = re.stateNode,
            je = re.memoizedState,
            Fe = je !== null
          if (((De.isHidden = Fe), Fe)) {
            var St = re.alternate !== null && re.alternate.memoizedState !== null
            St || IN()
          }
        }
        if (u & Tt) {
          try {
            sN(e)
          } catch (Ye) {
            pn(e, e.return, Ye)
          }
          d1(e)
        }
        return
      }
      case me: {
        var ht = s !== null && s.memoizedState !== null
        if (e.mode & yt) {
          var H = xr
          ;(xr = H || ht), ci(n, e), (xr = H)
        } else ci(n, e)
        if ((Li(e), u & Xs)) {
          var ae = e.stateNode,
            W = e.memoizedState,
            fe = W !== null,
            Ae = e
          if (((ae.isHidden = fe), fe && !ht && (Ae.mode & yt) !== Ie)) {
            Le = Ae
            for (var we = Ae.child; we !== null; ) (Le = we), fN(we), (we = we.sibling)
          }
          nN(Ae, fe)
        }
        return
      }
      case pe: {
        ci(n, e), Li(e), u & Tt && d1(e)
        return
      }
      case Ne:
        return
      default: {
        ci(n, e), Li(e)
        return
      }
    }
  }
  function Li(e) {
    var n = e.flags
    if (n & In) {
      try {
        iN(e)
      } catch (i) {
        pn(e, e.return, i)
      }
      e.flags &= ~In
    }
    n & io && (e.flags &= ~io)
  }
  function cN(e, n, i) {
    ;(Mu = i), (Pu = n), (Le = e), h1(e, n, i), (Mu = null), (Pu = null)
  }
  function h1(e, n, i) {
    for (var s = (e.mode & yt) !== Ie; Le !== null; ) {
      var u = Le,
        d = u.child
      if (u.tag === me && s) {
        var v = u.memoizedState !== null,
          y = v || Hh
        if (y) {
          t0(e, n, i)
          continue
        } else {
          var x = u.alternate,
            T = x !== null && x.memoizedState !== null,
            _ = T || xr,
            N = Hh,
            $ = xr
          ;(Hh = y), (xr = _), xr && !$ && ((Le = u), dN(u))
          for (var q = d; q !== null; ) (Le = q), h1(q, n, i), (q = q.sibling)
          ;(Le = u), (Hh = N), (xr = $), t0(e, n, i)
          continue
        }
      }
      ;(u.subtreeFlags & Dc) !== Ve && d !== null ? ((d.return = u), (Le = d)) : t0(e, n, i)
    }
  }
  function t0(e, n, i) {
    for (; Le !== null; ) {
      var s = Le
      if ((s.flags & Dc) !== Ve) {
        var u = s.alternate
        mn(s)
        try {
          eN(n, u, s, i)
        } catch (v) {
          pn(s, s.return, v)
        }
        Un()
      }
      if (s === e) {
        Le = null
        return
      }
      var d = s.sibling
      if (d !== null) {
        ;(d.return = s.return), (Le = d)
        return
      }
      Le = s.return
    }
  }
  function fN(e) {
    for (; Le !== null; ) {
      var n = Le,
        i = n.child
      switch (n.tag) {
        case h:
        case P:
        case Q:
        case Y: {
          if (n.mode & Yt)
            try {
              Pi(), li(er, n, n.return)
            } finally {
              Mi(n)
            }
          else li(er, n, n.return)
          break
        }
        case m: {
          Lu(n, n.return)
          var s = n.stateNode
          typeof s.componentWillUnmount == 'function' && Zb(n, n.return, s)
          break
        }
        case w: {
          Lu(n, n.return)
          break
        }
        case me: {
          var u = n.memoizedState !== null
          if (u) {
            m1(e)
            continue
          }
          break
        }
      }
      i !== null ? ((i.return = n), (Le = i)) : m1(e)
    }
  }
  function m1(e) {
    for (; Le !== null; ) {
      var n = Le
      if (n === e) {
        Le = null
        return
      }
      var i = n.sibling
      if (i !== null) {
        ;(i.return = n.return), (Le = i)
        return
      }
      Le = n.return
    }
  }
  function dN(e) {
    for (; Le !== null; ) {
      var n = Le,
        i = n.child
      if (n.tag === me) {
        var s = n.memoizedState !== null
        if (s) {
          v1(e)
          continue
        }
      }
      i !== null ? ((i.return = n), (Le = i)) : v1(e)
    }
  }
  function v1(e) {
    for (; Le !== null; ) {
      var n = Le
      mn(n)
      try {
        tN(n)
      } catch (s) {
        pn(n, n.return, s)
      }
      if ((Un(), n === e)) {
        Le = null
        return
      }
      var i = n.sibling
      if (i !== null) {
        ;(i.return = n.return), (Le = i)
        return
      }
      Le = n.return
    }
  }
  function pN(e, n, i, s) {
    ;(Le = n), hN(n, e, i, s)
  }
  function hN(e, n, i, s) {
    for (; Le !== null; ) {
      var u = Le,
        d = u.child
      ;(u.subtreeFlags & eu) !== Ve && d !== null ? ((d.return = u), (Le = d)) : mN(e, n, i, s)
    }
  }
  function mN(e, n, i, s) {
    for (; Le !== null; ) {
      var u = Le
      if ((u.flags & Za) !== Ve) {
        mn(u)
        try {
          vN(n, u, i, s)
        } catch (v) {
          pn(u, u.return, v)
        }
        Un()
      }
      if (u === e) {
        Le = null
        return
      }
      var d = u.sibling
      if (d !== null) {
        ;(d.return = u.return), (Le = d)
        return
      }
      Le = u.return
    }
  }
  function vN(e, n, i, s) {
    switch (n.tag) {
      case h:
      case P:
      case Y: {
        if (n.mode & Yt) {
          Mb()
          try {
            cs(br | Jn, n)
          } finally {
            Ob(n)
          }
        } else cs(br | Jn, n)
        break
      }
    }
  }
  function gN(e) {
    ;(Le = e), yN()
  }
  function yN() {
    for (; Le !== null; ) {
      var e = Le,
        n = e.child
      if ((Le.flags & qs) !== Ve) {
        var i = e.deletions
        if (i !== null) {
          for (var s = 0; s < i.length; s++) {
            var u = i[s]
            ;(Le = u), xN(u, e)
          }
          {
            var d = e.alternate
            if (d !== null) {
              var v = d.child
              if (v !== null) {
                d.child = null
                do {
                  var y = v.sibling
                  ;(v.sibling = null), (v = y)
                } while (v !== null)
              }
            }
          }
          Le = e
        }
      }
      ;(e.subtreeFlags & eu) !== Ve && n !== null ? ((n.return = e), (Le = n)) : bN()
    }
  }
  function bN() {
    for (; Le !== null; ) {
      var e = Le
      ;(e.flags & Za) !== Ve && (mn(e), SN(e), Un())
      var n = e.sibling
      if (n !== null) {
        ;(n.return = e.return), (Le = n)
        return
      }
      Le = e.return
    }
  }
  function SN(e) {
    switch (e.tag) {
      case h:
      case P:
      case Y: {
        e.mode & Yt ? (Mb(), li(br | Jn, e, e.return), Ob(e)) : li(br | Jn, e, e.return)
        break
      }
    }
  }
  function xN(e, n) {
    for (; Le !== null; ) {
      var i = Le
      mn(i), wN(i, n), Un()
      var s = i.child
      s !== null ? ((s.return = i), (Le = s)) : CN(e)
    }
  }
  function CN(e) {
    for (; Le !== null; ) {
      var n = Le,
        i = n.sibling,
        s = n.return
      if ((l1(n), n === e)) {
        Le = null
        return
      }
      if (i !== null) {
        ;(i.return = s), (Le = i)
        return
      }
      Le = s
    }
  }
  function wN(e, n) {
    switch (e.tag) {
      case h:
      case P:
      case Y: {
        e.mode & Yt ? (Mb(), li(br, e, n), Ob(e)) : li(br, e, n)
        break
      }
    }
  }
  function EN(e) {
    switch (e.tag) {
      case h:
      case P:
      case Y: {
        try {
          cs(er | Jn, e)
        } catch (i) {
          pn(e, e.return, i)
        }
        break
      }
      case m: {
        var n = e.stateNode
        try {
          n.componentDidMount()
        } catch (i) {
          pn(e, e.return, i)
        }
        break
      }
    }
  }
  function TN(e) {
    switch (e.tag) {
      case h:
      case P:
      case Y: {
        try {
          cs(br | Jn, e)
        } catch (n) {
          pn(e, e.return, n)
        }
        break
      }
    }
  }
  function RN(e) {
    switch (e.tag) {
      case h:
      case P:
      case Y: {
        try {
          li(er | Jn, e, e.return)
        } catch (i) {
          pn(e, e.return, i)
        }
        break
      }
      case m: {
        var n = e.stateNode
        typeof n.componentWillUnmount == 'function' && Zb(e, e.return, n)
        break
      }
    }
  }
  function _N(e) {
    switch (e.tag) {
      case h:
      case P:
      case Y:
        try {
          li(br | Jn, e, e.return)
        } catch (n) {
          pn(e, e.return, n)
        }
    }
  }
  if (typeof Symbol == 'function' && Symbol.for) {
    var Lf = Symbol.for
    Lf('selector.component'),
      Lf('selector.has_pseudo_class'),
      Lf('selector.role'),
      Lf('selector.test_id'),
      Lf('selector.text')
  }
  var kN = []
  function DN() {
    kN.forEach(function (e) {
      return e()
    })
  }
  var AN = a.ReactCurrentActQueue
  function ON(e) {
    {
      var n = typeof IS_REACT_ACT_ENVIRONMENT < 'u' ? IS_REACT_ACT_ENVIRONMENT : void 0,
        i = typeof jest < 'u'
      return i && n !== !1
    }
  }
  function g1() {
    {
      var e = typeof IS_REACT_ACT_ENVIRONMENT < 'u' ? IS_REACT_ACT_ENVIRONMENT : void 0
      return (
        !e &&
          AN.current !== null &&
          c('The current testing environment is not configured to support act(...)'),
        e
      )
    }
  }
  var MN = Math.ceil,
    n0 = a.ReactCurrentDispatcher,
    r0 = a.ReactCurrentOwner,
    wr = a.ReactCurrentBatchConfig,
    fi = a.ReactCurrentActQueue,
    rr = 0,
    y1 = 1,
    Er = 2,
    Ua = 4,
    bo = 0,
    zf = 1,
    gl = 2,
    Yh = 3,
    $f = 4,
    b1 = 5,
    a0 = 6,
    bt = rr,
    Hr = null,
    Dn = null,
    ar = ue,
    zi = ue,
    i0 = ts(ue),
    ir = bo,
    Ff = null,
    Gh = ue,
    Nf = ue,
    qh = ue,
    Bf = null,
    sa = null,
    o0 = 0,
    S1 = 500,
    x1 = 1 / 0,
    PN = 500,
    So = null
  function jf() {
    x1 = dr() + PN
  }
  function C1() {
    return x1
  }
  var Kh = !1,
    s0 = null,
    zu = null,
    yl = !1,
    ds = null,
    Uf = ue,
    l0 = [],
    u0 = null,
    LN = 50,
    Vf = 0,
    c0 = null,
    f0 = !1,
    Xh = !1,
    zN = 50,
    $u = 0,
    Qh = null,
    If = vn,
    Zh = ue,
    w1 = !1
  function Jh() {
    return Hr
  }
  function Wr() {
    return (bt & (Er | Ua)) !== rr ? dr() : (If !== vn || (If = dr()), If)
  }
  function ps(e) {
    var n = e.mode
    if ((n & yt) === Ie) return Ze
    if ((bt & Er) !== rr && ar !== ue) return $c(ar)
    var i = O5() !== A5
    if (i) {
      if (wr.transition !== null) {
        var s = wr.transition
        s._updatedFibers || (s._updatedFibers = new Set()), s._updatedFibers.add(e)
      }
      return Zh === hr && (Zh = rw()), Zh
    }
    var u = ei()
    if (u !== hr) return u
    var d = m2()
    return d
  }
  function $N(e) {
    var n = e.mode
    return (n & yt) === Ie ? Ze : BL()
  }
  function or(e, n, i, s) {
    oB(),
      w1 && c('useInsertionEffect must not schedule updates.'),
      f0 && (Xh = !0),
      Fc(e, i, s),
      (bt & Er) !== ue && e === Hr
        ? uB(n)
        : (Ja && ow(e, n, i),
          cB(n),
          e === Hr && ((bt & Er) === rr && (Nf = lt(Nf, i)), ir === $f && hs(e, ar)),
          la(e, s),
          i === Ze && bt === rr && (n.mode & yt) === Ie && !fi.isBatchingLegacy && (jf(), CE()))
  }
  function FN(e, n, i) {
    var s = e.current
    ;(s.lanes = n), Fc(e, n, i), la(e, i)
  }
  function NN(e) {
    return (bt & Er) !== rr
  }
  function la(e, n) {
    var i = e.callbackNode
    PL(e, n)
    var s = Sp(e, e === Hr ? ar : ue)
    if (s === ue) {
      i !== null && B1(i), (e.callbackNode = null), (e.callbackPriority = hr)
      return
    }
    var u = nl(s),
      d = e.callbackPriority
    if (d === u && !(fi.current !== null && i !== y0)) {
      i == null &&
        d !== Ze &&
        c(
          'Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.'
        )
      return
    }
    i != null && B1(i)
    var v
    if (u === Ze)
      e.tag === ns
        ? (fi.isBatchingLegacy !== null && (fi.didScheduleLegacyUpdate = !0), p5(R1.bind(null, e)))
        : xE(R1.bind(null, e)),
        fi.current !== null
          ? fi.current.push(rs)
          : g2(function () {
              ;(bt & (Er | Ua)) === rr && rs()
            }),
        (v = null)
    else {
      var y
      switch (uw(s)) {
        case Ca:
          y = vp
          break
        case uo:
          y = sg
          break
        case co:
          y = Js
          break
        case wp:
          y = lg
          break
        default:
          y = Js
          break
      }
      v = b0(y, E1.bind(null, e))
    }
    ;(e.callbackPriority = u), (e.callbackNode = v)
  }
  function E1(e, n) {
    if ((oF(), (If = vn), (Zh = ue), (bt & (Er | Ua)) !== rr))
      throw new Error('Should not already be working.')
    var i = e.callbackNode,
      s = Co()
    if (s && e.callbackNode !== i) return null
    var u = Sp(e, e === Hr ? ar : ue)
    if (u === ue) return null
    var d = !xp(e, u) && !NL(e, u) && !n,
      v = d ? qN(e, u) : tm(e, u)
    if (v !== bo) {
      if (v === gl) {
        var y = Ag(e)
        y !== ue && ((u = y), (v = d0(e, y)))
      }
      if (v === zf) {
        var x = Ff
        throw (bl(e, ue), hs(e, u), la(e, dr()), x)
      }
      if (v === a0) hs(e, u)
      else {
        var T = !xp(e, u),
          _ = e.current.alternate
        if (T && !jN(_)) {
          if (((v = tm(e, u)), v === gl)) {
            var N = Ag(e)
            N !== ue && ((u = N), (v = d0(e, N)))
          }
          if (v === zf) {
            var $ = Ff
            throw (bl(e, ue), hs(e, u), la(e, dr()), $)
          }
        }
        ;(e.finishedWork = _), (e.finishedLanes = u), BN(e, v, u)
      }
    }
    return la(e, dr()), e.callbackNode === i ? E1.bind(null, e) : null
  }
  function d0(e, n) {
    var i = Bf
    if (Ep(e)) {
      var s = bl(e, n)
      ;(s.flags |= ao), o5(e.containerInfo)
    }
    var u = tm(e, n)
    if (u !== gl) {
      var d = sa
      ;(sa = i), d !== null && T1(d)
    }
    return u
  }
  function T1(e) {
    sa === null ? (sa = e) : sa.push.apply(sa, e)
  }
  function BN(e, n, i) {
    switch (n) {
      case bo:
      case zf:
        throw new Error('Root did not complete. This is a bug in React.')
      case gl: {
        Sl(e, sa, So)
        break
      }
      case Yh: {
        if ((hs(e, i), tw(i) && !j1())) {
          var s = o0 + S1 - dr()
          if (s > 10) {
            var u = Sp(e, ue)
            if (u !== ue) break
            var d = e.suspendedLanes
            if (!ou(d, i)) {
              Wr(), iw(e, d)
              break
            }
            e.timeoutHandle = uy(Sl.bind(null, e, sa, So), s)
            break
          }
        }
        Sl(e, sa, So)
        break
      }
      case $f: {
        if ((hs(e, i), FL(i))) break
        if (!j1()) {
          var v = OL(e, i),
            y = v,
            x = dr() - y,
            T = iB(x) - x
          if (T > 10) {
            e.timeoutHandle = uy(Sl.bind(null, e, sa, So), T)
            break
          }
        }
        Sl(e, sa, So)
        break
      }
      case b1: {
        Sl(e, sa, So)
        break
      }
      default:
        throw new Error('Unknown root exit status.')
    }
  }
  function jN(e) {
    for (var n = e; ; ) {
      if (n.flags & hp) {
        var i = n.updateQueue
        if (i !== null) {
          var s = i.stores
          if (s !== null)
            for (var u = 0; u < s.length; u++) {
              var d = s[u],
                v = d.getSnapshot,
                y = d.value
              try {
                if (!Ea(v(), y)) return !1
              } catch {
                return !1
              }
            }
        }
      }
      var x = n.child
      if (n.subtreeFlags & hp && x !== null) {
        ;(x.return = n), (n = x)
        continue
      }
      if (n === e) return !0
      for (; n.sibling === null; ) {
        if (n.return === null || n.return === e) return !0
        n = n.return
      }
      ;(n.sibling.return = n.return), (n = n.sibling)
    }
    return !0
  }
  function hs(e, n) {
    ;(n = Cp(n, qh)), (n = Cp(n, Nf)), UL(e, n)
  }
  function R1(e) {
    if ((sF(), (bt & (Er | Ua)) !== rr)) throw new Error('Should not already be working.')
    Co()
    var n = Sp(e, ue)
    if (!xa(n, Ze)) return la(e, dr()), null
    var i = tm(e, n)
    if (e.tag !== ns && i === gl) {
      var s = Ag(e)
      s !== ue && ((n = s), (i = d0(e, s)))
    }
    if (i === zf) {
      var u = Ff
      throw (bl(e, ue), hs(e, n), la(e, dr()), u)
    }
    if (i === a0) throw new Error('Root did not complete. This is a bug in React.')
    var d = e.current.alternate
    return (e.finishedWork = d), (e.finishedLanes = n), Sl(e, sa, So), la(e, dr()), null
  }
  function UN(e, n) {
    n !== ue && (Lg(e, lt(n, Ze)), la(e, dr()), (bt & (Er | Ua)) === rr && (jf(), rs()))
  }
  function p0(e, n) {
    var i = bt
    bt |= y1
    try {
      return e(n)
    } finally {
      ;(bt = i), bt === rr && !fi.isBatchingLegacy && (jf(), CE())
    }
  }
  function VN(e, n, i, s, u) {
    var d = ei(),
      v = wr.transition
    try {
      return (wr.transition = null), mr(Ca), e(n, i, s, u)
    } finally {
      mr(d), (wr.transition = v), bt === rr && jf()
    }
  }
  function xo(e) {
    ds !== null && ds.tag === ns && (bt & (Er | Ua)) === rr && Co()
    var n = bt
    bt |= y1
    var i = wr.transition,
      s = ei()
    try {
      return (wr.transition = null), mr(Ca), e ? e() : void 0
    } finally {
      mr(s), (wr.transition = i), (bt = n), (bt & (Er | Ua)) === rr && rs()
    }
  }
  function _1() {
    return (bt & (Er | Ua)) !== rr
  }
  function em(e, n) {
    Mr(i0, zi, e), (zi = lt(zi, n))
  }
  function h0(e) {
    ;(zi = i0.current), Or(i0, e)
  }
  function bl(e, n) {
    ;(e.finishedWork = null), (e.finishedLanes = ue)
    var i = e.timeoutHandle
    if ((i !== cy && ((e.timeoutHandle = cy), v2(i)), Dn !== null))
      for (var s = Dn.return; s !== null; ) {
        var u = s.alternate
        n1(u, s), (s = s.return)
      }
    Hr = e
    var d = xl(e.current, null)
    return (
      (Dn = d),
      (ar = zi = n),
      (ir = bo),
      (Ff = null),
      (Gh = ue),
      (Nf = ue),
      (qh = ue),
      (Bf = null),
      (sa = null),
      z5(),
      ri.discardPendingWarnings(),
      d
    )
  }
  function k1(e, n) {
    do {
      var i = Dn
      try {
        if ((lh(), aT(), Un(), (r0.current = null), i === null || i.return === null)) {
          ;(ir = zf), (Ff = n), (Dn = null)
          return
        }
        if ((Rt && i.mode & Yt && jh(i, !0), Mt))
          if ((nu(), n !== null && typeof n == 'object' && typeof n.then == 'function')) {
            var s = n
            bL(i, s, ar)
          } else yL(i, n, ar)
        dF(e, i.return, i, n, ar), M1(i)
      } catch (u) {
        ;(n = u), Dn === i && i !== null ? ((i = i.return), (Dn = i)) : (i = Dn)
        continue
      }
      return
    } while (!0)
  }
  function D1() {
    var e = n0.current
    return (n0.current = zh), e === null ? zh : e
  }
  function A1(e) {
    n0.current = e
  }
  function IN() {
    o0 = dr()
  }
  function Hf(e) {
    Gh = lt(e, Gh)
  }
  function HN() {
    ir === bo && (ir = Yh)
  }
  function m0() {
    ;(ir === bo || ir === Yh || ir === gl) && (ir = $f),
      Hr !== null && (Og(Gh) || Og(Nf)) && hs(Hr, ar)
  }
  function WN(e) {
    ir !== $f && (ir = gl), Bf === null ? (Bf = [e]) : Bf.push(e)
  }
  function YN() {
    return ir === bo
  }
  function tm(e, n) {
    var i = bt
    bt |= Er
    var s = D1()
    if (Hr !== e || ar !== n) {
      if (Ja) {
        var u = e.memoizedUpdaters
        u.size > 0 && (Wf(e, ar), u.clear()), sw(e, n)
      }
      ;(So = lw()), bl(e, n)
    }
    XC(n)
    do
      try {
        GN()
        break
      } catch (d) {
        k1(e, d)
      }
    while (!0)
    if ((lh(), (bt = i), A1(s), Dn !== null))
      throw new Error(
        'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.'
      )
    return QC(), (Hr = null), (ar = ue), ir
  }
  function GN() {
    for (; Dn !== null; ) O1(Dn)
  }
  function qN(e, n) {
    var i = bt
    bt |= Er
    var s = D1()
    if (Hr !== e || ar !== n) {
      if (Ja) {
        var u = e.memoizedUpdaters
        u.size > 0 && (Wf(e, ar), u.clear()), sw(e, n)
      }
      ;(So = lw()), jf(), bl(e, n)
    }
    XC(n)
    do
      try {
        KN()
        break
      } catch (d) {
        k1(e, d)
      }
    while (!0)
    return lh(), A1(s), (bt = i), Dn !== null ? (EL(), bo) : (QC(), (Hr = null), (ar = ue), ir)
  }
  function KN() {
    for (; Dn !== null && !ZP(); ) O1(Dn)
  }
  function O1(e) {
    var n = e.alternate
    mn(e)
    var i
    ;(e.mode & Yt) !== Ie ? (Ab(e), (i = v0(n, e, zi)), jh(e, !0)) : (i = v0(n, e, zi)),
      Un(),
      (e.memoizedProps = e.pendingProps),
      i === null ? M1(e) : (Dn = i),
      (r0.current = null)
  }
  function M1(e) {
    var n = e
    do {
      var i = n.alternate,
        s = n.return
      if ((n.flags & kc) === Ve) {
        mn(n)
        var u = void 0
        if (
          ((n.mode & Yt) === Ie ? (u = t1(i, n, zi)) : (Ab(n), (u = t1(i, n, zi)), jh(n, !1)),
          Un(),
          u !== null)
        ) {
          Dn = u
          return
        }
      } else {
        var d = HF(i, n)
        if (d !== null) {
          ;(d.flags &= YP), (Dn = d)
          return
        }
        if ((n.mode & Yt) !== Ie) {
          jh(n, !1)
          for (var v = n.actualDuration, y = n.child; y !== null; )
            (v += y.actualDuration), (y = y.sibling)
          n.actualDuration = v
        }
        if (s !== null) (s.flags |= kc), (s.subtreeFlags = Ve), (s.deletions = null)
        else {
          ;(ir = a0), (Dn = null)
          return
        }
      }
      var x = n.sibling
      if (x !== null) {
        Dn = x
        return
      }
      ;(n = s), (Dn = n)
    } while (n !== null)
    ir === bo && (ir = b1)
  }
  function Sl(e, n, i) {
    var s = ei(),
      u = wr.transition
    try {
      ;(wr.transition = null), mr(Ca), XN(e, n, i, s)
    } finally {
      ;(wr.transition = u), mr(s)
    }
    return null
  }
  function XN(e, n, i, s) {
    do Co()
    while (ds !== null)
    if ((sB(), (bt & (Er | Ua)) !== rr)) throw new Error('Should not already be working.')
    var u = e.finishedWork,
      d = e.finishedLanes
    if ((fL(d), u === null)) return GC(), null
    if (
      (d === ue &&
        c('root.finishedLanes should not be empty during a commit. This is a bug in React.'),
      (e.finishedWork = null),
      (e.finishedLanes = ue),
      u === e.current)
    )
      throw new Error(
        'Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.'
      )
    ;(e.callbackNode = null), (e.callbackPriority = hr)
    var v = lt(u.lanes, u.childLanes)
    VL(e, v),
      e === Hr && ((Hr = null), (Dn = null), (ar = ue)),
      ((u.subtreeFlags & eu) !== Ve || (u.flags & eu) !== Ve) &&
        (yl ||
          ((yl = !0),
          (u0 = i),
          b0(Js, function () {
            return Co(), null
          })))
    var y = (u.subtreeFlags & (ig | og | Dc | eu)) !== Ve,
      x = (u.flags & (ig | og | Dc | eu)) !== Ve
    if (y || x) {
      var T = wr.transition
      wr.transition = null
      var _ = ei()
      mr(Ca)
      var N = bt
      ;(bt |= Ua),
        (r0.current = null),
        KF(e, u),
        DT(),
        uN(e, u, d),
        u2(e.containerInfo),
        (e.current = u),
        SL(d),
        cN(u, e, d),
        xL(),
        JP(),
        (bt = N),
        mr(_),
        (wr.transition = T)
    } else (e.current = u), DT()
    var $ = yl
    if (
      (yl ? ((yl = !1), (ds = e), (Uf = d)) : (($u = 0), (Qh = null)),
      (v = e.pendingLanes),
      v === ue && (zu = null),
      $ || $1(e.current, !1),
      oL(u.stateNode, s),
      Ja && e.memoizedUpdaters.clear(),
      DN(),
      la(e, dr()),
      n !== null)
    )
      for (var q = e.onRecoverableError, K = 0; K < n.length; K++) {
        var re = n[K],
          De = re.stack,
          je = re.digest
        q(re.value, { componentStack: De, digest: je })
      }
    if (Kh) {
      Kh = !1
      var Fe = s0
      throw ((s0 = null), Fe)
    }
    return (
      xa(Uf, Ze) && e.tag !== ns && Co(),
      (v = e.pendingLanes),
      xa(v, Ze) ? (iF(), e === c0 ? Vf++ : ((Vf = 0), (c0 = e))) : (Vf = 0),
      rs(),
      GC(),
      null
    )
  }
  function Co() {
    if (ds !== null) {
      var e = uw(Uf),
        n = YL(co, e),
        i = wr.transition,
        s = ei()
      try {
        return (wr.transition = null), mr(n), ZN()
      } finally {
        mr(s), (wr.transition = i)
      }
    }
    return !1
  }
  function QN(e) {
    l0.push(e),
      yl ||
        ((yl = !0),
        b0(Js, function () {
          return Co(), null
        }))
  }
  function ZN() {
    if (ds === null) return !1
    var e = u0
    u0 = null
    var n = ds,
      i = Uf
    if (((ds = null), (Uf = ue), (bt & (Er | Ua)) !== rr))
      throw new Error('Cannot flush passive effects while already rendering.')
    ;(f0 = !0), (Xh = !1), CL(i)
    var s = bt
    ;(bt |= Ua), gN(n.current), pN(n, n.current, i, e)
    {
      var u = l0
      l0 = []
      for (var d = 0; d < u.length; d++) {
        var v = u[d]
        JF(n, v)
      }
    }
    wL(),
      $1(n.current, !0),
      (bt = s),
      rs(),
      Xh ? (n === Qh ? $u++ : (($u = 0), (Qh = n))) : ($u = 0),
      (f0 = !1),
      (Xh = !1),
      sL(n)
    {
      var y = n.current.stateNode
      ;(y.effectDuration = 0), (y.passiveEffectDuration = 0)
    }
    return !0
  }
  function P1(e) {
    return zu !== null && zu.has(e)
  }
  function JN(e) {
    zu === null ? (zu = new Set([e])) : zu.add(e)
  }
  function eB(e) {
    Kh || ((Kh = !0), (s0 = e))
  }
  var tB = eB
  function L1(e, n, i) {
    var s = ml(i, n),
      u = OT(e, s, Ze),
      d = is(e, u, Ze),
      v = Wr()
    d !== null && (Fc(d, Ze, v), la(d, v))
  }
  function pn(e, n, i) {
    if ((YF(i), Yf(!1), e.tag === b)) {
      L1(e, e, i)
      return
    }
    var s = null
    for (s = n; s !== null; ) {
      if (s.tag === b) {
        L1(s, e, i)
        return
      } else if (s.tag === m) {
        var u = s.type,
          d = s.stateNode
        if (
          typeof u.getDerivedStateFromError == 'function' ||
          (typeof d.componentDidCatch == 'function' && !P1(d))
        ) {
          var v = ml(i, e),
            y = $b(s, v, Ze),
            x = is(s, y, Ze),
            T = Wr()
          x !== null && (Fc(x, Ze, T), la(x, T))
          return
        }
      }
      s = s.return
    }
    c(
      `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
      i
    )
  }
  function nB(e, n, i) {
    var s = e.pingCache
    s !== null && s.delete(n)
    var u = Wr()
    iw(e, i),
      fB(e),
      Hr === e &&
        ou(ar, i) &&
        (ir === $f || (ir === Yh && tw(ar) && dr() - o0 < S1) ? bl(e, ue) : (qh = lt(qh, i))),
      la(e, u)
  }
  function z1(e, n) {
    n === hr && (n = $N(e))
    var i = Wr(),
      s = ia(e, n)
    s !== null && (Fc(s, n, i), la(s, i))
  }
  function rB(e) {
    var n = e.memoizedState,
      i = hr
    n !== null && (i = n.retryLane), z1(e, i)
  }
  function aB(e, n) {
    var i = hr,
      s
    switch (e.tag) {
      case j:
        s = e.stateNode
        var u = e.memoizedState
        u !== null && (i = u.retryLane)
        break
      case pe:
        s = e.stateNode
        break
      default:
        throw new Error('Pinged unknown suspense boundary type. This is probably a bug in React.')
    }
    s !== null && s.delete(n), z1(e, i)
  }
  function iB(e) {
    return e < 120
      ? 120
      : e < 480
      ? 480
      : e < 1080
      ? 1080
      : e < 1920
      ? 1920
      : e < 3e3
      ? 3e3
      : e < 4320
      ? 4320
      : MN(e / 1960) * 1960
  }
  function oB() {
    if (Vf > LN)
      throw (
        ((Vf = 0),
        (c0 = null),
        new Error(
          'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.'
        ))
      )
    $u > zN &&
      (($u = 0),
      (Qh = null),
      c(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      ))
  }
  function sB() {
    ri.flushLegacyContextWarning(), ri.flushPendingUnsafeLifecycleWarnings()
  }
  function $1(e, n) {
    mn(e), nm(e, oo, RN), n && nm(e, mp, _N), nm(e, oo, EN), n && nm(e, mp, TN), Un()
  }
  function nm(e, n, i) {
    for (var s = e, u = null; s !== null; ) {
      var d = s.subtreeFlags & n
      s !== u && s.child !== null && d !== Ve
        ? (s = s.child)
        : ((s.flags & n) !== Ve && i(s), s.sibling !== null ? (s = s.sibling) : (s = u = s.return))
    }
  }
  var rm = null
  function F1(e) {
    {
      if ((bt & Er) !== rr || !(e.mode & yt)) return
      var n = e.tag
      if (n !== g && n !== b && n !== m && n !== h && n !== P && n !== Q && n !== Y) return
      var i = nt(e) || 'ReactComponent'
      if (rm !== null) {
        if (rm.has(i)) return
        rm.add(i)
      } else rm = new Set([i])
      var s = Nn
      try {
        mn(e),
          c(
            "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
          )
      } finally {
        s ? mn(e) : Un()
      }
    }
  }
  var v0
  {
    var lB = null
    v0 = function (e, n, i) {
      var s = W1(lB, n)
      try {
        return XT(e, n, i)
      } catch (d) {
        if (x5() || (d !== null && typeof d == 'object' && typeof d.then == 'function')) throw d
        if (
          (lh(), aT(), n1(e, n), W1(n, s), n.mode & Yt && Ab(n), Jv(null, XT, null, e, n, i), VP())
        ) {
          var u = eg()
          typeof u == 'object' &&
            u !== null &&
            u._suppressLogging &&
            typeof d == 'object' &&
            d !== null &&
            !d._suppressLogging &&
            (d._suppressLogging = !0)
        }
        throw d
      }
    }
  }
  var N1 = !1,
    g0
  g0 = new Set()
  function uB(e) {
    if (Xa && !nF())
      switch (e.tag) {
        case h:
        case P:
        case Y: {
          var n = (Dn && nt(Dn)) || 'Unknown',
            i = n
          if (!g0.has(i)) {
            g0.add(i)
            var s = nt(e) || 'Unknown'
            c(
              'Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render',
              s,
              n,
              n
            )
          }
          break
        }
        case m: {
          N1 ||
            (c(
              'Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.'
            ),
            (N1 = !0))
          break
        }
      }
  }
  function Wf(e, n) {
    if (Ja) {
      var i = e.memoizedUpdaters
      i.forEach(function (s) {
        ow(e, s, n)
      })
    }
  }
  var y0 = {}
  function b0(e, n) {
    {
      var i = fi.current
      return i !== null ? (i.push(n), y0) : YC(e, n)
    }
  }
  function B1(e) {
    if (e !== y0) return QP(e)
  }
  function j1() {
    return fi.current !== null
  }
  function cB(e) {
    {
      if (e.mode & yt) {
        if (!g1()) return
      } else if (!ON() || bt !== rr || (e.tag !== h && e.tag !== P && e.tag !== Y)) return
      if (fi.current === null) {
        var n = Nn
        try {
          mn(e),
            c(
              `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`,
              nt(e)
            )
        } finally {
          n ? mn(e) : Un()
        }
      }
    }
  }
  function fB(e) {
    e.tag !== ns &&
      g1() &&
      fi.current === null &&
      c(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`)
  }
  function Yf(e) {
    w1 = e
  }
  var Va = null,
    Fu = null,
    dB = function (e) {
      Va = e
    }
  function Nu(e) {
    {
      if (Va === null) return e
      var n = Va(e)
      return n === void 0 ? e : n.current
    }
  }
  function S0(e) {
    return Nu(e)
  }
  function x0(e) {
    {
      if (Va === null) return e
      var n = Va(e)
      if (n === void 0) {
        if (e != null && typeof e.render == 'function') {
          var i = Nu(e.render)
          if (e.render !== i) {
            var s = { $$typeof: ke, render: i }
            return e.displayName !== void 0 && (s.displayName = e.displayName), s
          }
        }
        return e
      }
      return n.current
    }
  }
  function U1(e, n) {
    {
      if (Va === null) return !1
      var i = e.elementType,
        s = n.type,
        u = !1,
        d = typeof s == 'object' && s !== null ? s.$$typeof : null
      switch (e.tag) {
        case m: {
          typeof s == 'function' && (u = !0)
          break
        }
        case h: {
          ;(typeof s == 'function' || d === Be) && (u = !0)
          break
        }
        case P: {
          ;(d === ke || d === Be) && (u = !0)
          break
        }
        case Q:
        case Y: {
          ;(d === at || d === Be) && (u = !0)
          break
        }
        default:
          return !1
      }
      if (u) {
        var v = Va(i)
        if (v !== void 0 && v === Va(s)) return !0
      }
      return !1
    }
  }
  function V1(e) {
    {
      if (Va === null || typeof WeakSet != 'function') return
      Fu === null && (Fu = new WeakSet()), Fu.add(e)
    }
  }
  var pB = function (e, n) {
      {
        if (Va === null) return
        var i = n.staleFamilies,
          s = n.updatedFamilies
        Co(),
          xo(function () {
            C0(e.current, s, i)
          })
      }
    },
    hB = function (e, n) {
      {
        if (e.context !== Ta) return
        Co(),
          xo(function () {
            Gf(n, e, null, null)
          })
      }
    }
  function C0(e, n, i) {
    {
      var s = e.alternate,
        u = e.child,
        d = e.sibling,
        v = e.tag,
        y = e.type,
        x = null
      switch (v) {
        case h:
        case Y:
        case m:
          x = y
          break
        case P:
          x = y.render
          break
      }
      if (Va === null) throw new Error('Expected resolveFamily to be set during hot reload.')
      var T = !1,
        _ = !1
      if (x !== null) {
        var N = Va(x)
        N !== void 0 && (i.has(N) ? (_ = !0) : n.has(N) && (v === m ? (_ = !0) : (T = !0)))
      }
      if (
        (Fu !== null && (Fu.has(e) || (s !== null && Fu.has(s))) && (_ = !0),
        _ && (e._debugNeedsRemount = !0),
        _ || T)
      ) {
        var $ = ia(e, Ze)
        $ !== null && or($, e, Ze, vn)
      }
      u !== null && !_ && C0(u, n, i), d !== null && C0(d, n, i)
    }
  }
  var mB = function (e, n) {
    {
      var i = new Set(),
        s = new Set(
          n.map(function (u) {
            return u.current
          })
        )
      return w0(e.current, s, i), i
    }
  }
  function w0(e, n, i) {
    {
      var s = e.child,
        u = e.sibling,
        d = e.tag,
        v = e.type,
        y = null
      switch (d) {
        case h:
        case Y:
        case m:
          y = v
          break
        case P:
          y = v.render
          break
      }
      var x = !1
      y !== null && n.has(y) && (x = !0),
        x ? vB(e, i) : s !== null && w0(s, n, i),
        u !== null && w0(u, n, i)
    }
  }
  function vB(e, n) {
    {
      var i = gB(e, n)
      if (i) return
      for (var s = e; ; ) {
        switch (s.tag) {
          case w:
            n.add(s.stateNode)
            return
          case C:
            n.add(s.stateNode.containerInfo)
            return
          case b:
            n.add(s.stateNode.containerInfo)
            return
        }
        if (s.return === null) throw new Error('Expected to reach root first.')
        s = s.return
      }
    }
  }
  function gB(e, n) {
    for (var i = e, s = !1; ; ) {
      if (i.tag === w) (s = !0), n.add(i.stateNode)
      else if (i.child !== null) {
        ;(i.child.return = i), (i = i.child)
        continue
      }
      if (i === e) return s
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === e) return s
        i = i.return
      }
      ;(i.sibling.return = i.return), (i = i.sibling)
    }
    return !1
  }
  var E0
  {
    E0 = !1
    try {
      var I1 = Object.preventExtensions({})
    } catch {
      E0 = !0
    }
  }
  function yB(e, n, i, s) {
    ;(this.tag = e),
      (this.key = i),
      (this.elementType = null),
      (this.type = null),
      (this.stateNode = null),
      (this.return = null),
      (this.child = null),
      (this.sibling = null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = n),
      (this.memoizedProps = null),
      (this.updateQueue = null),
      (this.memoizedState = null),
      (this.dependencies = null),
      (this.mode = s),
      (this.flags = Ve),
      (this.subtreeFlags = Ve),
      (this.deletions = null),
      (this.lanes = ue),
      (this.childLanes = ue),
      (this.alternate = null),
      (this.actualDuration = Number.NaN),
      (this.actualStartTime = Number.NaN),
      (this.selfBaseDuration = Number.NaN),
      (this.treeBaseDuration = Number.NaN),
      (this.actualDuration = 0),
      (this.actualStartTime = -1),
      (this.selfBaseDuration = 0),
      (this.treeBaseDuration = 0),
      (this._debugSource = null),
      (this._debugOwner = null),
      (this._debugNeedsRemount = !1),
      (this._debugHookTypes = null),
      !E0 && typeof Object.preventExtensions == 'function' && Object.preventExtensions(this)
  }
  var Ra = function (e, n, i, s) {
    return new yB(e, n, i, s)
  }
  function T0(e) {
    var n = e.prototype
    return !!(n && n.isReactComponent)
  }
  function bB(e) {
    return typeof e == 'function' && !T0(e) && e.defaultProps === void 0
  }
  function SB(e) {
    if (typeof e == 'function') return T0(e) ? m : h
    if (e != null) {
      var n = e.$$typeof
      if (n === ke) return P
      if (n === at) return Q
    }
    return g
  }
  function xl(e, n) {
    var i = e.alternate
    i === null
      ? ((i = Ra(e.tag, n, e.key, e.mode)),
        (i.elementType = e.elementType),
        (i.type = e.type),
        (i.stateNode = e.stateNode),
        (i._debugSource = e._debugSource),
        (i._debugOwner = e._debugOwner),
        (i._debugHookTypes = e._debugHookTypes),
        (i.alternate = e),
        (e.alternate = i))
      : ((i.pendingProps = n),
        (i.type = e.type),
        (i.flags = Ve),
        (i.subtreeFlags = Ve),
        (i.deletions = null),
        (i.actualDuration = 0),
        (i.actualStartTime = -1)),
      (i.flags = e.flags & so),
      (i.childLanes = e.childLanes),
      (i.lanes = e.lanes),
      (i.child = e.child),
      (i.memoizedProps = e.memoizedProps),
      (i.memoizedState = e.memoizedState),
      (i.updateQueue = e.updateQueue)
    var s = e.dependencies
    switch (
      ((i.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }),
      (i.sibling = e.sibling),
      (i.index = e.index),
      (i.ref = e.ref),
      (i.selfBaseDuration = e.selfBaseDuration),
      (i.treeBaseDuration = e.treeBaseDuration),
      (i._debugNeedsRemount = e._debugNeedsRemount),
      i.tag)
    ) {
      case g:
      case h:
      case Y:
        i.type = Nu(e.type)
        break
      case m:
        i.type = S0(e.type)
        break
      case P:
        i.type = x0(e.type)
        break
    }
    return i
  }
  function xB(e, n) {
    e.flags &= so | In
    var i = e.alternate
    if (i === null)
      (e.childLanes = ue),
        (e.lanes = n),
        (e.child = null),
        (e.subtreeFlags = Ve),
        (e.memoizedProps = null),
        (e.memoizedState = null),
        (e.updateQueue = null),
        (e.dependencies = null),
        (e.stateNode = null),
        (e.selfBaseDuration = 0),
        (e.treeBaseDuration = 0)
    else {
      ;(e.childLanes = i.childLanes),
        (e.lanes = i.lanes),
        (e.child = i.child),
        (e.subtreeFlags = Ve),
        (e.deletions = null),
        (e.memoizedProps = i.memoizedProps),
        (e.memoizedState = i.memoizedState),
        (e.updateQueue = i.updateQueue),
        (e.type = i.type)
      var s = i.dependencies
      ;(e.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }),
        (e.selfBaseDuration = i.selfBaseDuration),
        (e.treeBaseDuration = i.treeBaseDuration)
    }
    return e
  }
  function CB(e, n, i) {
    var s
    return (
      e === eh ? ((s = yt), n === !0 && ((s |= Hn), (s |= Ti))) : (s = Ie),
      Ja && (s |= Yt),
      Ra(b, null, null, s)
    )
  }
  function R0(e, n, i, s, u, d) {
    var v = g,
      y = e
    if (typeof e == 'function') T0(e) ? ((v = m), (y = S0(y))) : (y = Nu(y))
    else if (typeof e == 'string') v = w
    else
      e: switch (e) {
        case ea:
          return ms(i.children, u, d, n)
        case Tn:
          ;(v = E), (u |= Hn), (u & yt) !== Ie && (u |= Ti)
          break
        case L:
          return wB(i, u, d, n)
        case dt:
          return EB(i, u, d, n)
        case ct:
          return TB(i, u, d, n)
        case cn:
          return H1(i, u, d, n)
        case fr:
        case Fn:
        case ta:
        case Bo:
        case un:
        default: {
          if (typeof e == 'object' && e !== null)
            switch (e.$$typeof) {
              case se:
                v = z
                break e
              case ve:
                v = M
                break e
              case ke:
                ;(v = P), (y = x0(y))
                break e
              case at:
                v = Q
                break e
              case Be:
                ;(v = ne), (y = null)
                break e
            }
          var x = ''
          {
            ;(e === void 0 ||
              (typeof e == 'object' && e !== null && Object.keys(e).length === 0)) &&
              (x +=
                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.")
            var T = s ? nt(s) : null
            T &&
              (x +=
                `

Check the render method of \`` +
                T +
                '`.')
          }
          throw new Error(
            'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) ' +
              ('but got: ' + (e == null ? e : typeof e) + '.' + x)
          )
        }
      }
    var _ = Ra(v, i, n, u)
    return (_.elementType = e), (_.type = y), (_.lanes = d), (_._debugOwner = s), _
  }
  function _0(e, n, i) {
    var s = null
    s = e._owner
    var u = e.type,
      d = e.key,
      v = e.props,
      y = R0(u, d, v, s, n, i)
    return (y._debugSource = e._source), (y._debugOwner = e._owner), y
  }
  function ms(e, n, i, s) {
    var u = Ra(D, e, s, n)
    return (u.lanes = i), u
  }
  function wB(e, n, i, s) {
    typeof e.id != 'string' &&
      c(
        'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
        typeof e.id
      )
    var u = Ra(B, e, s, n | Yt)
    return (
      (u.elementType = L),
      (u.lanes = i),
      (u.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }),
      u
    )
  }
  function EB(e, n, i, s) {
    var u = Ra(j, e, s, n)
    return (u.elementType = dt), (u.lanes = i), u
  }
  function TB(e, n, i, s) {
    var u = Ra(pe, e, s, n)
    return (u.elementType = ct), (u.lanes = i), u
  }
  function H1(e, n, i, s) {
    var u = Ra(me, e, s, n)
    ;(u.elementType = cn), (u.lanes = i)
    var d = { isHidden: !1 }
    return (u.stateNode = d), u
  }
  function k0(e, n, i) {
    var s = Ra(k, e, null, n)
    return (s.lanes = i), s
  }
  function RB() {
    var e = Ra(w, null, null, Ie)
    return (e.elementType = 'DELETED'), e
  }
  function _B(e) {
    var n = Ra(le, null, null, Ie)
    return (n.stateNode = e), n
  }
  function D0(e, n, i) {
    var s = e.children !== null ? e.children : [],
      u = Ra(C, s, e.key, n)
    return (
      (u.lanes = i),
      (u.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        implementation: e.implementation,
      }),
      u
    )
  }
  function W1(e, n) {
    return (
      e === null && (e = Ra(g, null, null, Ie)),
      (e.tag = n.tag),
      (e.key = n.key),
      (e.elementType = n.elementType),
      (e.type = n.type),
      (e.stateNode = n.stateNode),
      (e.return = n.return),
      (e.child = n.child),
      (e.sibling = n.sibling),
      (e.index = n.index),
      (e.ref = n.ref),
      (e.pendingProps = n.pendingProps),
      (e.memoizedProps = n.memoizedProps),
      (e.updateQueue = n.updateQueue),
      (e.memoizedState = n.memoizedState),
      (e.dependencies = n.dependencies),
      (e.mode = n.mode),
      (e.flags = n.flags),
      (e.subtreeFlags = n.subtreeFlags),
      (e.deletions = n.deletions),
      (e.lanes = n.lanes),
      (e.childLanes = n.childLanes),
      (e.alternate = n.alternate),
      (e.actualDuration = n.actualDuration),
      (e.actualStartTime = n.actualStartTime),
      (e.selfBaseDuration = n.selfBaseDuration),
      (e.treeBaseDuration = n.treeBaseDuration),
      (e._debugSource = n._debugSource),
      (e._debugOwner = n._debugOwner),
      (e._debugNeedsRemount = n._debugNeedsRemount),
      (e._debugHookTypes = n._debugHookTypes),
      e
    )
  }
  function kB(e, n, i, s, u) {
    ;(this.tag = n),
      (this.containerInfo = e),
      (this.pendingChildren = null),
      (this.current = null),
      (this.pingCache = null),
      (this.finishedWork = null),
      (this.timeoutHandle = cy),
      (this.context = null),
      (this.pendingContext = null),
      (this.callbackNode = null),
      (this.callbackPriority = hr),
      (this.eventTimes = Pg(ue)),
      (this.expirationTimes = Pg(vn)),
      (this.pendingLanes = ue),
      (this.suspendedLanes = ue),
      (this.pingedLanes = ue),
      (this.expiredLanes = ue),
      (this.mutableReadLanes = ue),
      (this.finishedLanes = ue),
      (this.entangledLanes = ue),
      (this.entanglements = Pg(ue)),
      (this.identifierPrefix = s),
      (this.onRecoverableError = u),
      (this.mutableSourceEagerHydrationData = null),
      (this.effectDuration = 0),
      (this.passiveEffectDuration = 0)
    {
      this.memoizedUpdaters = new Set()
      for (var d = (this.pendingUpdatersLaneMap = []), v = 0; v < cg; v++) d.push(new Set())
    }
    switch (n) {
      case eh:
        this._debugRootType = i ? 'hydrateRoot()' : 'createRoot()'
        break
      case ns:
        this._debugRootType = i ? 'hydrate()' : 'render()'
        break
    }
  }
  function Y1(e, n, i, s, u, d, v, y, x, T) {
    var _ = new kB(e, n, i, y, x),
      N = CB(n, d)
    ;(_.current = N), (N.stateNode = _)
    {
      var $ = {
        element: s,
        isDehydrated: i,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }
      N.memoizedState = $
    }
    return Fy(N), _
  }
  var A0 = '18.2.0'
  function DB(e, n, i) {
    var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null
    return (
      Xn(s),
      {
        $$typeof: jr,
        key: s == null ? null : '' + s,
        children: e,
        containerInfo: n,
        implementation: i,
      }
    )
  }
  var O0, M0
  ;(O0 = !1), (M0 = {})
  function G1(e) {
    if (!e) return Ta
    var n = Zl(e),
      i = d5(n)
    if (n.tag === m) {
      var s = n.type
      if (ki(s)) return bE(n, s, i)
    }
    return i
  }
  function AB(e, n) {
    {
      var i = Zl(e)
      if (i === void 0) {
        if (typeof e.render == 'function')
          throw new Error('Unable to find node on an unmounted component.')
        var s = Object.keys(e).join(',')
        throw new Error('Argument appears to not be a ReactComponent. Keys: ' + s)
      }
      var u = IC(i)
      if (u === null) return null
      if (u.mode & Hn) {
        var d = nt(i) || 'Component'
        if (!M0[d]) {
          M0[d] = !0
          var v = Nn
          try {
            mn(u),
              i.mode & Hn
                ? c(
                    '%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node',
                    n,
                    n,
                    d
                  )
                : c(
                    '%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node',
                    n,
                    n,
                    d
                  )
          } finally {
            v ? mn(v) : Un()
          }
        }
      }
      return u.stateNode
    }
  }
  function q1(e, n, i, s, u, d, v, y) {
    var x = !1,
      T = null
    return Y1(e, n, x, T, i, s, u, d, v)
  }
  function K1(e, n, i, s, u, d, v, y, x, T) {
    var _ = !0,
      N = Y1(i, s, _, e, u, d, v, y, x)
    N.context = G1(null)
    var $ = N.current,
      q = Wr(),
      K = ps($),
      re = go(q, K)
    return (re.callback = n ?? null), is($, re, K), FN(N, K, q), N
  }
  function Gf(e, n, i, s) {
    iL(n, e)
    var u = n.current,
      d = Wr(),
      v = ps(u)
    TL(v)
    var y = G1(i)
    n.context === null ? (n.context = y) : (n.pendingContext = y),
      Xa &&
        Nn !== null &&
        !O0 &&
        ((O0 = !0),
        c(
          `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
          nt(Nn) || 'Unknown'
        ))
    var x = go(d, v)
    ;(x.payload = { element: e }),
      (s = s === void 0 ? null : s),
      s !== null &&
        (typeof s != 'function' &&
          c(
            'render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
            s
          ),
        (x.callback = s))
    var T = is(u, x, v)
    return T !== null && (or(T, u, v, d), ph(T, u, v)), v
  }
  function am(e) {
    var n = e.current
    if (!n.child) return null
    switch (n.child.tag) {
      case w:
        return n.child.stateNode
      default:
        return n.child.stateNode
    }
  }
  function OB(e) {
    switch (e.tag) {
      case b: {
        var n = e.stateNode
        if (Ep(n)) {
          var i = LL(n)
          UN(n, i)
        }
        break
      }
      case j: {
        xo(function () {
          var u = ia(e, Ze)
          if (u !== null) {
            var d = Wr()
            or(u, e, Ze, d)
          }
        })
        var s = Ze
        P0(e, s)
        break
      }
    }
  }
  function X1(e, n) {
    var i = e.memoizedState
    i !== null && i.dehydrated !== null && (i.retryLane = jL(i.retryLane, n))
  }
  function P0(e, n) {
    X1(e, n)
    var i = e.alternate
    i && X1(i, n)
  }
  function MB(e) {
    if (e.tag === j) {
      var n = Pc,
        i = ia(e, n)
      if (i !== null) {
        var s = Wr()
        or(i, e, n, s)
      }
      P0(e, n)
    }
  }
  function PB(e) {
    if (e.tag === j) {
      var n = ps(e),
        i = ia(e, n)
      if (i !== null) {
        var s = Wr()
        or(i, e, n, s)
      }
      P0(e, n)
    }
  }
  function Q1(e) {
    var n = XP(e)
    return n === null ? null : n.stateNode
  }
  var Z1 = function (e) {
    return null
  }
  function LB(e) {
    return Z1(e)
  }
  var J1 = function (e) {
    return !1
  }
  function zB(e) {
    return J1(e)
  }
  var eR = null,
    tR = null,
    nR = null,
    rR = null,
    aR = null,
    iR = null,
    oR = null,
    sR = null,
    lR = null
  {
    var uR = function (e, n, i) {
        var s = n[i],
          u = Pt(e) ? e.slice() : ot({}, e)
        return i + 1 === n.length
          ? (Pt(u) ? u.splice(s, 1) : delete u[s], u)
          : ((u[s] = uR(e[s], n, i + 1)), u)
      },
      cR = function (e, n) {
        return uR(e, n, 0)
      },
      fR = function (e, n, i, s) {
        var u = n[s],
          d = Pt(e) ? e.slice() : ot({}, e)
        if (s + 1 === n.length) {
          var v = i[s]
          ;(d[v] = d[u]), Pt(d) ? d.splice(u, 1) : delete d[u]
        } else d[u] = fR(e[u], n, i, s + 1)
        return d
      },
      dR = function (e, n, i) {
        if (n.length !== i.length) {
          f('copyWithRename() expects paths of the same length')
          return
        } else
          for (var s = 0; s < i.length - 1; s++)
            if (n[s] !== i[s]) {
              f('copyWithRename() expects paths to be the same except for the deepest key')
              return
            }
        return fR(e, n, i, 0)
      },
      pR = function (e, n, i, s) {
        if (i >= n.length) return s
        var u = n[i],
          d = Pt(e) ? e.slice() : ot({}, e)
        return (d[u] = pR(e[u], n, i + 1, s)), d
      },
      hR = function (e, n, i) {
        return pR(e, n, 0, i)
      },
      L0 = function (e, n) {
        for (var i = e.memoizedState; i !== null && n > 0; ) (i = i.next), n--
        return i
      }
    ;(eR = function (e, n, i, s) {
      var u = L0(e, n)
      if (u !== null) {
        var d = hR(u.memoizedState, i, s)
        ;(u.memoizedState = d), (u.baseState = d), (e.memoizedProps = ot({}, e.memoizedProps))
        var v = ia(e, Ze)
        v !== null && or(v, e, Ze, vn)
      }
    }),
      (tR = function (e, n, i) {
        var s = L0(e, n)
        if (s !== null) {
          var u = cR(s.memoizedState, i)
          ;(s.memoizedState = u), (s.baseState = u), (e.memoizedProps = ot({}, e.memoizedProps))
          var d = ia(e, Ze)
          d !== null && or(d, e, Ze, vn)
        }
      }),
      (nR = function (e, n, i, s) {
        var u = L0(e, n)
        if (u !== null) {
          var d = dR(u.memoizedState, i, s)
          ;(u.memoizedState = d), (u.baseState = d), (e.memoizedProps = ot({}, e.memoizedProps))
          var v = ia(e, Ze)
          v !== null && or(v, e, Ze, vn)
        }
      }),
      (rR = function (e, n, i) {
        ;(e.pendingProps = hR(e.memoizedProps, n, i)),
          e.alternate && (e.alternate.pendingProps = e.pendingProps)
        var s = ia(e, Ze)
        s !== null && or(s, e, Ze, vn)
      }),
      (aR = function (e, n) {
        ;(e.pendingProps = cR(e.memoizedProps, n)),
          e.alternate && (e.alternate.pendingProps = e.pendingProps)
        var i = ia(e, Ze)
        i !== null && or(i, e, Ze, vn)
      }),
      (iR = function (e, n, i) {
        ;(e.pendingProps = dR(e.memoizedProps, n, i)),
          e.alternate && (e.alternate.pendingProps = e.pendingProps)
        var s = ia(e, Ze)
        s !== null && or(s, e, Ze, vn)
      }),
      (oR = function (e) {
        var n = ia(e, Ze)
        n !== null && or(n, e, Ze, vn)
      }),
      (sR = function (e) {
        Z1 = e
      }),
      (lR = function (e) {
        J1 = e
      })
  }
  function $B(e) {
    var n = IC(e)
    return n === null ? null : n.stateNode
  }
  function FB(e) {
    return null
  }
  function NB() {
    return Nn
  }
  function BB(e) {
    var n = e.findFiberByHostInstance,
      i = a.ReactCurrentDispatcher
    return aL({
      bundleType: e.bundleType,
      version: e.version,
      rendererPackageName: e.rendererPackageName,
      rendererConfig: e.rendererConfig,
      overrideHookState: eR,
      overrideHookStateDeletePath: tR,
      overrideHookStateRenamePath: nR,
      overrideProps: rR,
      overridePropsDeletePath: aR,
      overridePropsRenamePath: iR,
      setErrorHandler: sR,
      setSuspenseHandler: lR,
      scheduleUpdate: oR,
      currentDispatcherRef: i,
      findHostInstanceByFiber: $B,
      findFiberByHostInstance: n || FB,
      findHostInstancesForRefresh: mB,
      scheduleRefresh: pB,
      scheduleRoot: hB,
      setRefreshHandler: dB,
      getCurrentFiber: NB,
      reconcilerVersion: A0,
    })
  }
  var mR =
    typeof reportError == 'function'
      ? reportError
      : function (e) {
          console.error(e)
        }
  function z0(e) {
    this._internalRoot = e
  }
  ;(im.prototype.render = z0.prototype.render =
    function (e) {
      var n = this._internalRoot
      if (n === null) throw new Error('Cannot update an unmounted root.')
      {
        typeof arguments[1] == 'function'
          ? c(
              'render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().'
            )
          : om(arguments[1])
          ? c(
              "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
            )
          : typeof arguments[1] < 'u' &&
            c('You passed a second argument to root.render(...) but it only accepts one argument.')
        var i = n.containerInfo
        if (i.nodeType !== Vn) {
          var s = Q1(n.current)
          s &&
            s.parentNode !== i &&
            c(
              "render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container."
            )
        }
      }
      Gf(e, n, null, null)
    }),
    (im.prototype.unmount = z0.prototype.unmount =
      function () {
        typeof arguments[0] == 'function' &&
          c(
            'unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().'
          )
        var e = this._internalRoot
        if (e !== null) {
          this._internalRoot = null
          var n = e.containerInfo
          _1() &&
            c(
              'Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.'
            ),
            xo(function () {
              Gf(null, e, null, null)
            }),
            hE(n)
        }
      })
  function jB(e, n) {
    if (!om(e)) throw new Error('createRoot(...): Target container is not a DOM element.')
    vR(e)
    var i = !1,
      s = !1,
      u = '',
      d = mR
    n != null &&
      (n.hydrate
        ? f(
            'hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.'
          )
        : typeof n == 'object' &&
          n !== null &&
          n.$$typeof === cr &&
          c(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`),
      n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (u = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (d = n.onRecoverableError),
      n.transitionCallbacks !== void 0 && n.transitionCallbacks)
    var v = q1(e, eh, null, i, s, u, d)
    Gp(v.current, e)
    var y = e.nodeType === Vn ? e.parentNode : e
    return ef(y), new z0(v)
  }
  function im(e) {
    this._internalRoot = e
  }
  function UB(e) {
    e && rz(e)
  }
  im.prototype.unstable_scheduleHydration = UB
  function VB(e, n, i) {
    if (!om(e)) throw new Error('hydrateRoot(...): Target container is not a DOM element.')
    vR(e),
      n === void 0 &&
        c(
          'Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)'
        )
    var s = i ?? null,
      u = (i != null && i.hydratedSources) || null,
      d = !1,
      v = !1,
      y = '',
      x = mR
    i != null &&
      (i.unstable_strictMode === !0 && (d = !0),
      i.identifierPrefix !== void 0 && (y = i.identifierPrefix),
      i.onRecoverableError !== void 0 && (x = i.onRecoverableError))
    var T = K1(n, null, e, eh, s, d, v, y, x)
    if ((Gp(T.current, e), ef(e), u))
      for (var _ = 0; _ < u.length; _++) {
        var N = u[_]
        X5(T, N)
      }
    return new im(T)
  }
  function om(e) {
    return !!(e && (e.nodeType === ra || e.nodeType === ro || e.nodeType === Vv || !vt))
  }
  function qf(e) {
    return !!(
      e &&
      (e.nodeType === ra ||
        e.nodeType === ro ||
        e.nodeType === Vv ||
        (e.nodeType === Vn && e.nodeValue === ' react-mount-point-unstable '))
    )
  }
  function vR(e) {
    e.nodeType === ra &&
      e.tagName &&
      e.tagName.toUpperCase() === 'BODY' &&
      c(
        'createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.'
      ),
      df(e) &&
        (e._reactRootContainer
          ? c(
              'You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.'
            )
          : c(
              'You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.'
            ))
  }
  var IB = a.ReactCurrentOwner,
    gR
  gR = function (e) {
    if (e._reactRootContainer && e.nodeType !== Vn) {
      var n = Q1(e._reactRootContainer.current)
      n &&
        n.parentNode !== e &&
        c(
          'render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.'
        )
    }
    var i = !!e._reactRootContainer,
      s = $0(e),
      u = !!(s && es(s))
    u &&
      !i &&
      c(
        'render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.'
      ),
      e.nodeType === ra &&
        e.tagName &&
        e.tagName.toUpperCase() === 'BODY' &&
        c(
          'render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.'
        )
  }
  function $0(e) {
    return e ? (e.nodeType === ro ? e.documentElement : e.firstChild) : null
  }
  function yR() {}
  function HB(e, n, i, s, u) {
    if (u) {
      if (typeof s == 'function') {
        var d = s
        s = function () {
          var $ = am(v)
          d.call($)
        }
      }
      var v = K1(n, s, e, ns, null, !1, !1, '', yR)
      ;(e._reactRootContainer = v), Gp(v.current, e)
      var y = e.nodeType === Vn ? e.parentNode : e
      return ef(y), xo(), v
    } else {
      for (var x; (x = e.lastChild); ) e.removeChild(x)
      if (typeof s == 'function') {
        var T = s
        s = function () {
          var $ = am(_)
          T.call($)
        }
      }
      var _ = q1(e, ns, null, !1, !1, '', yR)
      ;(e._reactRootContainer = _), Gp(_.current, e)
      var N = e.nodeType === Vn ? e.parentNode : e
      return (
        ef(N),
        xo(function () {
          Gf(n, _, i, s)
        }),
        _
      )
    }
  }
  function WB(e, n) {
    e !== null &&
      typeof e != 'function' &&
      c(
        '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
        n,
        e
      )
  }
  function sm(e, n, i, s, u) {
    gR(i), WB(u === void 0 ? null : u, 'render')
    var d = i._reactRootContainer,
      v
    if (!d) v = HB(i, n, e, u, s)
    else {
      if (((v = d), typeof u == 'function')) {
        var y = u
        u = function () {
          var x = am(v)
          y.call(x)
        }
      }
      Gf(n, v, e, u)
    }
    return am(v)
  }
  function YB(e) {
    {
      var n = IB.current
      if (n !== null && n.stateNode !== null) {
        var i = n.stateNode._warnedAboutRefsInRender
        i ||
          c(
            '%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.',
            kt(n.type) || 'A component'
          ),
          (n.stateNode._warnedAboutRefsInRender = !0)
      }
    }
    return e == null ? null : e.nodeType === ra ? e : AB(e, 'findDOMNode')
  }
  function GB(e, n, i) {
    if (
      (c(
        "ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
      ),
      !qf(n))
    )
      throw new Error('Target container is not a DOM element.')
    {
      var s = df(n) && n._reactRootContainer === void 0
      s &&
        c(
          'You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?'
        )
    }
    return sm(null, e, n, !0, i)
  }
  function qB(e, n, i) {
    if (
      (c(
        "ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
      ),
      !qf(n))
    )
      throw new Error('Target container is not a DOM element.')
    {
      var s = df(n) && n._reactRootContainer === void 0
      s &&
        c(
          'You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?'
        )
    }
    return sm(null, e, n, !1, i)
  }
  function KB(e, n, i, s) {
    if (
      (c(
        "ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
      ),
      !qf(i))
    )
      throw new Error('Target container is not a DOM element.')
    if (e == null || !IP(e)) throw new Error('parentComponent must be a valid React Component')
    return sm(e, n, i, !1, s)
  }
  function XB(e) {
    if (!qf(e))
      throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.')
    {
      var n = df(e) && e._reactRootContainer === void 0
      n &&
        c(
          'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?'
        )
    }
    if (e._reactRootContainer) {
      {
        var i = $0(e),
          s = i && !es(i)
        s &&
          c(
            "unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React."
          )
      }
      return (
        xo(function () {
          sm(null, null, e, !1, function () {
            ;(e._reactRootContainer = null), hE(e)
          })
        }),
        !0
      )
    } else {
      {
        var u = $0(e),
          d = !!(u && es(u)),
          v = e.nodeType === ra && qf(e.parentNode) && !!e.parentNode._reactRootContainer
        d &&
          c(
            "unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s",
            v
              ? 'You may have accidentally passed in a React root node instead of its container.'
              : 'Instead, have the parent component update its state and rerender in order to remove this component.'
          )
      }
      return !1
    }
  }
  GL(OB),
    KL(MB),
    XL(PB),
    QL(ei),
    ZL(HL),
    (typeof Map != 'function' ||
      Map.prototype == null ||
      typeof Map.prototype.forEach != 'function' ||
      typeof Set != 'function' ||
      Set.prototype == null ||
      typeof Set.prototype.clear != 'function' ||
      typeof Set.prototype.forEach != 'function') &&
      c(
        'React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills'
      ),
    MP(J$),
    zP(p0, VN, xo)
  function QB(e, n) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null
    if (!om(n)) throw new Error('Target container is not a DOM element.')
    return DB(e, n, null, i)
  }
  function ZB(e, n, i, s) {
    return KB(e, n, i, s)
  }
  var F0 = { usingClientEntryPoint: !1, Events: [es, mu, qp, OC, MC, p0] }
  function JB(e, n) {
    return (
      F0.usingClientEntryPoint ||
        c(
          'You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'
        ),
      jB(e, n)
    )
  }
  function ej(e, n, i) {
    return (
      F0.usingClientEntryPoint ||
        c(
          'You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'
        ),
      VB(e, n, i)
    )
  }
  function tj(e) {
    return (
      _1() &&
        c(
          'flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.'
        ),
      xo(e)
    )
  }
  var nj = BB({
    findFiberByHostInstance: ol,
    bundleType: 1,
    version: A0,
    rendererPackageName: 'react-dom',
  })
  if (
    !nj &&
    wt &&
    window.top === window.self &&
    ((navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1) ||
      navigator.userAgent.indexOf('Firefox') > -1)
  ) {
    var bR = window.location.protocol
    ;/^(https?|file):$/.test(bR) &&
      console.info(
        '%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools' +
          (bR === 'file:'
            ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq`
            : ''),
        'font-weight:bold'
      )
  }
  ;(ka.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = F0),
    (ka.createPortal = QB),
    (ka.createRoot = JB),
    (ka.findDOMNode = YB),
    (ka.flushSync = tj),
    (ka.hydrate = GB),
    (ka.hydrateRoot = ej),
    (ka.render = qB),
    (ka.unmountComponentAtNode = XB),
    (ka.unstable_batchedUpdates = p0),
    (ka.unstable_renderSubtreeIntoContainer = ZB),
    (ka.version = A0),
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == 'function' &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
})()
;(function (t) {
  t.exports = ka
})(CU)
var [ID, EU] = zo({ strict: !1, name: 'PortalContext' }),
  Cx = 'chakra-portal',
  TU = '.chakra-portal',
  RU = (t) =>
    V('div', {
      className: 'chakra-portal-zIndex',
      style: { position: 'absolute', zIndex: t.zIndex, top: 0, left: 0, right: 0 },
      children: t.children,
    }),
  _U = (t) => {
    const { appendToParentPortal: r, children: a } = t,
      [o, l] = R.useState(null),
      f = R.useRef(null),
      [, c] = R.useState({})
    R.useEffect(() => c({}), [])
    const p = EU(),
      h = xU()
    kd(() => {
      if (!o) return
      const g = o.ownerDocument,
        b = r ? p ?? g.body : g.body
      if (!b) return
      ;(f.current = g.createElement('div')),
        (f.current.className = Cx),
        b.appendChild(f.current),
        c({})
      const C = f.current
      return () => {
        b.contains(C) && b.removeChild(C)
      }
    }, [o])
    const m =
      h != null && h.zIndex ? V(RU, { zIndex: h == null ? void 0 : h.zIndex, children: a }) : a
    return f.current
      ? Dd.createPortal(V(ID, { value: f.current, children: m }), f.current)
      : V('span', {
          ref: (g) => {
            g && l(g)
          },
        })
  },
  kU = (t) => {
    const { children: r, containerRef: a, appendToParentPortal: o } = t,
      l = a.current,
      f = l ?? (typeof window < 'u' ? document.body : void 0),
      c = R.useMemo(() => {
        const h = l == null ? void 0 : l.ownerDocument.createElement('div')
        return h && (h.className = Cx), h
      }, [l]),
      [, p] = R.useState({})
    return (
      kd(() => p({}), []),
      kd(() => {
        if (!(!c || !f))
          return (
            f.appendChild(c),
            () => {
              f.removeChild(c)
            }
          )
      }, [c, f]),
      f && c ? Dd.createPortal(V(ID, { value: o ? c : null, children: r }), c) : null
    )
  }
function hv(t) {
  const r = { appendToParentPortal: !0, ...t },
    { containerRef: a, ...o } = r
  return a ? V(kU, { containerRef: a, ...o }) : V(_U, { ...o })
}
hv.className = Cx
hv.selector = TU
hv.displayName = 'Portal'
function mv() {
  const t = R.useContext(ks)
  if (!t)
    throw Error(
      'useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`'
    )
  return t
}
var wx = R.createContext({})
wx.displayName = 'ColorModeContext'
function Ex() {
  const t = R.useContext(wx)
  if (t === void 0) throw new Error('useColorMode must be used within a ColorModeProvider')
  return t
}
var cm = { light: 'chakra-ui-light', dark: 'chakra-ui-dark' }
function DU(t = {}) {
  const { preventTransition: r = !0 } = t,
    a = {
      setDataset: (o) => {
        const l = r ? a.preventTransition() : void 0
        ;(document.documentElement.dataset.theme = o),
          (document.documentElement.style.colorScheme = o),
          l == null || l()
      },
      setClassName(o) {
        document.body.classList.add(o ? cm.dark : cm.light),
          document.body.classList.remove(o ? cm.light : cm.dark)
      },
      query() {
        return window.matchMedia('(prefers-color-scheme: dark)')
      },
      getSystemTheme(o) {
        var l
        return ((l = a.query().matches) != null ? l : o === 'dark') ? 'dark' : 'light'
      },
      addListener(o) {
        const l = a.query(),
          f = (c) => {
            o(c.matches ? 'dark' : 'light')
          }
        return (
          typeof l.addListener == 'function' ? l.addListener(f) : l.addEventListener('change', f),
          () => {
            typeof l.removeListener == 'function'
              ? l.removeListener(f)
              : l.removeEventListener('change', f)
          }
        )
      },
      preventTransition() {
        const o = document.createElement('style')
        return (
          o.appendChild(
            document.createTextNode(
              '*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}'
            )
          ),
          document.head.appendChild(o),
          () => {
            window.getComputedStyle(document.body),
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  document.head.removeChild(o)
                })
              })
          }
        )
      },
    }
  return a
}
var AU = 'chakra-ui-color-mode'
function OU(t) {
  return {
    ssr: !1,
    type: 'localStorage',
    get(r) {
      if (!(globalThis != null && globalThis.document)) return r
      let a
      try {
        a = localStorage.getItem(t) || r
      } catch {}
      return a || r
    },
    set(r) {
      try {
        localStorage.setItem(t, r)
      } catch {}
    },
  }
}
var MU = OU(AU),
  $R = () => {}
function FR(t, r) {
  return t.type === 'cookie' && t.ssr ? t.get(r) : r
}
function HD(t) {
  const {
      value: r,
      children: a,
      options: { useSystemColorMode: o, initialColorMode: l, disableTransitionOnChange: f } = {},
      colorModeManager: c = MU,
    } = t,
    p = l === 'dark' ? 'dark' : 'light',
    [h, m] = R.useState(() => FR(c, p)),
    [g, b] = R.useState(() => FR(c)),
    {
      getSystemTheme: C,
      setClassName: w,
      setDataset: k,
      addListener: D,
    } = R.useMemo(() => DU({ preventTransition: f }), [f]),
    E = l === 'system' && !h ? g : h,
    M = R.useCallback(
      (B) => {
        const j = B === 'system' ? C() : B
        m(j), w(j === 'dark'), k(j), c.set(j)
      },
      [c, C, w, k]
    )
  kd(() => {
    l === 'system' && b(C())
  }, []),
    R.useEffect(() => {
      const B = c.get()
      if (B) {
        M(B)
        return
      }
      if (l === 'system') {
        M('system')
        return
      }
      M(p)
    }, [c, p, l, M])
  const z = R.useCallback(() => {
    M(E === 'dark' ? 'light' : 'dark')
  }, [E, M])
  R.useEffect(() => {
    if (o) return D(M)
  }, [o, D, M])
  const P = R.useMemo(
    () => ({
      colorMode: r ?? E,
      toggleColorMode: r ? $R : z,
      setColorMode: r ? $R : M,
      forced: r !== void 0,
    }),
    [E, z, M, r]
  )
  return V(wx.Provider, { value: P, children: a })
}
HD.displayName = 'ColorModeProvider'
function PU() {
  const t = Ex(),
    r = mv()
  return { ...t, theme: r }
}
var lr = (...t) => t.filter(Boolean).join(' ')
function Br(t) {
  const r = typeof t
  return t != null && (r === 'object' || r === 'function') && !Array.isArray(t)
}
function ko(t, ...r) {
  return LU(t) ? t(...r) : t
}
var LU = (t) => typeof t == 'function',
  Um = (t) => (t ? '' : void 0)
function RS(...t) {
  return function (a) {
    t.some((o) => (o == null || o(a), a == null ? void 0 : a.defaultPrevented))
  }
}
function zU(...t) {
  return function (a) {
    t.forEach((o) => {
      o == null || o(a)
    })
  }
}
var Vm = {},
  $U = {
    get exports() {
      return Vm
    },
    set exports(t) {
      Vm = t
    },
  }
;(function (t, r) {
  var a = 200,
    o = '__lodash_hash_undefined__',
    l = 800,
    f = 16,
    c = 9007199254740991,
    p = '[object Arguments]',
    h = '[object Array]',
    m = '[object AsyncFunction]',
    g = '[object Boolean]',
    b = '[object Date]',
    C = '[object Error]',
    w = '[object Function]',
    k = '[object GeneratorFunction]',
    D = '[object Map]',
    E = '[object Number]',
    M = '[object Null]',
    z = '[object Object]',
    P = '[object Proxy]',
    B = '[object RegExp]',
    j = '[object Set]',
    Q = '[object String]',
    Y = '[object Undefined]',
    ne = '[object WeakMap]',
    he = '[object ArrayBuffer]',
    le = '[object DataView]',
    pe = '[object Float32Array]',
    Ne = '[object Float64Array]',
    me = '[object Int8Array]',
    ge = '[object Int16Array]',
    Oe = '[object Int32Array]',
    ze = '[object Uint8Array]',
    ee = '[object Uint8ClampedArray]',
    ut = '[object Uint16Array]',
    Bt = '[object Uint32Array]',
    rt = /[\\^$.*+?()[\]{}|]/g,
    qe = /^\[object .+?Constructor\]$/,
    vt = /^(?:0|[1-9]\d*)$/,
    Pe = {}
  ;(Pe[pe] = Pe[Ne] = Pe[me] = Pe[ge] = Pe[Oe] = Pe[ze] = Pe[ee] = Pe[ut] = Pe[Bt] = !0),
    (Pe[p] =
      Pe[h] =
      Pe[he] =
      Pe[g] =
      Pe[le] =
      Pe[b] =
      Pe[C] =
      Pe[w] =
      Pe[D] =
      Pe[E] =
      Pe[z] =
      Pe[B] =
      Pe[j] =
      Pe[Q] =
      Pe[ne] =
        !1)
  var Ke = typeof lm == 'object' && lm && lm.Object === Object && lm,
    Mt = typeof self == 'object' && self && self.Object === Object && self,
    Rt = Ke || Mt || Function('return this')(),
    an = r && !r.nodeType && r,
    _t = an && !0 && t && !t.nodeType && t,
    zt = _t && _t.exports === an,
    Qt = zt && Ke.process,
    Ct = (function () {
      try {
        var A = _t && _t.require && _t.require('util').types
        return A || (Qt && Qt.binding && Qt.binding('util'))
      } catch {}
    })(),
    xe = Ct && Ct.isTypedArray
  function wt(A, F, X) {
    switch (X.length) {
      case 0:
        return A.call(F)
      case 1:
        return A.call(F, X[0])
      case 2:
        return A.call(F, X[0], X[1])
      case 3:
        return A.call(F, X[0], X[1], X[2])
    }
    return A.apply(F, X)
  }
  function Zt(A, F) {
    for (var X = -1, Te = Array(A); ++X < A; ) Te[X] = F(X)
    return Te
  }
  function Jt(A) {
    return function (F) {
      return A(F)
    }
  }
  function on(A, F) {
    return A == null ? void 0 : A[F]
  }
  function sn(A, F) {
    return function (X) {
      return A(F(X))
    }
  }
  var Kn = Array.prototype,
    Xn = Function.prototype,
    en = Object.prototype,
    hn = Rt['__core-js_shared__'],
    gn = Xn.toString,
    jt = en.hasOwnProperty,
    kn = (function () {
      var A = /[^.]+$/.exec((hn && hn.keys && hn.keys.IE_PROTO) || '')
      return A ? 'Symbol(src)_1.' + A : ''
    })(),
    wn = en.toString,
    jn = gn.call(Object),
    tn = RegExp(
      '^' +
        gn
          .call(jt)
          .replace(rt, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
        '$'
    ),
    On = zt ? Rt.Buffer : void 0,
    J = Rt.Symbol,
    te = Rt.Uint8Array,
    I = On ? On.allocUnsafe : void 0,
    ie = sn(Object.getPrototypeOf, Object),
    ce = Object.create,
    be = en.propertyIsEnumerable,
    Se = Kn.splice,
    _e = J ? J.toStringTag : void 0,
    Ce = (function () {
      try {
        var A = xi(Object, 'defineProperty')
        return A({}, '', {}), A
      } catch {}
    })(),
    it = On ? On.isBuffer : void 0,
    $e = Math.max,
    ln = Date.now,
    et = xi(Rt, 'Map'),
    Xe = xi(Object, 'create'),
    En = (function () {
      function A() {}
      return function (F) {
        if (!Pn(F)) return {}
        if (ce) return ce(F)
        A.prototype = F
        var X = new A()
        return (A.prototype = void 0), X
      }
    })()
  function yn(A) {
    var F = -1,
      X = A == null ? 0 : A.length
    for (this.clear(); ++F < X; ) {
      var Te = A[F]
      this.set(Te[0], Te[1])
    }
  }
  function va() {
    ;(this.__data__ = Xe ? Xe(null) : {}), (this.size = 0)
  }
  function Zr(A) {
    var F = this.has(A) && delete this.__data__[A]
    return (this.size -= F ? 1 : 0), F
  }
  function Jr(A) {
    var F = this.__data__
    if (Xe) {
      var X = F[A]
      return X === o ? void 0 : X
    }
    return jt.call(F, A) ? F[A] : void 0
  }
  function ga(A) {
    var F = this.__data__
    return Xe ? F[A] !== void 0 : jt.call(F, A)
  }
  function ya(A, F) {
    var X = this.__data__
    return (this.size += this.has(A) ? 0 : 1), (X[A] = Xe && F === void 0 ? o : F), this
  }
  ;(yn.prototype.clear = va),
    (yn.prototype.delete = Zr),
    (yn.prototype.get = Jr),
    (yn.prototype.has = ga),
    (yn.prototype.set = ya)
  function Et(A) {
    var F = -1,
      X = A == null ? 0 : A.length
    for (this.clear(); ++F < X; ) {
      var Te = A[F]
      this.set(Te[0], Te[1])
    }
  }
  function Mn() {
    ;(this.__data__ = []), (this.size = 0)
  }
  function Qn(A) {
    var F = this.__data__,
      X = Zn(F, A)
    if (X < 0) return !1
    var Te = F.length - 1
    return X == Te ? F.pop() : Se.call(F, X, 1), --this.size, !0
  }
  function cr(A) {
    var F = this.__data__,
      X = Zn(F, A)
    return X < 0 ? void 0 : F[X][1]
  }
  function jr(A) {
    return Zn(this.__data__, A) > -1
  }
  function ea(A, F) {
    var X = this.__data__,
      Te = Zn(X, A)
    return Te < 0 ? (++this.size, X.push([A, F])) : (X[Te][1] = F), this
  }
  ;(Et.prototype.clear = Mn),
    (Et.prototype.delete = Qn),
    (Et.prototype.get = cr),
    (Et.prototype.has = jr),
    (Et.prototype.set = ea)
  function Tn(A) {
    var F = -1,
      X = A == null ? 0 : A.length
    for (this.clear(); ++F < X; ) {
      var Te = A[F]
      this.set(Te[0], Te[1])
    }
  }
  function L() {
    ;(this.size = 0), (this.__data__ = { hash: new yn(), map: new (et || Et)(), string: new yn() })
  }
  function se(A) {
    var F = ba(this, A).delete(A)
    return (this.size -= F ? 1 : 0), F
  }
  function ve(A) {
    return ba(this, A).get(A)
  }
  function ke(A) {
    return ba(this, A).has(A)
  }
  function dt(A, F) {
    var X = ba(this, A),
      Te = X.size
    return X.set(A, F), (this.size += X.size == Te ? 0 : 1), this
  }
  ;(Tn.prototype.clear = L),
    (Tn.prototype.delete = se),
    (Tn.prototype.get = ve),
    (Tn.prototype.has = ke),
    (Tn.prototype.set = dt)
  function ct(A) {
    var F = (this.__data__ = new Et(A))
    this.size = F.size
  }
  function at() {
    ;(this.__data__ = new Et()), (this.size = 0)
  }
  function Be(A) {
    var F = this.__data__,
      X = F.delete(A)
    return (this.size = F.size), X
  }
  function Fn(A) {
    return this.__data__.get(A)
  }
  function un(A) {
    return this.__data__.has(A)
  }
  function cn(A, F) {
    var X = this.__data__
    if (X instanceof Et) {
      var Te = X.__data__
      if (!et || Te.length < a - 1) return Te.push([A, F]), (this.size = ++X.size), this
      X = this.__data__ = new Tn(Te)
    }
    return X.set(A, F), (this.size = X.size), this
  }
  ;(ct.prototype.clear = at),
    (ct.prototype.delete = Be),
    (ct.prototype.get = Fn),
    (ct.prototype.has = un),
    (ct.prototype.set = cn)
  function fr(A, F) {
    var X = za(A),
      Te = !X && Xa(A),
      pt = !X && !Te && mn(A),
      $t = !X && !Te && !pt && Zi(A),
      nn = X || Te || pt || $t,
      S = nn ? Zt(A.length, String) : [],
      O = S.length
    for (var G in A)
      (F || jt.call(A, G)) &&
        !(
          nn &&
          (G == 'length' ||
            (pt && (G == 'offset' || G == 'parent')) ||
            ($t && (G == 'buffer' || G == 'byteLength' || G == 'byteOffset')) ||
            Uo(G, O))
        ) &&
        S.push(G)
    return S
  }
  function ta(A, F, X) {
    ;((X !== void 0 && !Nn(A[F], X)) || (X === void 0 && !(F in A))) && $s(A, F, X)
  }
  function Bo(A, F, X) {
    var Te = A[F]
    ;(!(jt.call(A, F) && Nn(Te, X)) || (X === void 0 && !(F in A))) && $s(A, F, X)
  }
  function Zn(A, F) {
    for (var X = A.length; X--; ) if (Nn(A[X][0], F)) return X
    return -1
  }
  function $s(A, F, X) {
    F == '__proto__' && Ce
      ? Ce(A, F, { configurable: !0, enumerable: !0, value: X, writable: !0 })
      : (A[F] = X)
  }
  var Ka = Si()
  function ot(A) {
    return A == null ? (A === void 0 ? Y : M) : _e && _e in Object(A) ? Hs(A) : Vl(A)
  }
  function yi(A) {
    return Dr(A) && ot(A) == p
  }
  function bi(A) {
    if (!Pn(A) || Ul(A)) return !1
    var F = Wo(A) ? tn : qe
    return F.test(Il(A))
  }
  function Fs(A) {
    return Dr(A) && kr(A.length) && !!Pe[ot(A)]
  }
  function Ns(A) {
    if (!Pn(A)) return Io(A)
    var F = Vo(A),
      X = []
    for (var Te in A) (Te == 'constructor' && (F || !jt.call(A, Te))) || X.push(Te)
    return X
  }
  function jo(A, F, X, Te, pt) {
    A !== F &&
      Ka(
        F,
        function ($t, nn) {
          if ((pt || (pt = new ct()), Pn($t))) Bs(A, F, nn, X, jo, Te, pt)
          else {
            var S = Te ? Te(Qi(A, nn), $t, nn + '', A, F, pt) : void 0
            S === void 0 && (S = $t), ta(A, nn, S)
          }
        },
        Ys
      )
  }
  function Bs(A, F, X, Te, pt, $t, nn) {
    var S = Qi(A, X),
      O = Qi(F, X),
      G = nn.get(O)
    if (G) {
      ta(A, X, G)
      return
    }
    var Z = $t ? $t(S, O, X + '', A, F, nn) : void 0,
      de = Z === void 0
    if (de) {
      var Ue = za(O),
        Me = !Ue && mn(O),
        We = !Ue && !Me && Zi(O)
      ;(Z = O),
        Ue || Me || We
          ? za(S)
            ? (Z = S)
            : Un(S)
            ? (Z = Is(S))
            : Me
            ? ((de = !1), (Z = Vs(O, !0)))
            : We
            ? ((de = !1), (Z = vc(O, !0)))
            : (Z = [])
          : yc(O) || Xa(O)
          ? ((Z = S), Xa(S) ? (Z = Ji(S)) : (!Pn(S) || Wo(S)) && (Z = jl(O)))
          : (de = !1)
    }
    de && (nn.set(O, Z), pt(Z, O, Te, $t, nn), nn.delete(O)), ta(A, X, Z)
  }
  function js(A, F) {
    return Ws(kt(A, F, Wl), A + '')
  }
  var Us = Ce
    ? function (A, F) {
        return Ce(A, 'toString', { configurable: !0, enumerable: !1, value: Hl(F), writable: !0 })
      }
    : Wl
  function Vs(A, F) {
    if (F) return A.slice()
    var X = A.length,
      Te = I ? I(X) : new A.constructor(X)
    return A.copy(Te), Te
  }
  function Bl(A) {
    var F = new A.constructor(A.byteLength)
    return new te(F).set(new te(A)), F
  }
  function vc(A, F) {
    var X = F ? Bl(A.buffer) : A.buffer
    return new A.constructor(X, A.byteOffset, A.length)
  }
  function Is(A, F) {
    var X = -1,
      Te = A.length
    for (F || (F = Array(Te)); ++X < Te; ) F[X] = A[X]
    return F
  }
  function Xi(A, F, X, Te) {
    var pt = !X
    X || (X = {})
    for (var $t = -1, nn = F.length; ++$t < nn; ) {
      var S = F[$t],
        O = Te ? Te(X[S], A[S], S, X, A) : void 0
      O === void 0 && (O = A[S]), pt ? $s(X, S, O) : Bo(X, S, O)
    }
    return X
  }
  function na(A) {
    return js(function (F, X) {
      var Te = -1,
        pt = X.length,
        $t = pt > 1 ? X[pt - 1] : void 0,
        nn = pt > 2 ? X[2] : void 0
      for (
        $t = A.length > 3 && typeof $t == 'function' ? (pt--, $t) : void 0,
          nn && gc(X[0], X[1], nn) && (($t = pt < 3 ? void 0 : $t), (pt = 1)),
          F = Object(F);
        ++Te < pt;

      ) {
        var S = X[Te]
        S && A(F, S, Te, $t)
      }
      return F
    })
  }
  function Si(A) {
    return function (F, X, Te) {
      for (var pt = -1, $t = Object(F), nn = Te(F), S = nn.length; S--; ) {
        var O = nn[A ? S : ++pt]
        if (X($t[O], O, $t) === !1) break
      }
      return F
    }
  }
  function ba(A, F) {
    var X = A.__data__
    return Ci(F) ? X[typeof F == 'string' ? 'string' : 'hash'] : X.map
  }
  function xi(A, F) {
    var X = on(A, F)
    return bi(X) ? X : void 0
  }
  function Hs(A) {
    var F = jt.call(A, _e),
      X = A[_e]
    try {
      A[_e] = void 0
      var Te = !0
    } catch {}
    var pt = wn.call(A)
    return Te && (F ? (A[_e] = X) : delete A[_e]), pt
  }
  function jl(A) {
    return typeof A.constructor == 'function' && !Vo(A) ? En(ie(A)) : {}
  }
  function Uo(A, F) {
    var X = typeof A
    return (
      (F = F ?? c),
      !!F && (X == 'number' || (X != 'symbol' && vt.test(A))) && A > -1 && A % 1 == 0 && A < F
    )
  }
  function gc(A, F, X) {
    if (!Pn(X)) return !1
    var Te = typeof F
    return (Te == 'number' ? Ho(X) && Uo(F, X.length) : Te == 'string' && F in X) ? Nn(X[F], A) : !1
  }
  function Ci(A) {
    var F = typeof A
    return F == 'string' || F == 'number' || F == 'symbol' || F == 'boolean'
      ? A !== '__proto__'
      : A === null
  }
  function Ul(A) {
    return !!kn && kn in A
  }
  function Vo(A) {
    var F = A && A.constructor,
      X = (typeof F == 'function' && F.prototype) || en
    return A === X
  }
  function Io(A) {
    var F = []
    if (A != null) for (var X in Object(A)) F.push(X)
    return F
  }
  function Vl(A) {
    return wn.call(A)
  }
  function kt(A, F, X) {
    return (
      (F = $e(F === void 0 ? A.length - 1 : F, 0)),
      function () {
        for (var Te = arguments, pt = -1, $t = $e(Te.length - F, 0), nn = Array($t); ++pt < $t; )
          nn[pt] = Te[F + pt]
        pt = -1
        for (var S = Array(F + 1); ++pt < F; ) S[pt] = Te[pt]
        return (S[F] = X(nn)), wt(A, this, S)
      }
    )
  }
  function Qi(A, F) {
    if (!(F === 'constructor' && typeof A[F] == 'function') && F != '__proto__') return A[F]
  }
  var Ws = nt(Us)
  function nt(A) {
    var F = 0,
      X = 0
    return function () {
      var Te = ln(),
        pt = f - (Te - X)
      if (((X = Te), pt > 0)) {
        if (++F >= l) return arguments[0]
      } else F = 0
      return A.apply(void 0, arguments)
    }
  }
  function Il(A) {
    if (A != null) {
      try {
        return gn.call(A)
      } catch {}
      try {
        return A + ''
      } catch {}
    }
    return ''
  }
  function Nn(A, F) {
    return A === F || (A !== A && F !== F)
  }
  var Xa = yi(
      (function () {
        return arguments
      })()
    )
      ? yi
      : function (A) {
          return Dr(A) && jt.call(A, 'callee') && !be.call(A, 'callee')
        },
    za = Array.isArray
  function Ho(A) {
    return A != null && kr(A.length) && !Wo(A)
  }
  function Un(A) {
    return Dr(A) && Ho(A)
  }
  var mn = it || Qa
  function Wo(A) {
    if (!Pn(A)) return !1
    var F = ot(A)
    return F == w || F == k || F == m || F == P
  }
  function kr(A) {
    return typeof A == 'number' && A > -1 && A % 1 == 0 && A <= c
  }
  function Pn(A) {
    var F = typeof A
    return A != null && (F == 'object' || F == 'function')
  }
  function Dr(A) {
    return A != null && typeof A == 'object'
  }
  function yc(A) {
    if (!Dr(A) || ot(A) != z) return !1
    var F = ie(A)
    if (F === null) return !0
    var X = jt.call(F, 'constructor') && F.constructor
    return typeof X == 'function' && X instanceof X && gn.call(X) == jn
  }
  var Zi = xe ? Jt(xe) : Fs
  function Ji(A) {
    return Xi(A, Ys(A))
  }
  function Ys(A) {
    return Ho(A) ? fr(A, !0) : Ns(A)
  }
  var wi = na(function (A, F, X, Te) {
    jo(A, F, X, Te)
  })
  function Hl(A) {
    return function () {
      return A
    }
  }
  function Wl(A) {
    return A
  }
  function Qa() {
    return !1
  }
  t.exports = wi
})($U, Vm)
const Ya = Vm
var FU = (t) => /!(important)?$/.test(t),
  NR = (t) => (typeof t == 'string' ? t.replace(/!(important)?$/, '').trim() : t),
  NU = (t, r) => (a) => {
    const o = String(r),
      l = FU(o),
      f = NR(o),
      c = t ? `${t}.${f}` : f
    let p = Br(a.__cssMap) && c in a.__cssMap ? a.__cssMap[c].varRef : r
    return (p = NR(p)), l ? `${p} !important` : p
  }
function Tx(t) {
  const { scale: r, transform: a, compose: o } = t
  return (f, c) => {
    var p
    const h = NU(r, f)(c)
    let m = (p = a == null ? void 0 : a(h, c)) != null ? p : h
    return o && (m = o(m, c)), m
  }
}
var fm =
  (...t) =>
  (r) =>
    t.reduce((a, o) => o(a), r)
function Ia(t, r) {
  return (a) => {
    const o = { property: a, scale: t }
    return (o.transform = Tx({ scale: t, transform: r })), o
  }
}
var BU =
  ({ rtl: t, ltr: r }) =>
  (a) =>
    a.direction === 'rtl' ? t : r
function jU(t) {
  const { property: r, scale: a, transform: o } = t
  return { scale: a, property: BU(r), transform: a ? Tx({ scale: a, compose: o }) : o }
}
var WD = [
  'rotate(var(--chakra-rotate, 0))',
  'scaleX(var(--chakra-scale-x, 1))',
  'scaleY(var(--chakra-scale-y, 1))',
  'skewX(var(--chakra-skew-x, 0))',
  'skewY(var(--chakra-skew-y, 0))',
]
function UU() {
  return [
    'translateX(var(--chakra-translate-x, 0))',
    'translateY(var(--chakra-translate-y, 0))',
    ...WD,
  ].join(' ')
}
function VU() {
  return ['translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)', ...WD].join(
    ' '
  )
}
var IU = {
    '--chakra-blur': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-brightness': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-contrast': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-grayscale': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-hue-rotate': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-invert': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-saturate': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-sepia': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-drop-shadow': 'var(--chakra-empty,/*!*/ /*!*/)',
    'filter': [
      'var(--chakra-blur)',
      'var(--chakra-brightness)',
      'var(--chakra-contrast)',
      'var(--chakra-grayscale)',
      'var(--chakra-hue-rotate)',
      'var(--chakra-invert)',
      'var(--chakra-saturate)',
      'var(--chakra-sepia)',
      'var(--chakra-drop-shadow)',
    ].join(' '),
  },
  HU = {
    'backdropFilter': [
      'var(--chakra-backdrop-blur)',
      'var(--chakra-backdrop-brightness)',
      'var(--chakra-backdrop-contrast)',
      'var(--chakra-backdrop-grayscale)',
      'var(--chakra-backdrop-hue-rotate)',
      'var(--chakra-backdrop-invert)',
      'var(--chakra-backdrop-opacity)',
      'var(--chakra-backdrop-saturate)',
      'var(--chakra-backdrop-sepia)',
    ].join(' '),
    '--chakra-backdrop-blur': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-backdrop-brightness': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-backdrop-contrast': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-backdrop-grayscale': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-backdrop-hue-rotate': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-backdrop-invert': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-backdrop-opacity': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-backdrop-saturate': 'var(--chakra-empty,/*!*/ /*!*/)',
    '--chakra-backdrop-sepia': 'var(--chakra-empty,/*!*/ /*!*/)',
  }
function WU(t) {
  return {
    '--chakra-ring-offset-shadow':
      'var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)',
    '--chakra-ring-shadow':
      'var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)',
    '--chakra-ring-width': t,
    'boxShadow': [
      'var(--chakra-ring-offset-shadow)',
      'var(--chakra-ring-shadow)',
      'var(--chakra-shadow, 0 0 #0000)',
    ].join(', '),
  }
}
var YU = {
    'row-reverse': { space: '--chakra-space-x-reverse', divide: '--chakra-divide-x-reverse' },
    'column-reverse': { space: '--chakra-space-y-reverse', divide: '--chakra-divide-y-reverse' },
  },
  _S = {
    'to-t': 'to top',
    'to-tr': 'to top right',
    'to-r': 'to right',
    'to-br': 'to bottom right',
    'to-b': 'to bottom',
    'to-bl': 'to bottom left',
    'to-l': 'to left',
    'to-tl': 'to top left',
  },
  GU = new Set(Object.values(_S)),
  kS = new Set(['none', '-moz-initial', 'inherit', 'initial', 'revert', 'unset']),
  qU = (t) => t.trim()
function KU(t, r) {
  if (t == null || kS.has(t)) return t
  if (!(DS(t) || kS.has(t))) return `url('${t}')`
  const l = /(^[a-z-A-Z]+)\((.*)\)/g.exec(t),
    f = l == null ? void 0 : l[1],
    c = l == null ? void 0 : l[2]
  if (!f || !c) return t
  const p = f.includes('-gradient') ? f : `${f}-gradient`,
    [h, ...m] = c.split(',').map(qU).filter(Boolean)
  if ((m == null ? void 0 : m.length) === 0) return t
  const g = h in _S ? _S[h] : h
  m.unshift(g)
  const b = m.map((C) => {
    if (GU.has(C)) return C
    const w = C.indexOf(' '),
      [k, D] = w !== -1 ? [C.substr(0, w), C.substr(w + 1)] : [C],
      E = DS(D) ? D : D && D.split(' '),
      M = `colors.${k}`,
      z = M in r.__cssMap ? r.__cssMap[M].varRef : k
    return E ? [z, ...(Array.isArray(E) ? E : [E])].join(' ') : z
  })
  return `${p}(${b.join(', ')})`
}
var DS = (t) => typeof t == 'string' && t.includes('(') && t.includes(')'),
  XU = (t, r) => KU(t, r ?? {})
function QU(t) {
  return /^var\(--.+\)$/.test(t)
}
var ZU = (t) => {
    const r = parseFloat(t.toString()),
      a = t.toString().replace(String(r), '')
    return { unitless: !a, value: r, unit: a }
  },
  Fi = (t) => (r) => `${t}(${r})`,
  Nt = {
    filter(t) {
      return t !== 'auto' ? t : IU
    },
    backdropFilter(t) {
      return t !== 'auto' ? t : HU
    },
    ring(t) {
      return WU(Nt.px(t))
    },
    bgClip(t) {
      return t === 'text' ? { color: 'transparent', backgroundClip: 'text' } : { backgroundClip: t }
    },
    transform(t) {
      return t === 'auto' ? UU() : t === 'auto-gpu' ? VU() : t
    },
    vh(t) {
      return t === '$100vh' ? 'var(--chakra-vh)' : t
    },
    px(t) {
      if (t == null) return t
      const { unitless: r } = ZU(t)
      return r || typeof t == 'number' ? `${t}px` : t
    },
    fraction(t) {
      return typeof t != 'number' || t > 1 ? t : `${t * 100}%`
    },
    float(t, r) {
      const a = { left: 'right', right: 'left' }
      return r.direction === 'rtl' ? a[t] : t
    },
    degree(t) {
      if (QU(t) || t == null) return t
      const r = typeof t == 'string' && !t.endsWith('deg')
      return typeof t == 'number' || r ? `${t}deg` : t
    },
    gradient: XU,
    blur: Fi('blur'),
    opacity: Fi('opacity'),
    brightness: Fi('brightness'),
    contrast: Fi('contrast'),
    dropShadow: Fi('drop-shadow'),
    grayscale: Fi('grayscale'),
    hueRotate: Fi('hue-rotate'),
    invert: Fi('invert'),
    saturate: Fi('saturate'),
    sepia: Fi('sepia'),
    bgImage(t) {
      return t == null || DS(t) || kS.has(t) ? t : `url(${t})`
    },
    outline(t) {
      const r = String(t) === '0' || String(t) === 'none'
      return t !== null && r
        ? { outline: '2px solid transparent', outlineOffset: '2px' }
        : { outline: t }
    },
    flexDirection(t) {
      var r
      const { space: a, divide: o } = (r = YU[t]) != null ? r : {},
        l = { flexDirection: t }
      return a && (l[a] = 1), o && (l[o] = 1), l
    },
  },
  U = {
    borderWidths: Ia('borderWidths'),
    borderStyles: Ia('borderStyles'),
    colors: Ia('colors'),
    borders: Ia('borders'),
    gradients: Ia('gradients', Nt.gradient),
    radii: Ia('radii', Nt.px),
    space: Ia('space', fm(Nt.vh, Nt.px)),
    spaceT: Ia('space', fm(Nt.vh, Nt.px)),
    degreeT(t) {
      return { property: t, transform: Nt.degree }
    },
    prop(t, r, a) {
      return { property: t, scale: r, ...(r && { transform: Tx({ scale: r, transform: a }) }) }
    },
    propT(t, r) {
      return { property: t, transform: r }
    },
    sizes: Ia('sizes', fm(Nt.vh, Nt.px)),
    sizesT: Ia('sizes', fm(Nt.vh, Nt.fraction)),
    shadows: Ia('shadows'),
    logical: jU,
    blur: Ia('blur', Nt.blur),
  },
  km = {
    background: U.colors('background'),
    backgroundColor: U.colors('backgroundColor'),
    backgroundImage: U.gradients('backgroundImage'),
    backgroundSize: !0,
    backgroundPosition: !0,
    backgroundRepeat: !0,
    backgroundAttachment: !0,
    backgroundClip: { transform: Nt.bgClip },
    bgSize: U.prop('backgroundSize'),
    bgPosition: U.prop('backgroundPosition'),
    bg: U.colors('background'),
    bgColor: U.colors('backgroundColor'),
    bgPos: U.prop('backgroundPosition'),
    bgRepeat: U.prop('backgroundRepeat'),
    bgAttachment: U.prop('backgroundAttachment'),
    bgGradient: U.gradients('backgroundImage'),
    bgClip: { transform: Nt.bgClip },
  }
Object.assign(km, { bgImage: km.backgroundImage, bgImg: km.backgroundImage })
var Ut = {
  border: U.borders('border'),
  borderWidth: U.borderWidths('borderWidth'),
  borderStyle: U.borderStyles('borderStyle'),
  borderColor: U.colors('borderColor'),
  borderRadius: U.radii('borderRadius'),
  borderTop: U.borders('borderTop'),
  borderBlockStart: U.borders('borderBlockStart'),
  borderTopLeftRadius: U.radii('borderTopLeftRadius'),
  borderStartStartRadius: U.logical({
    scale: 'radii',
    property: { ltr: 'borderTopLeftRadius', rtl: 'borderTopRightRadius' },
  }),
  borderEndStartRadius: U.logical({
    scale: 'radii',
    property: { ltr: 'borderBottomLeftRadius', rtl: 'borderBottomRightRadius' },
  }),
  borderTopRightRadius: U.radii('borderTopRightRadius'),
  borderStartEndRadius: U.logical({
    scale: 'radii',
    property: { ltr: 'borderTopRightRadius', rtl: 'borderTopLeftRadius' },
  }),
  borderEndEndRadius: U.logical({
    scale: 'radii',
    property: { ltr: 'borderBottomRightRadius', rtl: 'borderBottomLeftRadius' },
  }),
  borderRight: U.borders('borderRight'),
  borderInlineEnd: U.borders('borderInlineEnd'),
  borderBottom: U.borders('borderBottom'),
  borderBlockEnd: U.borders('borderBlockEnd'),
  borderBottomLeftRadius: U.radii('borderBottomLeftRadius'),
  borderBottomRightRadius: U.radii('borderBottomRightRadius'),
  borderLeft: U.borders('borderLeft'),
  borderInlineStart: { property: 'borderInlineStart', scale: 'borders' },
  borderInlineStartRadius: U.logical({
    scale: 'radii',
    property: {
      ltr: ['borderTopLeftRadius', 'borderBottomLeftRadius'],
      rtl: ['borderTopRightRadius', 'borderBottomRightRadius'],
    },
  }),
  borderInlineEndRadius: U.logical({
    scale: 'radii',
    property: {
      ltr: ['borderTopRightRadius', 'borderBottomRightRadius'],
      rtl: ['borderTopLeftRadius', 'borderBottomLeftRadius'],
    },
  }),
  borderX: U.borders(['borderLeft', 'borderRight']),
  borderInline: U.borders('borderInline'),
  borderY: U.borders(['borderTop', 'borderBottom']),
  borderBlock: U.borders('borderBlock'),
  borderTopWidth: U.borderWidths('borderTopWidth'),
  borderBlockStartWidth: U.borderWidths('borderBlockStartWidth'),
  borderTopColor: U.colors('borderTopColor'),
  borderBlockStartColor: U.colors('borderBlockStartColor'),
  borderTopStyle: U.borderStyles('borderTopStyle'),
  borderBlockStartStyle: U.borderStyles('borderBlockStartStyle'),
  borderBottomWidth: U.borderWidths('borderBottomWidth'),
  borderBlockEndWidth: U.borderWidths('borderBlockEndWidth'),
  borderBottomColor: U.colors('borderBottomColor'),
  borderBlockEndColor: U.colors('borderBlockEndColor'),
  borderBottomStyle: U.borderStyles('borderBottomStyle'),
  borderBlockEndStyle: U.borderStyles('borderBlockEndStyle'),
  borderLeftWidth: U.borderWidths('borderLeftWidth'),
  borderInlineStartWidth: U.borderWidths('borderInlineStartWidth'),
  borderLeftColor: U.colors('borderLeftColor'),
  borderInlineStartColor: U.colors('borderInlineStartColor'),
  borderLeftStyle: U.borderStyles('borderLeftStyle'),
  borderInlineStartStyle: U.borderStyles('borderInlineStartStyle'),
  borderRightWidth: U.borderWidths('borderRightWidth'),
  borderInlineEndWidth: U.borderWidths('borderInlineEndWidth'),
  borderRightColor: U.colors('borderRightColor'),
  borderInlineEndColor: U.colors('borderInlineEndColor'),
  borderRightStyle: U.borderStyles('borderRightStyle'),
  borderInlineEndStyle: U.borderStyles('borderInlineEndStyle'),
  borderTopRadius: U.radii(['borderTopLeftRadius', 'borderTopRightRadius']),
  borderBottomRadius: U.radii(['borderBottomLeftRadius', 'borderBottomRightRadius']),
  borderLeftRadius: U.radii(['borderTopLeftRadius', 'borderBottomLeftRadius']),
  borderRightRadius: U.radii(['borderTopRightRadius', 'borderBottomRightRadius']),
}
Object.assign(Ut, {
  rounded: Ut.borderRadius,
  roundedTop: Ut.borderTopRadius,
  roundedTopLeft: Ut.borderTopLeftRadius,
  roundedTopRight: Ut.borderTopRightRadius,
  roundedTopStart: Ut.borderStartStartRadius,
  roundedTopEnd: Ut.borderStartEndRadius,
  roundedBottom: Ut.borderBottomRadius,
  roundedBottomLeft: Ut.borderBottomLeftRadius,
  roundedBottomRight: Ut.borderBottomRightRadius,
  roundedBottomStart: Ut.borderEndStartRadius,
  roundedBottomEnd: Ut.borderEndEndRadius,
  roundedLeft: Ut.borderLeftRadius,
  roundedRight: Ut.borderRightRadius,
  roundedStart: Ut.borderInlineStartRadius,
  roundedEnd: Ut.borderInlineEndRadius,
  borderStart: Ut.borderInlineStart,
  borderEnd: Ut.borderInlineEnd,
  borderTopStartRadius: Ut.borderStartStartRadius,
  borderTopEndRadius: Ut.borderStartEndRadius,
  borderBottomStartRadius: Ut.borderEndStartRadius,
  borderBottomEndRadius: Ut.borderEndEndRadius,
  borderStartRadius: Ut.borderInlineStartRadius,
  borderEndRadius: Ut.borderInlineEndRadius,
  borderStartWidth: Ut.borderInlineStartWidth,
  borderEndWidth: Ut.borderInlineEndWidth,
  borderStartColor: Ut.borderInlineStartColor,
  borderEndColor: Ut.borderInlineEndColor,
  borderStartStyle: Ut.borderInlineStartStyle,
  borderEndStyle: Ut.borderInlineEndStyle,
})
var JU = {
    color: U.colors('color'),
    textColor: U.colors('color'),
    fill: U.colors('fill'),
    stroke: U.colors('stroke'),
  },
  AS = {
    boxShadow: U.shadows('boxShadow'),
    mixBlendMode: !0,
    blendMode: U.prop('mixBlendMode'),
    backgroundBlendMode: !0,
    bgBlendMode: U.prop('backgroundBlendMode'),
    opacity: !0,
  }
Object.assign(AS, { shadow: AS.boxShadow })
var eV = {
    filter: { transform: Nt.filter },
    blur: U.blur('--chakra-blur'),
    brightness: U.propT('--chakra-brightness', Nt.brightness),
    contrast: U.propT('--chakra-contrast', Nt.contrast),
    hueRotate: U.degreeT('--chakra-hue-rotate'),
    invert: U.propT('--chakra-invert', Nt.invert),
    saturate: U.propT('--chakra-saturate', Nt.saturate),
    dropShadow: U.propT('--chakra-drop-shadow', Nt.dropShadow),
    backdropFilter: { transform: Nt.backdropFilter },
    backdropBlur: U.blur('--chakra-backdrop-blur'),
    backdropBrightness: U.propT('--chakra-backdrop-brightness', Nt.brightness),
    backdropContrast: U.propT('--chakra-backdrop-contrast', Nt.contrast),
    backdropHueRotate: U.degreeT('--chakra-backdrop-hue-rotate'),
    backdropInvert: U.propT('--chakra-backdrop-invert', Nt.invert),
    backdropSaturate: U.propT('--chakra-backdrop-saturate', Nt.saturate),
  },
  Im = {
    alignItems: !0,
    alignContent: !0,
    justifyItems: !0,
    justifyContent: !0,
    flexWrap: !0,
    flexDirection: { transform: Nt.flexDirection },
    flex: !0,
    flexFlow: !0,
    flexGrow: !0,
    flexShrink: !0,
    flexBasis: U.sizes('flexBasis'),
    justifySelf: !0,
    alignSelf: !0,
    order: !0,
    placeItems: !0,
    placeContent: !0,
    placeSelf: !0,
    gap: U.space('gap'),
    rowGap: U.space('rowGap'),
    columnGap: U.space('columnGap'),
  }
Object.assign(Im, { flexDir: Im.flexDirection })
var YD = {
    gridGap: U.space('gridGap'),
    gridColumnGap: U.space('gridColumnGap'),
    gridRowGap: U.space('gridRowGap'),
    gridColumn: !0,
    gridRow: !0,
    gridAutoFlow: !0,
    gridAutoColumns: !0,
    gridColumnStart: !0,
    gridColumnEnd: !0,
    gridRowStart: !0,
    gridRowEnd: !0,
    gridAutoRows: !0,
    gridTemplate: !0,
    gridTemplateColumns: !0,
    gridTemplateRows: !0,
    gridTemplateAreas: !0,
    gridArea: !0,
  },
  tV = {
    appearance: !0,
    cursor: !0,
    resize: !0,
    userSelect: !0,
    pointerEvents: !0,
    outline: { transform: Nt.outline },
    outlineOffset: !0,
    outlineColor: U.colors('outlineColor'),
  },
  Wa = {
    width: U.sizesT('width'),
    inlineSize: U.sizesT('inlineSize'),
    height: U.sizes('height'),
    blockSize: U.sizes('blockSize'),
    boxSize: U.sizes(['width', 'height']),
    minWidth: U.sizes('minWidth'),
    minInlineSize: U.sizes('minInlineSize'),
    minHeight: U.sizes('minHeight'),
    minBlockSize: U.sizes('minBlockSize'),
    maxWidth: U.sizes('maxWidth'),
    maxInlineSize: U.sizes('maxInlineSize'),
    maxHeight: U.sizes('maxHeight'),
    maxBlockSize: U.sizes('maxBlockSize'),
    overflow: !0,
    overflowX: !0,
    overflowY: !0,
    overscrollBehavior: !0,
    overscrollBehaviorX: !0,
    overscrollBehaviorY: !0,
    display: !0,
    hideFrom: {
      scale: 'breakpoints',
      transform: (t, r) => {
        var a, o, l
        return {
          [(l =
            (o = (a = r.__breakpoints) == null ? void 0 : a.get(t)) == null
              ? void 0
              : o.minWQuery) != null
            ? l
            : `@media screen and (min-width: ${t})`]: { display: 'none' },
        }
      },
    },
    hideBelow: {
      scale: 'breakpoints',
      transform: (t, r) => {
        var a, o, l
        return {
          [(l =
            (o = (a = r.__breakpoints) == null ? void 0 : a.get(t)) == null
              ? void 0
              : o.maxWQuery) != null
            ? l
            : `@media screen and (max-width: ${t})`]: { display: 'none' },
        }
      },
    },
    verticalAlign: !0,
    boxSizing: !0,
    boxDecorationBreak: !0,
    float: U.propT('float', Nt.float),
    objectFit: !0,
    objectPosition: !0,
    visibility: !0,
    isolation: !0,
  }
Object.assign(Wa, {
  w: Wa.width,
  h: Wa.height,
  minW: Wa.minWidth,
  maxW: Wa.maxWidth,
  minH: Wa.minHeight,
  maxH: Wa.maxHeight,
  overscroll: Wa.overscrollBehavior,
  overscrollX: Wa.overscrollBehaviorX,
  overscrollY: Wa.overscrollBehaviorY,
})
var nV = {
  listStyleType: !0,
  listStylePosition: !0,
  listStylePos: U.prop('listStylePosition'),
  listStyleImage: !0,
  listStyleImg: U.prop('listStyleImage'),
}
function rV(t, r, a, o) {
  const l = typeof r == 'string' ? r.split('.') : [r]
  for (o = 0; o < l.length && t; o += 1) t = t[l[o]]
  return t === void 0 ? a : t
}
var aV = (t) => {
    const r = new WeakMap()
    return (o, l, f, c) => {
      if (typeof o > 'u') return t(o, l, f)
      r.has(o) || r.set(o, new Map())
      const p = r.get(o)
      if (p.has(l)) return p.get(l)
      const h = t(o, l, f, c)
      return p.set(l, h), h
    }
  },
  iV = aV(rV),
  oV = {
    border: '0px',
    clip: 'rect(0, 0, 0, 0)',
    width: '1px',
    height: '1px',
    margin: '-1px',
    padding: '0px',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    position: 'absolute',
  },
  sV = {
    position: 'static',
    width: 'auto',
    height: 'auto',
    clip: 'auto',
    padding: '0',
    margin: '0',
    overflow: 'visible',
    whiteSpace: 'normal',
  },
  B0 = (t, r, a) => {
    const o = {},
      l = iV(t, r, {})
    for (const f in l) (f in a && a[f] != null) || (o[f] = l[f])
    return o
  },
  lV = {
    srOnly: {
      transform(t) {
        return t === !0 ? oV : t === 'focusable' ? sV : {}
      },
    },
    layerStyle: { processResult: !0, transform: (t, r, a) => B0(r, `layerStyles.${t}`, a) },
    textStyle: { processResult: !0, transform: (t, r, a) => B0(r, `textStyles.${t}`, a) },
    apply: { processResult: !0, transform: (t, r, a) => B0(r, t, a) },
  },
  ud = {
    position: !0,
    pos: U.prop('position'),
    zIndex: U.prop('zIndex', 'zIndices'),
    inset: U.spaceT('inset'),
    insetX: U.spaceT(['left', 'right']),
    insetInline: U.spaceT('insetInline'),
    insetY: U.spaceT(['top', 'bottom']),
    insetBlock: U.spaceT('insetBlock'),
    top: U.spaceT('top'),
    insetBlockStart: U.spaceT('insetBlockStart'),
    bottom: U.spaceT('bottom'),
    insetBlockEnd: U.spaceT('insetBlockEnd'),
    left: U.spaceT('left'),
    insetInlineStart: U.logical({ scale: 'space', property: { ltr: 'left', rtl: 'right' } }),
    right: U.spaceT('right'),
    insetInlineEnd: U.logical({ scale: 'space', property: { ltr: 'right', rtl: 'left' } }),
  }
Object.assign(ud, { insetStart: ud.insetInlineStart, insetEnd: ud.insetInlineEnd })
var uV = {
    ring: { transform: Nt.ring },
    ringColor: U.colors('--chakra-ring-color'),
    ringOffset: U.prop('--chakra-ring-offset-width'),
    ringOffsetColor: U.colors('--chakra-ring-offset-color'),
    ringInset: U.prop('--chakra-ring-inset'),
  },
  xn = {
    margin: U.spaceT('margin'),
    marginTop: U.spaceT('marginTop'),
    marginBlockStart: U.spaceT('marginBlockStart'),
    marginRight: U.spaceT('marginRight'),
    marginInlineEnd: U.spaceT('marginInlineEnd'),
    marginBottom: U.spaceT('marginBottom'),
    marginBlockEnd: U.spaceT('marginBlockEnd'),
    marginLeft: U.spaceT('marginLeft'),
    marginInlineStart: U.spaceT('marginInlineStart'),
    marginX: U.spaceT(['marginInlineStart', 'marginInlineEnd']),
    marginInline: U.spaceT('marginInline'),
    marginY: U.spaceT(['marginTop', 'marginBottom']),
    marginBlock: U.spaceT('marginBlock'),
    padding: U.space('padding'),
    paddingTop: U.space('paddingTop'),
    paddingBlockStart: U.space('paddingBlockStart'),
    paddingRight: U.space('paddingRight'),
    paddingBottom: U.space('paddingBottom'),
    paddingBlockEnd: U.space('paddingBlockEnd'),
    paddingLeft: U.space('paddingLeft'),
    paddingInlineStart: U.space('paddingInlineStart'),
    paddingInlineEnd: U.space('paddingInlineEnd'),
    paddingX: U.space(['paddingInlineStart', 'paddingInlineEnd']),
    paddingInline: U.space('paddingInline'),
    paddingY: U.space(['paddingTop', 'paddingBottom']),
    paddingBlock: U.space('paddingBlock'),
  }
Object.assign(xn, {
  m: xn.margin,
  mt: xn.marginTop,
  mr: xn.marginRight,
  me: xn.marginInlineEnd,
  marginEnd: xn.marginInlineEnd,
  mb: xn.marginBottom,
  ml: xn.marginLeft,
  ms: xn.marginInlineStart,
  marginStart: xn.marginInlineStart,
  mx: xn.marginX,
  my: xn.marginY,
  p: xn.padding,
  pt: xn.paddingTop,
  py: xn.paddingY,
  px: xn.paddingX,
  pb: xn.paddingBottom,
  pl: xn.paddingLeft,
  ps: xn.paddingInlineStart,
  paddingStart: xn.paddingInlineStart,
  pr: xn.paddingRight,
  pe: xn.paddingInlineEnd,
  paddingEnd: xn.paddingInlineEnd,
})
var cV = {
    textDecorationColor: U.colors('textDecorationColor'),
    textDecoration: !0,
    textDecor: { property: 'textDecoration' },
    textDecorationLine: !0,
    textDecorationStyle: !0,
    textDecorationThickness: !0,
    textUnderlineOffset: !0,
    textShadow: U.shadows('textShadow'),
  },
  fV = {
    clipPath: !0,
    transform: U.propT('transform', Nt.transform),
    transformOrigin: !0,
    translateX: U.spaceT('--chakra-translate-x'),
    translateY: U.spaceT('--chakra-translate-y'),
    skewX: U.degreeT('--chakra-skew-x'),
    skewY: U.degreeT('--chakra-skew-y'),
    scaleX: U.prop('--chakra-scale-x'),
    scaleY: U.prop('--chakra-scale-y'),
    scale: U.prop(['--chakra-scale-x', '--chakra-scale-y']),
    rotate: U.degreeT('--chakra-rotate'),
  },
  dV = {
    transition: !0,
    transitionDelay: !0,
    animation: !0,
    willChange: !0,
    transitionDuration: U.prop('transitionDuration', 'transition.duration'),
    transitionProperty: U.prop('transitionProperty', 'transition.property'),
    transitionTimingFunction: U.prop('transitionTimingFunction', 'transition.easing'),
  },
  pV = {
    fontFamily: U.prop('fontFamily', 'fonts'),
    fontSize: U.prop('fontSize', 'fontSizes', Nt.px),
    fontWeight: U.prop('fontWeight', 'fontWeights'),
    lineHeight: U.prop('lineHeight', 'lineHeights'),
    letterSpacing: U.prop('letterSpacing', 'letterSpacings'),
    textAlign: !0,
    fontStyle: !0,
    textIndent: !0,
    wordBreak: !0,
    overflowWrap: !0,
    textOverflow: !0,
    textTransform: !0,
    whiteSpace: !0,
    isTruncated: {
      transform(t) {
        if (t === !0) return { overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }
      },
    },
    noOfLines: {
      static: {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        display: '-webkit-box',
        WebkitBoxOrient: 'vertical',
        WebkitLineClamp: 'var(--chakra-line-clamp)',
      },
      property: '--chakra-line-clamp',
    },
  },
  hV = {
    scrollBehavior: !0,
    scrollSnapAlign: !0,
    scrollSnapStop: !0,
    scrollSnapType: !0,
    scrollMargin: U.spaceT('scrollMargin'),
    scrollMarginTop: U.spaceT('scrollMarginTop'),
    scrollMarginBottom: U.spaceT('scrollMarginBottom'),
    scrollMarginLeft: U.spaceT('scrollMarginLeft'),
    scrollMarginRight: U.spaceT('scrollMarginRight'),
    scrollMarginX: U.spaceT(['scrollMarginLeft', 'scrollMarginRight']),
    scrollMarginY: U.spaceT(['scrollMarginTop', 'scrollMarginBottom']),
    scrollPadding: U.spaceT('scrollPadding'),
    scrollPaddingTop: U.spaceT('scrollPaddingTop'),
    scrollPaddingBottom: U.spaceT('scrollPaddingBottom'),
    scrollPaddingLeft: U.spaceT('scrollPaddingLeft'),
    scrollPaddingRight: U.spaceT('scrollPaddingRight'),
    scrollPaddingX: U.spaceT(['scrollPaddingLeft', 'scrollPaddingRight']),
    scrollPaddingY: U.spaceT(['scrollPaddingTop', 'scrollPaddingBottom']),
  }
function GD(t) {
  return Br(t) && t.reference ? t.reference : String(t)
}
var vv = (t, ...r) => r.map(GD).join(` ${t} `).replace(/calc/g, ''),
  BR = (...t) => `calc(${vv('+', ...t)})`,
  jR = (...t) => `calc(${vv('-', ...t)})`,
  OS = (...t) => `calc(${vv('*', ...t)})`,
  UR = (...t) => `calc(${vv('/', ...t)})`,
  VR = (t) => {
    const r = GD(t)
    return r != null && !Number.isNaN(parseFloat(r))
      ? String(r).startsWith('-')
        ? String(r).slice(1)
        : `-${r}`
      : OS(r, -1)
  },
  Rl = Object.assign(
    (t) => ({
      add: (...r) => Rl(BR(t, ...r)),
      subtract: (...r) => Rl(jR(t, ...r)),
      multiply: (...r) => Rl(OS(t, ...r)),
      divide: (...r) => Rl(UR(t, ...r)),
      negate: () => Rl(VR(t)),
      toString: () => t.toString(),
    }),
    { add: BR, subtract: jR, multiply: OS, divide: UR, negate: VR }
  )
function mV(t, r = '-') {
  return t.replace(/\s+/g, r)
}
function vV(t) {
  const r = mV(t.toString())
  return yV(gV(r))
}
function gV(t) {
  return t.includes('\\.')
    ? t
    : !Number.isInteger(parseFloat(t.toString()))
    ? t.replace('.', '\\.')
    : t
}
function yV(t) {
  return t.replace(/[!-,/:-@[-^`{-~]/g, '\\$&')
}
function bV(t, r = '') {
  return [r, t].filter(Boolean).join('-')
}
function SV(t, r) {
  return `var(${t}${r ? `, ${r}` : ''})`
}
function xV(t, r = '') {
  return vV(`--${bV(t, r)}`)
}
function xt(t, r, a) {
  const o = xV(t, a)
  return { variable: o, reference: SV(o, r) }
}
function CV(t) {
  const r = t == null ? 0 : t.length
  return r ? t[r - 1] : void 0
}
function wV(t) {
  const r = parseFloat(t.toString()),
    a = t.toString().replace(String(r), '')
  return { unitless: !a, value: r, unit: a }
}
function MS(t) {
  if (t == null) return t
  const { unitless: r } = wV(t)
  return r || typeof t == 'number' ? `${t}px` : t
}
var qD = (t, r) => (parseInt(t[1], 10) > parseInt(r[1], 10) ? 1 : -1),
  Rx = (t) => Object.fromEntries(Object.entries(t).sort(qD))
function IR(t) {
  const r = Rx(t)
  return Object.assign(Object.values(r), r)
}
function EV(t) {
  const r = Object.keys(Rx(t))
  return new Set(r)
}
function HR(t) {
  var r
  if (!t) return t
  t = (r = MS(t)) != null ? r : t
  const a = -0.02
  return typeof t == 'number'
    ? `${t + a}`
    : t.replace(/(\d+\.?\d*)/u, (o) => `${parseFloat(o) + a}`)
}
function ad(t, r) {
  const a = ['@media screen']
  return (
    t && a.push('and', `(min-width: ${MS(t)})`),
    r && a.push('and', `(max-width: ${MS(r)})`),
    a.join(' ')
  )
}
function TV(t) {
  var r
  if (!t) return null
  t.base = (r = t.base) != null ? r : '0px'
  const a = IR(t),
    o = Object.entries(t)
      .sort(qD)
      .map(([c, p], h, m) => {
        var g
        let [, b] = (g = m[h + 1]) != null ? g : []
        return (
          (b = parseFloat(b) > 0 ? HR(b) : void 0),
          {
            _minW: HR(p),
            breakpoint: c,
            minW: p,
            maxW: b,
            maxWQuery: ad(null, b),
            minWQuery: ad(p),
            minMaxQuery: ad(p, b),
          }
        )
      }),
    l = EV(t),
    f = Array.from(l.values())
  return {
    keys: l,
    normalized: a,
    isResponsive(c) {
      const p = Object.keys(c)
      return p.length > 0 && p.every((h) => l.has(h))
    },
    asObject: Rx(t),
    asArray: IR(t),
    details: o,
    get(c) {
      return o.find((p) => p.breakpoint === c)
    },
    media: [null, ...a.map((c) => ad(c)).slice(1)],
    toArrayValue(c) {
      if (!Br(c)) throw new Error('toArrayValue: value must be an object')
      const p = f.map((h) => {
        var m
        return (m = c[h]) != null ? m : null
      })
      for (; CV(p) === null; ) p.pop()
      return p
    },
    toObjectValue(c) {
      if (!Array.isArray(c)) throw new Error('toObjectValue: value must be an array')
      return c.reduce((p, h, m) => {
        const g = f[m]
        return g != null && h != null && (p[g] = h), p
      }, {})
    },
  }
}
var Rr = {
    hover: (t, r) => `${t}:hover ${r}, ${t}[data-hover] ${r}`,
    focus: (t, r) => `${t}:focus ${r}, ${t}[data-focus] ${r}`,
    focusVisible: (t, r) => `${t}:focus-visible ${r}`,
    focusWithin: (t, r) => `${t}:focus-within ${r}`,
    active: (t, r) => `${t}:active ${r}, ${t}[data-active] ${r}`,
    disabled: (t, r) => `${t}:disabled ${r}, ${t}[data-disabled] ${r}`,
    invalid: (t, r) => `${t}:invalid ${r}, ${t}[data-invalid] ${r}`,
    checked: (t, r) => `${t}:checked ${r}, ${t}[data-checked] ${r}`,
    indeterminate: (t, r) =>
      `${t}:indeterminate ${r}, ${t}[aria-checked=mixed] ${r}, ${t}[data-indeterminate] ${r}`,
    readOnly: (t, r) => `${t}:read-only ${r}, ${t}[readonly] ${r}, ${t}[data-read-only] ${r}`,
    expanded: (t, r) =>
      `${t}:read-only ${r}, ${t}[aria-expanded=true] ${r}, ${t}[data-expanded] ${r}`,
    placeholderShown: (t, r) => `${t}:placeholder-shown ${r}`,
  },
  vs = (t) => KD((r) => t(r, '&'), '[role=group]', '[data-group]', '.group'),
  Eo = (t) => KD((r) => t(r, '~ &'), '[data-peer]', '.peer'),
  KD = (t, ...r) => r.map(t).join(', '),
  gv = {
    _hover: '&:hover, &[data-hover]',
    _active: '&:active, &[data-active]',
    _focus: '&:focus, &[data-focus]',
    _highlighted: '&[data-highlighted]',
    _focusWithin: '&:focus-within',
    _focusVisible: '&:focus-visible, &[data-focus-visible]',
    _disabled: '&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]',
    _readOnly: '&[aria-readonly=true], &[readonly], &[data-readonly]',
    _before: '&::before',
    _after: '&::after',
    _empty: '&:empty',
    _expanded: '&[aria-expanded=true], &[data-expanded]',
    _checked: '&[aria-checked=true], &[data-checked]',
    _grabbed: '&[aria-grabbed=true], &[data-grabbed]',
    _pressed: '&[aria-pressed=true], &[data-pressed]',
    _invalid: '&[aria-invalid=true], &[data-invalid]',
    _valid: '&[data-valid], &[data-state=valid]',
    _loading: '&[data-loading], &[aria-busy=true]',
    _selected: '&[aria-selected=true], &[data-selected]',
    _hidden: '&[hidden], &[data-hidden]',
    _autofill: '&:-webkit-autofill',
    _even: '&:nth-of-type(even)',
    _odd: '&:nth-of-type(odd)',
    _first: '&:first-of-type',
    _firstLetter: '&::first-letter',
    _last: '&:last-of-type',
    _notFirst: '&:not(:first-of-type)',
    _notLast: '&:not(:last-of-type)',
    _visited: '&:visited',
    _activeLink: '&[aria-current=page]',
    _activeStep: '&[aria-current=step]',
    _indeterminate: '&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]',
    _groupHover: vs(Rr.hover),
    _peerHover: Eo(Rr.hover),
    _groupFocus: vs(Rr.focus),
    _peerFocus: Eo(Rr.focus),
    _groupFocusVisible: vs(Rr.focusVisible),
    _peerFocusVisible: Eo(Rr.focusVisible),
    _groupActive: vs(Rr.active),
    _peerActive: Eo(Rr.active),
    _groupDisabled: vs(Rr.disabled),
    _peerDisabled: Eo(Rr.disabled),
    _groupInvalid: vs(Rr.invalid),
    _peerInvalid: Eo(Rr.invalid),
    _groupChecked: vs(Rr.checked),
    _peerChecked: Eo(Rr.checked),
    _groupFocusWithin: vs(Rr.focusWithin),
    _peerFocusWithin: Eo(Rr.focusWithin),
    _peerPlaceholderShown: Eo(Rr.placeholderShown),
    _placeholder: '&::placeholder',
    _placeholderShown: '&:placeholder-shown',
    _fullScreen: '&:fullscreen',
    _selection: '&::selection',
    _rtl: '[dir=rtl] &, &[dir=rtl]',
    _ltr: '[dir=ltr] &, &[dir=ltr]',
    _mediaDark: '@media (prefers-color-scheme: dark)',
    _mediaReduceMotion: '@media (prefers-reduced-motion: reduce)',
    _dark:
      '.chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]',
    _light:
      '.chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]',
  },
  RV = Object.keys(gv)
function WR(t, r) {
  return xt(String(t).replace(/\./g, '-'), void 0, r)
}
function _V(t, r) {
  let a = {}
  const o = {}
  for (const [l, f] of Object.entries(t)) {
    const { isSemantic: c, value: p } = f,
      { variable: h, reference: m } = WR(l, r == null ? void 0 : r.cssVarPrefix)
    if (!c) {
      if (l.startsWith('space')) {
        const C = l.split('.'),
          [w, ...k] = C,
          D = `${w}.-${k.join('.')}`,
          E = Rl.negate(p),
          M = Rl.negate(m)
        o[D] = { value: E, var: h, varRef: M }
      }
      ;(a[h] = p), (o[l] = { value: p, var: h, varRef: m })
      continue
    }
    const g = (C) => {
        const k = [String(l).split('.')[0], C].join('.')
        if (!t[k]) return C
        const { reference: E } = WR(k, r == null ? void 0 : r.cssVarPrefix)
        return E
      },
      b = Br(p) ? p : { default: p }
    ;(a = Ya(
      a,
      Object.entries(b).reduce((C, [w, k]) => {
        var D, E
        const M = g(k)
        if (w === 'default') return (C[h] = M), C
        const z = (E = (D = gv) == null ? void 0 : D[w]) != null ? E : w
        return (C[z] = { [h]: M }), C
      }, {})
    )),
      (o[l] = { value: m, var: h, varRef: m })
  }
  return { cssVars: a, cssMap: o }
}
function kV(t, r = []) {
  const a = Object.assign({}, t)
  for (const o of r) o in a && delete a[o]
  return a
}
function DV(t, r) {
  const a = {}
  for (const o of r) o in t && (a[o] = t[o])
  return a
}
var AV = [
  'colors',
  'borders',
  'borderWidths',
  'borderStyles',
  'fonts',
  'fontSizes',
  'fontWeights',
  'gradients',
  'letterSpacings',
  'lineHeights',
  'radii',
  'space',
  'shadows',
  'sizes',
  'zIndices',
  'transition',
  'blur',
  'breakpoints',
]
function OV(t) {
  return DV(t, AV)
}
function MV(t) {
  return t.semanticTokens
}
function PV(t) {
  const { __cssMap: r, __cssVars: a, __breakpoints: o, ...l } = t
  return l
}
function LV({ tokens: t, semanticTokens: r }) {
  var a, o
  const l = Object.entries((a = PS(t)) != null ? a : {}).map(([c, p]) => [
      c,
      { isSemantic: !1, value: p },
    ]),
    f = Object.entries((o = PS(r, 1)) != null ? o : {}).map(([c, p]) => [
      c,
      { isSemantic: !0, value: p },
    ])
  return Object.fromEntries([...l, ...f])
}
function PS(t, r = 1 / 0) {
  return (!Br(t) && !Array.isArray(t)) || !r
    ? t
    : Object.entries(t).reduce(
        (a, [o, l]) => (
          Br(l) || Array.isArray(l)
            ? Object.entries(PS(l, r - 1)).forEach(([f, c]) => {
                a[`${o}.${f}`] = c
              })
            : (a[o] = l),
          a
        ),
        {}
      )
}
function zV(t) {
  var r
  const a = PV(t),
    o = OV(a),
    l = MV(a),
    f = LV({ tokens: o, semanticTokens: l }),
    c = (r = a.config) == null ? void 0 : r.cssVarPrefix,
    { cssMap: p, cssVars: h } = _V(f, { cssVarPrefix: c })
  return (
    Object.assign(a, {
      __cssVars: {
        ...{
          '--chakra-ring-inset': 'var(--chakra-empty,/*!*/ /*!*/)',
          '--chakra-ring-offset-width': '0px',
          '--chakra-ring-offset-color': '#fff',
          '--chakra-ring-color': 'rgba(66, 153, 225, 0.6)',
          '--chakra-ring-offset-shadow': '0 0 #0000',
          '--chakra-ring-shadow': '0 0 #0000',
          '--chakra-space-x-reverse': '0',
          '--chakra-space-y-reverse': '0',
        },
        ...h,
      },
      __cssMap: p,
      __breakpoints: TV(a.breakpoints),
    }),
    a
  )
}
var _x = Ya({}, km, Ut, JU, Im, Wa, eV, uV, tV, YD, lV, ud, AS, xn, hV, pV, cV, fV, nV, dV)
Object.assign({}, xn, Wa, Im, YD, ud)
var $V = [...Object.keys(_x), ...RV],
  FV = { ..._x, ...gv },
  NV = (t) => t in FV,
  BV = (t) => (r) => {
    if (!r.__breakpoints) return t
    const { isResponsive: a, toArrayValue: o, media: l } = r.__breakpoints,
      f = {}
    for (const c in t) {
      let p = ko(t[c], r)
      if (p == null) continue
      if (((p = Br(p) && a(p) ? o(p) : p), !Array.isArray(p))) {
        f[c] = p
        continue
      }
      const h = p.slice(0, l.length).length
      for (let m = 0; m < h; m += 1) {
        const g = l == null ? void 0 : l[m]
        if (!g) {
          f[c] = p[m]
          continue
        }
        ;(f[g] = f[g] || {}), p[m] != null && (f[g][c] = p[m])
      }
    }
    return f
  }
function jV(t) {
  const r = []
  let a = '',
    o = !1
  for (let l = 0; l < t.length; l++) {
    const f = t[l]
    f === '('
      ? ((o = !0), (a += f))
      : f === ')'
      ? ((o = !1), (a += f))
      : f === ',' && !o
      ? (r.push(a), (a = ''))
      : (a += f)
  }
  return (a = a.trim()), a && r.push(a), r
}
function UV(t) {
  return /^var\(--.+\)$/.test(t)
}
var VV = (t, r) => t.startsWith('--') && typeof r == 'string' && !UV(r),
  IV = (t, r) => {
    var a, o
    if (r == null) return r
    const l = (h) => {
        var m, g
        return (g = (m = t.__cssMap) == null ? void 0 : m[h]) == null ? void 0 : g.varRef
      },
      f = (h) => {
        var m
        return (m = l(h)) != null ? m : h
      },
      [c, p] = jV(r)
    return (r = (o = (a = l(c)) != null ? a : f(p)) != null ? o : f(r)), r
  }
function HV(t) {
  const { configs: r = {}, pseudos: a = {}, theme: o } = t,
    l = (f, c = !1) => {
      var p, h, m
      const g = ko(f, o),
        b = BV(g)(o)
      let C = {}
      for (let w in b) {
        const k = b[w]
        let D = ko(k, o)
        w in a && (w = a[w]), VV(w, D) && (D = IV(o, D))
        let E = r[w]
        if ((E === !0 && (E = { property: w }), Br(D))) {
          ;(C[w] = (p = C[w]) != null ? p : {}), (C[w] = Ya({}, C[w], l(D, !0)))
          continue
        }
        let M =
          (m = (h = E == null ? void 0 : E.transform) == null ? void 0 : h.call(E, D, o, g)) != null
            ? m
            : D
        M = E != null && E.processResult ? l(M, !0) : M
        const z = ko(E == null ? void 0 : E.property, o)
        if (!c && E != null && E.static) {
          const P = ko(E.static, o)
          C = Ya({}, C, P)
        }
        if (z && Array.isArray(z)) {
          for (const P of z) C[P] = M
          continue
        }
        if (z) {
          z === '&' && Br(M) ? (C = Ya({}, C, M)) : (C[z] = M)
          continue
        }
        if (Br(M)) {
          C = Ya({}, C, M)
          continue
        }
        C[w] = M
      }
      return C
    }
  return l
}
var XD = (t) => (r) => HV({ theme: r, pseudos: gv, configs: _x })(t)
function Cn(t) {
  return {
    definePartsStyle(r) {
      return r
    },
    defineMultiStyleConfig(r) {
      return { parts: t, ...r }
    },
  }
}
function WV(t, r) {
  if (Array.isArray(t)) return t
  if (Br(t)) return r(t)
  if (t != null) return [t]
}
function YV(t, r) {
  for (let a = r + 1; a < t.length; a++) if (t[a] != null) return a
  return -1
}
function GV(t) {
  const r = t.__breakpoints
  return function (o, l, f, c) {
    var p, h
    if (!r) return
    const m = {},
      g = WV(f, r.toArrayValue)
    if (!g) return m
    const b = g.length,
      C = b === 1,
      w = !!o.parts
    for (let k = 0; k < b; k++) {
      const D = r.details[k],
        E = r.details[YV(g, k)],
        M = ad(D.minW, E == null ? void 0 : E._minW),
        z = ko((p = o[l]) == null ? void 0 : p[g[k]], c)
      if (z) {
        if (w) {
          ;(h = o.parts) == null ||
            h.forEach((P) => {
              Ya(m, { [P]: C ? z[P] : { [M]: z[P] } })
            })
          continue
        }
        if (!w) {
          C ? Ya(m, z) : (m[M] = z)
          continue
        }
        m[M] = z
      }
    }
    return m
  }
}
function qV(t) {
  return (r) => {
    var a
    const { variant: o, size: l, theme: f } = r,
      c = GV(f)
    return Ya(
      {},
      ko((a = t.baseStyle) != null ? a : {}, r),
      c(t, 'sizes', l, r),
      c(t, 'variants', o, r)
    )
  }
}
function Ps(t) {
  return kV(t, ['styleConfig', 'size', 'variant', 'colorScheme'])
}
var KV = [
  'borders',
  'breakpoints',
  'colors',
  'components',
  'config',
  'direction',
  'fonts',
  'fontSizes',
  'fontWeights',
  'letterSpacings',
  'lineHeights',
  'radii',
  'shadows',
  'sizes',
  'space',
  'styles',
  'transition',
  'zIndices',
]
function XV(t) {
  return Br(t) ? KV.every((r) => Object.prototype.hasOwnProperty.call(t, r)) : !1
}
var QV = {
    hide: -1,
    auto: 'auto',
    base: 0,
    docked: 10,
    dropdown: 1e3,
    sticky: 1100,
    banner: 1200,
    overlay: 1300,
    modal: 1400,
    popover: 1500,
    skipLink: 1600,
    toast: 1700,
    tooltip: 1800,
  },
  ZV = QV,
  JV = { 'base': '0em', 'sm': '30em', 'md': '48em', 'lg': '62em', 'xl': '80em', '2xl': '96em' },
  eI = JV,
  tI = {
    transparent: 'transparent',
    current: 'currentColor',
    black: '#000000',
    white: '#FFFFFF',
    whiteAlpha: {
      50: 'rgba(255, 255, 255, 0.04)',
      100: 'rgba(255, 255, 255, 0.06)',
      200: 'rgba(255, 255, 255, 0.08)',
      300: 'rgba(255, 255, 255, 0.16)',
      400: 'rgba(255, 255, 255, 0.24)',
      500: 'rgba(255, 255, 255, 0.36)',
      600: 'rgba(255, 255, 255, 0.48)',
      700: 'rgba(255, 255, 255, 0.64)',
      800: 'rgba(255, 255, 255, 0.80)',
      900: 'rgba(255, 255, 255, 0.92)',
    },
    blackAlpha: {
      50: 'rgba(0, 0, 0, 0.04)',
      100: 'rgba(0, 0, 0, 0.06)',
      200: 'rgba(0, 0, 0, 0.08)',
      300: 'rgba(0, 0, 0, 0.16)',
      400: 'rgba(0, 0, 0, 0.24)',
      500: 'rgba(0, 0, 0, 0.36)',
      600: 'rgba(0, 0, 0, 0.48)',
      700: 'rgba(0, 0, 0, 0.64)',
      800: 'rgba(0, 0, 0, 0.80)',
      900: 'rgba(0, 0, 0, 0.92)',
    },
    gray: {
      50: '#F7FAFC',
      100: '#EDF2F7',
      200: '#E2E8F0',
      300: '#CBD5E0',
      400: '#A0AEC0',
      500: '#718096',
      600: '#4A5568',
      700: '#2D3748',
      800: '#1A202C',
      900: '#171923',
    },
    red: {
      50: '#FFF5F5',
      100: '#FED7D7',
      200: '#FEB2B2',
      300: '#FC8181',
      400: '#F56565',
      500: '#E53E3E',
      600: '#C53030',
      700: '#9B2C2C',
      800: '#822727',
      900: '#63171B',
    },
    orange: {
      50: '#FFFAF0',
      100: '#FEEBC8',
      200: '#FBD38D',
      300: '#F6AD55',
      400: '#ED8936',
      500: '#DD6B20',
      600: '#C05621',
      700: '#9C4221',
      800: '#7B341E',
      900: '#652B19',
    },
    yellow: {
      50: '#FFFFF0',
      100: '#FEFCBF',
      200: '#FAF089',
      300: '#F6E05E',
      400: '#ECC94B',
      500: '#D69E2E',
      600: '#B7791F',
      700: '#975A16',
      800: '#744210',
      900: '#5F370E',
    },
    green: {
      50: '#F0FFF4',
      100: '#C6F6D5',
      200: '#9AE6B4',
      300: '#68D391',
      400: '#48BB78',
      500: '#38A169',
      600: '#2F855A',
      700: '#276749',
      800: '#22543D',
      900: '#1C4532',
    },
    teal: {
      50: '#E6FFFA',
      100: '#B2F5EA',
      200: '#81E6D9',
      300: '#4FD1C5',
      400: '#38B2AC',
      500: '#319795',
      600: '#2C7A7B',
      700: '#285E61',
      800: '#234E52',
      900: '#1D4044',
    },
    blue: {
      50: '#ebf8ff',
      100: '#bee3f8',
      200: '#90cdf4',
      300: '#63b3ed',
      400: '#4299e1',
      500: '#3182ce',
      600: '#2b6cb0',
      700: '#2c5282',
      800: '#2a4365',
      900: '#1A365D',
    },
    cyan: {
      50: '#EDFDFD',
      100: '#C4F1F9',
      200: '#9DECF9',
      300: '#76E4F7',
      400: '#0BC5EA',
      500: '#00B5D8',
      600: '#00A3C4',
      700: '#0987A0',
      800: '#086F83',
      900: '#065666',
    },
    purple: {
      50: '#FAF5FF',
      100: '#E9D8FD',
      200: '#D6BCFA',
      300: '#B794F4',
      400: '#9F7AEA',
      500: '#805AD5',
      600: '#6B46C1',
      700: '#553C9A',
      800: '#44337A',
      900: '#322659',
    },
    pink: {
      50: '#FFF5F7',
      100: '#FED7E2',
      200: '#FBB6CE',
      300: '#F687B3',
      400: '#ED64A6',
      500: '#D53F8C',
      600: '#B83280',
      700: '#97266D',
      800: '#702459',
      900: '#521B41',
    },
    linkedin: {
      50: '#E8F4F9',
      100: '#CFEDFB',
      200: '#9BDAF3',
      300: '#68C7EC',
      400: '#34B3E4',
      500: '#00A0DC',
      600: '#008CC9',
      700: '#0077B5',
      800: '#005E93',
      900: '#004471',
    },
    facebook: {
      50: '#E8F4F9',
      100: '#D9DEE9',
      200: '#B7C2DA',
      300: '#6482C0',
      400: '#4267B2',
      500: '#385898',
      600: '#314E89',
      700: '#29487D',
      800: '#223B67',
      900: '#1E355B',
    },
    messenger: {
      50: '#D0E6FF',
      100: '#B9DAFF',
      200: '#A2CDFF',
      300: '#7AB8FF',
      400: '#2E90FF',
      500: '#0078FF',
      600: '#0063D1',
      700: '#0052AC',
      800: '#003C7E',
      900: '#002C5C',
    },
    whatsapp: {
      50: '#dffeec',
      100: '#b9f5d0',
      200: '#90edb3',
      300: '#65e495',
      400: '#3cdd78',
      500: '#22c35e',
      600: '#179848',
      700: '#0c6c33',
      800: '#01421c',
      900: '#001803',
    },
    twitter: {
      50: '#E5F4FD',
      100: '#C8E9FB',
      200: '#A8DCFA',
      300: '#83CDF7',
      400: '#57BBF5',
      500: '#1DA1F2',
      600: '#1A94DA',
      700: '#1681BF',
      800: '#136B9E',
      900: '#0D4D71',
    },
    telegram: {
      50: '#E3F2F9',
      100: '#C5E4F3',
      200: '#A2D4EC',
      300: '#7AC1E4',
      400: '#47A9DA',
      500: '#0088CC',
      600: '#007AB8',
      700: '#006BA1',
      800: '#005885',
      900: '#003F5E',
    },
  },
  nI = tI,
  rI = {
    'none': '0',
    'sm': '0.125rem',
    'base': '0.25rem',
    'md': '0.375rem',
    'lg': '0.5rem',
    'xl': '0.75rem',
    '2xl': '1rem',
    '3xl': '1.5rem',
    'full': '9999px',
  },
  aI = rI,
  iI = {
    'xs': '0 0 0 1px rgba(0, 0, 0, 0.05)',
    'sm': '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
    'base': '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
    'md': '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
    'lg': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
    'xl': '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
    'outline': '0 0 0 3px rgba(66, 153, 225, 0.6)',
    'inner': 'inset 0 2px 4px 0 rgba(0,0,0,0.06)',
    'none': 'none',
    'dark-lg':
      'rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px',
  },
  oI = iI,
  sI = {
    common: 'background-color, border-color, color, fill, stroke, opacity, box-shadow, transform',
    colors: 'background-color, border-color, color, fill, stroke',
    dimensions: 'width, height',
    position: 'left, right, top, bottom',
    background: 'background-color, background-image, background-position',
  },
  lI = {
    'ease-in': 'cubic-bezier(0.4, 0, 1, 1)',
    'ease-out': 'cubic-bezier(0, 0, 0.2, 1)',
    'ease-in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
  },
  uI = {
    'ultra-fast': '50ms',
    'faster': '100ms',
    'fast': '150ms',
    'normal': '200ms',
    'slow': '300ms',
    'slower': '400ms',
    'ultra-slow': '500ms',
  },
  cI = { property: sI, easing: lI, duration: uI },
  fI = cI,
  dI = {
    'none': 0,
    'sm': '4px',
    'base': '8px',
    'md': '12px',
    'lg': '16px',
    'xl': '24px',
    '2xl': '40px',
    '3xl': '64px',
  },
  pI = dI,
  hI = {
    'none': 0,
    '1px': '1px solid',
    '2px': '2px solid',
    '4px': '4px solid',
    '8px': '8px solid',
  },
  mI = hI,
  vI = {
    letterSpacings: {
      tighter: '-0.05em',
      tight: '-0.025em',
      normal: '0',
      wide: '0.025em',
      wider: '0.05em',
      widest: '0.1em',
    },
    lineHeights: {
      normal: 'normal',
      none: 1,
      shorter: 1.25,
      short: 1.375,
      base: 1.5,
      tall: 1.625,
      taller: '2',
      3: '.75rem',
      4: '1rem',
      5: '1.25rem',
      6: '1.5rem',
      7: '1.75rem',
      8: '2rem',
      9: '2.25rem',
      10: '2.5rem',
    },
    fontWeights: {
      hairline: 100,
      thin: 200,
      light: 300,
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700,
      extrabold: 800,
      black: 900,
    },
    fonts: {
      heading:
        '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace',
    },
    fontSizes: {
      '3xs': '0.45rem',
      '2xs': '0.625rem',
      'xs': '0.75rem',
      'sm': '0.875rem',
      'md': '1rem',
      'lg': '1.125rem',
      'xl': '1.25rem',
      '2xl': '1.5rem',
      '3xl': '1.875rem',
      '4xl': '2.25rem',
      '5xl': '3rem',
      '6xl': '3.75rem',
      '7xl': '4.5rem',
      '8xl': '6rem',
      '9xl': '8rem',
    },
  },
  QD = vI,
  ZD = {
    px: '1px',
    0.5: '0.125rem',
    1: '0.25rem',
    1.5: '0.375rem',
    2: '0.5rem',
    2.5: '0.625rem',
    3: '0.75rem',
    3.5: '0.875rem',
    4: '1rem',
    5: '1.25rem',
    6: '1.5rem',
    7: '1.75rem',
    8: '2rem',
    9: '2.25rem',
    10: '2.5rem',
    12: '3rem',
    14: '3.5rem',
    16: '4rem',
    20: '5rem',
    24: '6rem',
    28: '7rem',
    32: '8rem',
    36: '9rem',
    40: '10rem',
    44: '11rem',
    48: '12rem',
    52: '13rem',
    56: '14rem',
    60: '15rem',
    64: '16rem',
    72: '18rem',
    80: '20rem',
    96: '24rem',
  },
  gI = {
    'max': 'max-content',
    'min': 'min-content',
    'full': '100%',
    '3xs': '14rem',
    '2xs': '16rem',
    'xs': '20rem',
    'sm': '24rem',
    'md': '28rem',
    'lg': '32rem',
    'xl': '36rem',
    '2xl': '42rem',
    '3xl': '48rem',
    '4xl': '56rem',
    '5xl': '64rem',
    '6xl': '72rem',
    '7xl': '80rem',
    '8xl': '90rem',
    'prose': '60ch',
  },
  yI = { sm: '640px', md: '768px', lg: '1024px', xl: '1280px' },
  bI = { ...ZD, ...gI, container: yI },
  JD = bI,
  SI = {
    breakpoints: eI,
    zIndices: ZV,
    radii: aI,
    blur: pI,
    colors: nI,
    ...QD,
    sizes: JD,
    shadows: oI,
    space: ZD,
    borders: mI,
    transition: fI,
  }
function Xt(t, r = {}) {
  let a = !1
  function o() {
    if (!a) {
      a = !0
      return
    }
    throw new Error(
      '[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?'
    )
  }
  function l(...g) {
    o()
    for (const b of g) r[b] = h(b)
    return Xt(t, r)
  }
  function f(...g) {
    for (const b of g) b in r || (r[b] = h(b))
    return Xt(t, r)
  }
  function c() {
    return Object.fromEntries(Object.entries(r).map(([b, C]) => [b, C.selector]))
  }
  function p() {
    return Object.fromEntries(Object.entries(r).map(([b, C]) => [b, C.className]))
  }
  function h(g) {
    const w = `chakra-${(['container', 'root'].includes(g ?? '') ? [t] : [t, g])
      .filter(Boolean)
      .join('__')}`
    return { className: w, selector: `.${w}`, toString: () => g }
  }
  return {
    parts: l,
    toPart: h,
    extend: f,
    selectors: c,
    classnames: p,
    get keys() {
      return Object.keys(r)
    },
    __type: {},
  }
}
var xI = Xt('accordion').parts('root', 'container', 'button', 'panel').extend('icon'),
  CI = Xt('alert').parts('title', 'description', 'container').extend('icon', 'spinner'),
  wI = Xt('avatar').parts('label', 'badge', 'container').extend('excessLabel', 'group'),
  EI = Xt('breadcrumb').parts('link', 'item', 'container').extend('separator')
Xt('button').parts()
var TI = Xt('checkbox').parts('control', 'icon', 'container').extend('label')
Xt('progress').parts('track', 'filledTrack').extend('label')
var RI = Xt('drawer')
    .parts('overlay', 'dialogContainer', 'dialog')
    .extend('header', 'closeButton', 'body', 'footer'),
  _I = Xt('editable').parts('preview', 'input', 'textarea'),
  kI = Xt('form').parts('container', 'requiredIndicator', 'helperText'),
  DI = Xt('formError').parts('text', 'icon'),
  AI = Xt('input').parts('addon', 'field', 'element'),
  OI = Xt('list').parts('container', 'item', 'icon'),
  MI = Xt('menu').parts('button', 'list', 'item').extend('groupTitle', 'command', 'divider'),
  PI = Xt('modal')
    .parts('overlay', 'dialogContainer', 'dialog')
    .extend('header', 'closeButton', 'body', 'footer'),
  LI = Xt('numberinput').parts('root', 'field', 'stepperGroup', 'stepper')
Xt('pininput').parts('field')
var zI = Xt('popover')
    .parts('content', 'header', 'body', 'footer')
    .extend('popper', 'arrow', 'closeButton'),
  $I = Xt('progress').parts('label', 'filledTrack', 'track'),
  FI = Xt('radio').parts('container', 'control', 'label'),
  NI = Xt('select').parts('field', 'icon'),
  BI = Xt('slider').parts('container', 'track', 'thumb', 'filledTrack', 'mark'),
  jI = Xt('stat').parts('container', 'label', 'helpText', 'number', 'icon'),
  UI = Xt('switch').parts('container', 'track', 'thumb'),
  VI = Xt('table').parts('table', 'thead', 'tbody', 'tr', 'th', 'td', 'tfoot', 'caption'),
  II = Xt('tabs').parts('root', 'tab', 'tablist', 'tabpanel', 'tabpanels', 'indicator'),
  HI = Xt('tag').parts('container', 'label', 'closeButton'),
  WI = Xt('card').parts('container', 'header', 'body', 'footer')
function Ii(t, r, a) {
  return Math.min(Math.max(t, a), r)
}
class YI extends Error {
  constructor(r) {
    super(`Failed to parse color: "${r}"`)
  }
}
var id = YI
function yv(t) {
  if (typeof t != 'string') throw new id(t)
  if (t.trim().toLowerCase() === 'transparent') return [0, 0, 0, 0]
  let r = t.trim()
  r = e3.test(t) ? KI(t) : t
  const a = XI.exec(r)
  if (a) {
    const c = Array.from(a).slice(1)
    return [
      ...c.slice(0, 3).map((p) => parseInt(Ad(p, 2), 16)),
      parseInt(Ad(c[3] || 'f', 2), 16) / 255,
    ]
  }
  const o = QI.exec(r)
  if (o) {
    const c = Array.from(o).slice(1)
    return [...c.slice(0, 3).map((p) => parseInt(p, 16)), parseInt(c[3] || 'ff', 16) / 255]
  }
  const l = ZI.exec(r)
  if (l) {
    const c = Array.from(l).slice(1)
    return [...c.slice(0, 3).map((p) => parseInt(p, 10)), parseFloat(c[3] || '1')]
  }
  const f = JI.exec(r)
  if (f) {
    const [c, p, h, m] = Array.from(f).slice(1).map(parseFloat)
    if (Ii(0, 100, p) !== p) throw new id(t)
    if (Ii(0, 100, h) !== h) throw new id(t)
    return [...t3(c, p, h), Number.isNaN(m) ? 1 : m]
  }
  throw new id(t)
}
function GI(t) {
  let r = 5381,
    a = t.length
  for (; a; ) r = (r * 33) ^ t.charCodeAt(--a)
  return (r >>> 0) % 2341
}
const YR = (t) => parseInt(t.replace(/_/g, ''), 36),
  qI =
    '1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm'
      .split(' ')
      .reduce((t, r) => {
        const a = YR(r.substring(0, 3)),
          o = YR(r.substring(3)).toString(16)
        let l = ''
        for (let f = 0; f < 6 - o.length; f++) l += '0'
        return (t[a] = `${l}${o}`), t
      }, {})
function KI(t) {
  const r = t.toLowerCase().trim(),
    a = qI[GI(r)]
  if (!a) throw new id(t)
  return `#${a}`
}
const Ad = (t, r) =>
    Array.from(Array(r))
      .map(() => t)
      .join(''),
  XI = new RegExp(`^#${Ad('([a-f0-9])', 3)}([a-f0-9])?$`, 'i'),
  QI = new RegExp(`^#${Ad('([a-f0-9]{2})', 3)}([a-f0-9]{2})?$`, 'i'),
  ZI = new RegExp(
    `^rgba?\\(\\s*(\\d+)\\s*${Ad(',\\s*(\\d+)\\s*', 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`,
    'i'
  ),
  JI = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i,
  e3 = /^[a-z]+$/i,
  GR = (t) => Math.round(t * 255),
  t3 = (t, r, a) => {
    let o = a / 100
    if (r === 0) return [o, o, o].map(GR)
    const l = (((t % 360) + 360) % 360) / 60,
      f = (1 - Math.abs(2 * o - 1)) * (r / 100),
      c = f * (1 - Math.abs((l % 2) - 1))
    let p = 0,
      h = 0,
      m = 0
    l >= 0 && l < 1
      ? ((p = f), (h = c))
      : l >= 1 && l < 2
      ? ((p = c), (h = f))
      : l >= 2 && l < 3
      ? ((h = f), (m = c))
      : l >= 3 && l < 4
      ? ((h = c), (m = f))
      : l >= 4 && l < 5
      ? ((p = c), (m = f))
      : l >= 5 && l < 6 && ((p = f), (m = c))
    const g = o - f / 2,
      b = p + g,
      C = h + g,
      w = m + g
    return [b, C, w].map(GR)
  }
function n3(t) {
  const [r, a, o, l] = yv(t).map((b, C) => (C === 3 ? b : b / 255)),
    f = Math.max(r, a, o),
    c = Math.min(r, a, o),
    p = (f + c) / 2
  if (f === c) return [0, 0, p, l]
  const h = f - c,
    m = p > 0.5 ? h / (2 - f - c) : h / (f + c)
  return [
    60 * (r === f ? (a - o) / h + (a < o ? 6 : 0) : a === f ? (o - r) / h + 2 : (r - a) / h + 4),
    m,
    p,
    l,
  ]
}
function r3(t, r, a, o) {
  return `hsla(${(t % 360).toFixed()}, ${Ii(0, 100, r * 100).toFixed()}%, ${Ii(
    0,
    100,
    a * 100
  ).toFixed()}%, ${parseFloat(Ii(0, 1, o).toFixed(3))})`
}
function a3(t, r) {
  const [a, o, l, f] = n3(t)
  return r3(a, o, l - r, f)
}
function i3(t, r, a, o) {
  return `rgba(${Ii(0, 255, t).toFixed()}, ${Ii(0, 255, r).toFixed()}, ${Ii(
    0,
    255,
    a
  ).toFixed()}, ${parseFloat(Ii(0, 1, o).toFixed(3))})`
}
function eA(t, r) {
  const [a, o, l, f] = yv(t)
  return i3(a, o, l, f - r)
}
function kx(t) {
  const [r, a, o, l] = yv(t)
  let f = (c) => {
    const p = Ii(0, 255, c).toString(16)
    return p.length === 1 ? `0${p}` : p
  }
  return `#${f(r)}${f(a)}${f(o)}${l < 1 ? f(Math.round(l * 255)) : ''}`
}
function o3(t, r, a, o, l) {
  for (r = r.split ? r.split('.') : r, o = 0; o < r.length; o++) t = t ? t[r[o]] : l
  return t === l ? a : t
}
var s3 = (t) => Object.keys(t).length === 0,
  Xr = (t, r, a) => {
    const o = o3(t, `colors.${r}`, r)
    try {
      return kx(o), o
    } catch {
      return a ?? '#000000'
    }
  },
  l3 = (t) => {
    const [r, a, o] = yv(t)
    return (r * 299 + a * 587 + o * 114) / 1e3
  },
  u3 = (t) => (r) => {
    const a = Xr(r, t)
    return l3(a) < 128 ? 'dark' : 'light'
  },
  c3 = (t) => (r) => u3(t)(r) === 'dark',
  ac = (t, r) => (a) => {
    const o = Xr(a, t)
    return eA(o, 1 - r)
  }
function qR(t = '1rem', r = 'rgba(255, 255, 255, 0.15)') {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${r} 25%,
    transparent 25%,
    transparent 50%,
    ${r} 50%,
    ${r} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${t} ${t}`,
  }
}
var f3 = () =>
  `#${Math.floor(Math.random() * 16777215)
    .toString(16)
    .padEnd(6, '0')}`
function d3(t) {
  const r = f3()
  return !t || s3(t)
    ? r
    : t.string && t.colors
    ? h3(t.string, t.colors)
    : t.string && !t.colors
    ? p3(t.string)
    : t.colors && !t.string
    ? m3(t.colors)
    : r
}
function p3(t) {
  let r = 0
  if (t.length === 0) return r.toString()
  for (let o = 0; o < t.length; o += 1) (r = t.charCodeAt(o) + ((r << 5) - r)), (r = r & r)
  let a = '#'
  for (let o = 0; o < 3; o += 1) {
    const l = (r >> (o * 8)) & 255
    a += `00${l.toString(16)}`.substr(-2)
  }
  return a
}
function h3(t, r) {
  let a = 0
  if (t.length === 0) return r[0]
  for (let o = 0; o < t.length; o += 1) (a = t.charCodeAt(o) + ((a << 5) - a)), (a = a & a)
  return (a = ((a % r.length) + r.length) % r.length), r[a]
}
function m3(t) {
  return t[Math.floor(Math.random() * t.length)]
}
function Ge(t, r) {
  return (a) => (a.colorMode === 'dark' ? r : t)
}
function Dx(t) {
  const { orientation: r, vertical: a, horizontal: o } = t
  return r ? (r === 'vertical' ? a : o) : {}
}
function tA(t) {
  return Br(t) && t.reference ? t.reference : String(t)
}
var bv = (t, ...r) => r.map(tA).join(` ${t} `).replace(/calc/g, ''),
  KR = (...t) => `calc(${bv('+', ...t)})`,
  XR = (...t) => `calc(${bv('-', ...t)})`,
  LS = (...t) => `calc(${bv('*', ...t)})`,
  QR = (...t) => `calc(${bv('/', ...t)})`,
  ZR = (t) => {
    const r = tA(t)
    return r != null && !Number.isNaN(parseFloat(r))
      ? String(r).startsWith('-')
        ? String(r).slice(1)
        : `-${r}`
      : LS(r, -1)
  },
  _o = Object.assign(
    (t) => ({
      add: (...r) => _o(KR(t, ...r)),
      subtract: (...r) => _o(XR(t, ...r)),
      multiply: (...r) => _o(LS(t, ...r)),
      divide: (...r) => _o(QR(t, ...r)),
      negate: () => _o(ZR(t)),
      toString: () => t.toString(),
    }),
    { add: KR, subtract: XR, multiply: LS, divide: QR, negate: ZR }
  )
function v3(t) {
  return !Number.isInteger(parseFloat(t.toString()))
}
function g3(t, r = '-') {
  return t.replace(/\s+/g, r)
}
function nA(t) {
  const r = g3(t.toString())
  return r.includes('\\.') ? t : v3(t) ? r.replace('.', '\\.') : t
}
function y3(t, r = '') {
  return [r, nA(t)].filter(Boolean).join('-')
}
function b3(t, r) {
  return `var(${nA(t)}${r ? `, ${r}` : ''})`
}
function S3(t, r = '') {
  return `--${y3(t, r)}`
}
function ur(t, r) {
  const a = S3(t, r == null ? void 0 : r.prefix)
  return { variable: a, reference: b3(a, x3(r == null ? void 0 : r.fallback)) }
}
function x3(t) {
  return typeof t == 'string' ? t : t == null ? void 0 : t.reference
}
var { defineMultiStyleConfig: C3, definePartsStyle: Dm } = Cn(UI.keys),
  cd = ur('switch-track-width'),
  Al = ur('switch-track-height'),
  j0 = ur('switch-track-diff'),
  w3 = _o.subtract(cd, Al),
  zS = ur('switch-thumb-x'),
  Qf = ur('switch-bg'),
  E3 = (t) => {
    const { colorScheme: r } = t
    return {
      borderRadius: 'full',
      p: '0.5',
      width: [cd.reference],
      height: [Al.reference],
      transitionProperty: 'common',
      transitionDuration: 'fast',
      [Qf.variable]: 'colors.gray.300',
      _dark: { [Qf.variable]: 'colors.whiteAlpha.400' },
      _focusVisible: { boxShadow: 'outline' },
      _disabled: { opacity: 0.4, cursor: 'not-allowed' },
      _checked: { [Qf.variable]: `colors.${r}.500`, _dark: { [Qf.variable]: `colors.${r}.200` } },
      bg: Qf.reference,
    }
  },
  T3 = {
    bg: 'white',
    transitionProperty: 'transform',
    transitionDuration: 'normal',
    borderRadius: 'inherit',
    width: [Al.reference],
    height: [Al.reference],
    _checked: { transform: `translateX(${zS.reference})` },
  },
  R3 = Dm((t) => ({
    container: {
      [j0.variable]: w3,
      [zS.variable]: j0.reference,
      _rtl: { [zS.variable]: _o(j0).negate().toString() },
    },
    track: E3(t),
    thumb: T3,
  })),
  _3 = {
    sm: Dm({ container: { [cd.variable]: '1.375rem', [Al.variable]: 'sizes.3' } }),
    md: Dm({ container: { [cd.variable]: '1.875rem', [Al.variable]: 'sizes.4' } }),
    lg: Dm({ container: { [cd.variable]: '2.875rem', [Al.variable]: 'sizes.6' } }),
  },
  k3 = C3({ baseStyle: R3, sizes: _3, defaultProps: { size: 'md', colorScheme: 'blue' } }),
  { defineMultiStyleConfig: D3, definePartsStyle: Xu } = Cn(VI.keys),
  A3 = Xu({
    table: {
      fontVariantNumeric: 'lining-nums tabular-nums',
      borderCollapse: 'collapse',
      width: 'full',
    },
    th: {
      fontFamily: 'heading',
      fontWeight: 'bold',
      textTransform: 'uppercase',
      letterSpacing: 'wider',
      textAlign: 'start',
    },
    td: { textAlign: 'start' },
    caption: { mt: 4, fontFamily: 'heading', textAlign: 'center', fontWeight: 'medium' },
  }),
  Hm = { '&[data-is-numeric=true]': { textAlign: 'end' } },
  O3 = Xu((t) => {
    const { colorScheme: r } = t
    return {
      th: {
        color: Ge('gray.600', 'gray.400')(t),
        borderBottom: '1px',
        borderColor: Ge(`${r}.100`, `${r}.700`)(t),
        ...Hm,
      },
      td: { borderBottom: '1px', borderColor: Ge(`${r}.100`, `${r}.700`)(t), ...Hm },
      caption: { color: Ge('gray.600', 'gray.100')(t) },
      tfoot: { tr: { '&:last-of-type': { th: { borderBottomWidth: 0 } } } },
    }
  }),
  M3 = Xu((t) => {
    const { colorScheme: r } = t
    return {
      th: {
        color: Ge('gray.600', 'gray.400')(t),
        borderBottom: '1px',
        borderColor: Ge(`${r}.100`, `${r}.700`)(t),
        ...Hm,
      },
      td: { borderBottom: '1px', borderColor: Ge(`${r}.100`, `${r}.700`)(t), ...Hm },
      caption: { color: Ge('gray.600', 'gray.100')(t) },
      tbody: {
        tr: {
          '&:nth-of-type(odd)': {
            'th, td': { borderBottomWidth: '1px', borderColor: Ge(`${r}.100`, `${r}.700`)(t) },
            'td': { background: Ge(`${r}.100`, `${r}.700`)(t) },
          },
        },
      },
      tfoot: { tr: { '&:last-of-type': { th: { borderBottomWidth: 0 } } } },
    }
  }),
  P3 = { simple: O3, striped: M3, unstyled: {} },
  L3 = {
    sm: Xu({
      th: { px: '4', py: '1', lineHeight: '4', fontSize: 'xs' },
      td: { px: '4', py: '2', fontSize: 'sm', lineHeight: '4' },
      caption: { px: '4', py: '2', fontSize: 'xs' },
    }),
    md: Xu({
      th: { px: '6', py: '3', lineHeight: '4', fontSize: 'xs' },
      td: { px: '6', py: '4', lineHeight: '5' },
      caption: { px: '6', py: '2', fontSize: 'sm' },
    }),
    lg: Xu({
      th: { px: '8', py: '4', lineHeight: '5', fontSize: 'sm' },
      td: { px: '8', py: '5', lineHeight: '6' },
      caption: { px: '6', py: '2', fontSize: 'md' },
    }),
  },
  z3 = D3({
    baseStyle: A3,
    variants: P3,
    sizes: L3,
    defaultProps: { variant: 'simple', size: 'md', colorScheme: 'gray' },
  }),
  ua = xt('tabs-color'),
  pi = xt('tabs-bg'),
  dm = xt('tabs-border-color'),
  { defineMultiStyleConfig: $3, definePartsStyle: Wi } = Cn(II.keys),
  F3 = (t) => {
    const { orientation: r } = t
    return { display: r === 'vertical' ? 'flex' : 'block' }
  },
  N3 = (t) => {
    const { isFitted: r } = t
    return {
      flex: r ? 1 : void 0,
      transitionProperty: 'common',
      transitionDuration: 'normal',
      _focusVisible: { zIndex: 1, boxShadow: 'outline' },
      _disabled: { cursor: 'not-allowed', opacity: 0.4 },
    }
  },
  B3 = (t) => {
    const { align: r = 'start', orientation: a } = t
    return {
      justifyContent: { end: 'flex-end', center: 'center', start: 'flex-start' }[r],
      flexDirection: a === 'vertical' ? 'column' : 'row',
    }
  },
  j3 = { p: 4 },
  U3 = Wi((t) => ({ root: F3(t), tab: N3(t), tablist: B3(t), tabpanel: j3 })),
  V3 = {
    sm: Wi({ tab: { py: 1, px: 4, fontSize: 'sm' } }),
    md: Wi({ tab: { fontSize: 'md', py: 2, px: 4 } }),
    lg: Wi({ tab: { fontSize: 'lg', py: 3, px: 4 } }),
  },
  I3 = Wi((t) => {
    const { colorScheme: r, orientation: a } = t,
      o = a === 'vertical',
      l = a === 'vertical' ? 'borderStart' : 'borderBottom',
      f = o ? 'marginStart' : 'marginBottom'
    return {
      tablist: { [l]: '2px solid', borderColor: 'inherit' },
      tab: {
        [l]: '2px solid',
        borderColor: 'transparent',
        [f]: '-2px',
        _selected: {
          [ua.variable]: `colors.${r}.600`,
          _dark: { [ua.variable]: `colors.${r}.300` },
          borderColor: 'currentColor',
        },
        _active: {
          [pi.variable]: 'colors.gray.200',
          _dark: { [pi.variable]: 'colors.whiteAlpha.300' },
        },
        _disabled: { _active: { bg: 'none' } },
        color: ua.reference,
        bg: pi.reference,
      },
    }
  }),
  H3 = Wi((t) => {
    const { colorScheme: r } = t
    return {
      tab: {
        borderTopRadius: 'md',
        border: '1px solid',
        borderColor: 'transparent',
        mb: '-1px',
        [dm.variable]: 'transparent',
        _selected: {
          [ua.variable]: `colors.${r}.600`,
          [dm.variable]: 'colors.white',
          _dark: { [ua.variable]: `colors.${r}.300`, [dm.variable]: 'colors.gray.800' },
          borderColor: 'inherit',
          borderBottomColor: dm.reference,
        },
        color: ua.reference,
      },
      tablist: { mb: '-1px', borderBottom: '1px solid', borderColor: 'inherit' },
    }
  }),
  W3 = Wi((t) => {
    const { colorScheme: r } = t
    return {
      tab: {
        border: '1px solid',
        borderColor: 'inherit',
        [pi.variable]: 'colors.gray.50',
        _dark: { [pi.variable]: 'colors.whiteAlpha.50' },
        mb: '-1px',
        _notLast: { marginEnd: '-1px' },
        _selected: {
          [pi.variable]: 'colors.white',
          [ua.variable]: `colors.${r}.600`,
          _dark: { [pi.variable]: 'colors.gray.800', [ua.variable]: `colors.${r}.300` },
          borderColor: 'inherit',
          borderTopColor: 'currentColor',
          borderBottomColor: 'transparent',
        },
        color: ua.reference,
        bg: pi.reference,
      },
      tablist: { mb: '-1px', borderBottom: '1px solid', borderColor: 'inherit' },
    }
  }),
  Y3 = Wi((t) => {
    const { colorScheme: r, theme: a } = t
    return {
      tab: {
        borderRadius: 'full',
        fontWeight: 'semibold',
        color: 'gray.600',
        _selected: { color: Xr(a, `${r}.700`), bg: Xr(a, `${r}.100`) },
      },
    }
  }),
  G3 = Wi((t) => {
    const { colorScheme: r } = t
    return {
      tab: {
        borderRadius: 'full',
        fontWeight: 'semibold',
        [ua.variable]: 'colors.gray.600',
        _dark: { [ua.variable]: 'inherit' },
        _selected: {
          [ua.variable]: 'colors.white',
          [pi.variable]: `colors.${r}.600`,
          _dark: { [ua.variable]: 'colors.gray.800', [pi.variable]: `colors.${r}.300` },
        },
        color: ua.reference,
        bg: pi.reference,
      },
    }
  }),
  q3 = Wi({}),
  K3 = {
    'line': I3,
    'enclosed': H3,
    'enclosed-colored': W3,
    'soft-rounded': Y3,
    'solid-rounded': G3,
    'unstyled': q3,
  },
  X3 = $3({
    baseStyle: U3,
    sizes: V3,
    variants: K3,
    defaultProps: { size: 'md', variant: 'line', colorScheme: 'blue' },
  }),
  Od = xt('badge-bg'),
  Es = xt('badge-color'),
  rA = xt('badge-shadow'),
  Q3 = {
    px: 1,
    textTransform: 'uppercase',
    fontSize: 'xs',
    borderRadius: 'sm',
    fontWeight: 'bold',
    bg: Od.reference,
    color: Es.reference,
    boxShadow: rA.reference,
  },
  Z3 = (t) => {
    const { colorScheme: r, theme: a } = t,
      o = ac(`${r}.500`, 0.6)(a)
    return {
      [Od.variable]: `colors.${r}.500`,
      [Es.variable]: 'colors.white',
      _dark: { [Od.variable]: o, [Es.variable]: 'colors.whiteAlpha.800' },
    }
  },
  J3 = (t) => {
    const { colorScheme: r, theme: a } = t,
      o = ac(`${r}.200`, 0.16)(a)
    return {
      [Od.variable]: `colors.${r}.100`,
      [Es.variable]: `colors.${r}.800`,
      _dark: { [Od.variable]: o, [Es.variable]: `colors.${r}.200` },
    }
  },
  e4 = (t) => {
    const { colorScheme: r, theme: a } = t,
      o = ac(`${r}.200`, 0.8)(a)
    return {
      [Es.variable]: `colors.${r}.500`,
      _dark: { [Es.variable]: o },
      [rA.variable]: `inset 0 0 0px 1px ${Es.reference}`,
    }
  },
  t4 = { solid: Z3, subtle: J3, outline: e4 },
  fd = { baseStyle: Q3, variants: t4, defaultProps: { variant: 'subtle', colorScheme: 'gray' } },
  n4 = xt('badge-bg'),
  r4 = xt('badge-color'),
  { defineMultiStyleConfig: a4, definePartsStyle: Ol } = Cn(HI.keys),
  i4 = {
    fontWeight: 'medium',
    lineHeight: 1.2,
    outline: 0,
    color: r4.reference,
    bg: n4.reference,
    borderRadius: 'md',
    _focusVisible: { boxShadow: 'outline' },
  },
  o4 = { lineHeight: 1.2, overflow: 'visible' },
  s4 = {
    fontSize: 'lg',
    w: '5',
    h: '5',
    transitionProperty: 'common',
    transitionDuration: 'normal',
    borderRadius: 'full',
    marginStart: '1.5',
    marginEnd: '-1',
    opacity: 0.5,
    _disabled: { opacity: 0.4 },
    _focusVisible: { boxShadow: 'outline', bg: 'rgba(0, 0, 0, 0.14)' },
    _hover: { opacity: 0.8 },
    _active: { opacity: 1 },
  },
  l4 = Ol({ container: i4, label: o4, closeButton: s4 }),
  u4 = {
    sm: Ol({
      container: { minH: '5', minW: '5', fontSize: 'xs', px: '2' },
      closeButton: { marginEnd: '-2px', marginStart: '0.35rem' },
    }),
    md: Ol({ container: { minH: '6', minW: '6', fontSize: 'sm', px: '2' } }),
    lg: Ol({ container: { minH: '8', minW: '8', fontSize: 'md', px: '3' } }),
  },
  c4 = {
    subtle: Ol((t) => {
      var r
      return { container: (r = fd.variants) == null ? void 0 : r.subtle(t) }
    }),
    solid: Ol((t) => {
      var r
      return { container: (r = fd.variants) == null ? void 0 : r.solid(t) }
    }),
    outline: Ol((t) => {
      var r
      return { container: (r = fd.variants) == null ? void 0 : r.outline(t) }
    }),
  },
  f4 = a4({
    variants: c4,
    baseStyle: l4,
    sizes: u4,
    defaultProps: { size: 'md', variant: 'subtle', colorScheme: 'gray' },
  }),
  { definePartsStyle: Do, defineMultiStyleConfig: d4 } = Cn(AI.keys),
  p4 = Do({
    field: {
      width: '100%',
      minWidth: 0,
      outline: 0,
      position: 'relative',
      appearance: 'none',
      transitionProperty: 'common',
      transitionDuration: 'normal',
      _disabled: { opacity: 0.4, cursor: 'not-allowed' },
    },
  }),
  gs = {
    lg: { fontSize: 'lg', px: '4', h: '12', borderRadius: 'md' },
    md: { fontSize: 'md', px: '4', h: '10', borderRadius: 'md' },
    sm: { fontSize: 'sm', px: '3', h: '8', borderRadius: 'sm' },
    xs: { fontSize: 'xs', px: '2', h: '6', borderRadius: 'sm' },
  },
  h4 = {
    lg: Do({ field: gs.lg, addon: gs.lg }),
    md: Do({ field: gs.md, addon: gs.md }),
    sm: Do({ field: gs.sm, addon: gs.sm }),
    xs: Do({ field: gs.xs, addon: gs.xs }),
  }
function Ax(t) {
  const { focusBorderColor: r, errorBorderColor: a } = t
  return {
    focusBorderColor: r || Ge('blue.500', 'blue.300')(t),
    errorBorderColor: a || Ge('red.500', 'red.300')(t),
  }
}
var m4 = Do((t) => {
    const { theme: r } = t,
      { focusBorderColor: a, errorBorderColor: o } = Ax(t)
    return {
      field: {
        border: '1px solid',
        borderColor: 'inherit',
        bg: 'inherit',
        _hover: { borderColor: Ge('gray.300', 'whiteAlpha.400')(t) },
        _readOnly: { boxShadow: 'none !important', userSelect: 'all' },
        _invalid: { borderColor: Xr(r, o), boxShadow: `0 0 0 1px ${Xr(r, o)}` },
        _focusVisible: { zIndex: 1, borderColor: Xr(r, a), boxShadow: `0 0 0 1px ${Xr(r, a)}` },
      },
      addon: {
        border: '1px solid',
        borderColor: Ge('inherit', 'whiteAlpha.50')(t),
        bg: Ge('gray.100', 'whiteAlpha.300')(t),
      },
    }
  }),
  v4 = Do((t) => {
    const { theme: r } = t,
      { focusBorderColor: a, errorBorderColor: o } = Ax(t)
    return {
      field: {
        border: '2px solid',
        borderColor: 'transparent',
        bg: Ge('gray.100', 'whiteAlpha.50')(t),
        _hover: { bg: Ge('gray.200', 'whiteAlpha.100')(t) },
        _readOnly: { boxShadow: 'none !important', userSelect: 'all' },
        _invalid: { borderColor: Xr(r, o) },
        _focusVisible: { bg: 'transparent', borderColor: Xr(r, a) },
      },
      addon: {
        border: '2px solid',
        borderColor: 'transparent',
        bg: Ge('gray.100', 'whiteAlpha.50')(t),
      },
    }
  }),
  g4 = Do((t) => {
    const { theme: r } = t,
      { focusBorderColor: a, errorBorderColor: o } = Ax(t)
    return {
      field: {
        borderBottom: '1px solid',
        borderColor: 'inherit',
        borderRadius: '0',
        px: '0',
        bg: 'transparent',
        _readOnly: { boxShadow: 'none !important', userSelect: 'all' },
        _invalid: { borderColor: Xr(r, o), boxShadow: `0px 1px 0px 0px ${Xr(r, o)}` },
        _focusVisible: { borderColor: Xr(r, a), boxShadow: `0px 1px 0px 0px ${Xr(r, a)}` },
      },
      addon: {
        borderBottom: '2px solid',
        borderColor: 'inherit',
        borderRadius: '0',
        px: '0',
        bg: 'transparent',
      },
    }
  }),
  y4 = Do({
    field: { bg: 'transparent', px: '0', height: 'auto' },
    addon: { bg: 'transparent', px: '0', height: 'auto' },
  }),
  b4 = { outline: m4, filled: v4, flushed: g4, unstyled: y4 },
  It = d4({
    baseStyle: p4,
    sizes: h4,
    variants: b4,
    defaultProps: { size: 'md', variant: 'outline' },
  }),
  JR,
  S4 = {
    ...((JR = It.baseStyle) == null ? void 0 : JR.field),
    paddingY: '2',
    minHeight: '20',
    lineHeight: 'short',
    verticalAlign: 'top',
  },
  e_,
  t_,
  x4 = {
    outline: (t) => {
      var r, a
      return (a = (r = It.variants) == null ? void 0 : r.outline(t).field) != null ? a : {}
    },
    flushed: (t) => {
      var r, a
      return (a = (r = It.variants) == null ? void 0 : r.flushed(t).field) != null ? a : {}
    },
    filled: (t) => {
      var r, a
      return (a = (r = It.variants) == null ? void 0 : r.filled(t).field) != null ? a : {}
    },
    unstyled: (t_ = (e_ = It.variants) == null ? void 0 : e_.unstyled.field) != null ? t_ : {},
  },
  n_,
  r_,
  a_,
  i_,
  o_,
  s_,
  l_,
  u_,
  C4 = {
    xs: (r_ = (n_ = It.sizes) == null ? void 0 : n_.xs.field) != null ? r_ : {},
    sm: (i_ = (a_ = It.sizes) == null ? void 0 : a_.sm.field) != null ? i_ : {},
    md: (s_ = (o_ = It.sizes) == null ? void 0 : o_.md.field) != null ? s_ : {},
    lg: (u_ = (l_ = It.sizes) == null ? void 0 : l_.lg.field) != null ? u_ : {},
  },
  w4 = { baseStyle: S4, sizes: C4, variants: x4, defaultProps: { size: 'md', variant: 'outline' } },
  pm = ur('tooltip-bg'),
  U0 = ur('tooltip-fg'),
  E4 = ur('popper-arrow-bg'),
  T4 = {
    bg: pm.reference,
    color: U0.reference,
    [pm.variable]: 'colors.gray.700',
    [U0.variable]: 'colors.whiteAlpha.900',
    _dark: { [pm.variable]: 'colors.gray.300', [U0.variable]: 'colors.gray.900' },
    [E4.variable]: pm.reference,
    px: '2',
    py: '0.5',
    borderRadius: 'sm',
    fontWeight: 'medium',
    fontSize: 'sm',
    boxShadow: 'md',
    maxW: 'xs',
    zIndex: 'tooltip',
  },
  R4 = { baseStyle: T4 },
  { defineMultiStyleConfig: _4, definePartsStyle: od } = Cn($I.keys),
  k4 = (t) => {
    const { colorScheme: r, theme: a, isIndeterminate: o, hasStripe: l } = t,
      f = Ge(qR(), qR('1rem', 'rgba(0,0,0,0.1)'))(t),
      c = Ge(`${r}.500`, `${r}.200`)(t),
      p = `linear-gradient(
    to right,
    transparent 0%,
    ${Xr(a, c)} 50%,
    transparent 100%
  )`
    return { ...(!o && l && f), ...(o ? { bgImage: p } : { bgColor: c }) }
  },
  D4 = { lineHeight: '1', fontSize: '0.25em', fontWeight: 'bold', color: 'white' },
  A4 = (t) => ({ bg: Ge('gray.100', 'whiteAlpha.300')(t) }),
  O4 = (t) => ({ transitionProperty: 'common', transitionDuration: 'slow', ...k4(t) }),
  M4 = od((t) => ({ label: D4, filledTrack: O4(t), track: A4(t) })),
  P4 = {
    xs: od({ track: { h: '1' } }),
    sm: od({ track: { h: '2' } }),
    md: od({ track: { h: '3' } }),
    lg: od({ track: { h: '4' } }),
  },
  L4 = _4({ sizes: P4, baseStyle: M4, defaultProps: { size: 'md', colorScheme: 'blue' } }),
  z4 = (t) => typeof t == 'function'
function Qr(t, ...r) {
  return z4(t) ? t(...r) : t
}
var { definePartsStyle: Am, defineMultiStyleConfig: $4 } = Cn(TI.keys),
  dd = xt('checkbox-size'),
  F4 = (t) => {
    const { colorScheme: r } = t
    return {
      w: dd.reference,
      h: dd.reference,
      transitionProperty: 'box-shadow',
      transitionDuration: 'normal',
      border: '2px solid',
      borderRadius: 'sm',
      borderColor: 'inherit',
      color: 'white',
      _checked: {
        bg: Ge(`${r}.500`, `${r}.200`)(t),
        borderColor: Ge(`${r}.500`, `${r}.200`)(t),
        color: Ge('white', 'gray.900')(t),
        _hover: { bg: Ge(`${r}.600`, `${r}.300`)(t), borderColor: Ge(`${r}.600`, `${r}.300`)(t) },
        _disabled: {
          borderColor: Ge('gray.200', 'transparent')(t),
          bg: Ge('gray.200', 'whiteAlpha.300')(t),
          color: Ge('gray.500', 'whiteAlpha.500')(t),
        },
      },
      _indeterminate: {
        bg: Ge(`${r}.500`, `${r}.200`)(t),
        borderColor: Ge(`${r}.500`, `${r}.200`)(t),
        color: Ge('white', 'gray.900')(t),
      },
      _disabled: {
        bg: Ge('gray.100', 'whiteAlpha.100')(t),
        borderColor: Ge('gray.100', 'transparent')(t),
      },
      _focusVisible: { boxShadow: 'outline' },
      _invalid: { borderColor: Ge('red.500', 'red.300')(t) },
    }
  },
  N4 = { _disabled: { cursor: 'not-allowed' } },
  B4 = { userSelect: 'none', _disabled: { opacity: 0.4 } },
  j4 = { transitionProperty: 'transform', transitionDuration: 'normal' },
  U4 = Am((t) => ({ icon: j4, container: N4, control: Qr(F4, t), label: B4 })),
  V4 = {
    sm: Am({
      control: { [dd.variable]: 'sizes.3' },
      label: { fontSize: 'sm' },
      icon: { fontSize: '3xs' },
    }),
    md: Am({
      control: { [dd.variable]: 'sizes.4' },
      label: { fontSize: 'md' },
      icon: { fontSize: '2xs' },
    }),
    lg: Am({
      control: { [dd.variable]: 'sizes.5' },
      label: { fontSize: 'lg' },
      icon: { fontSize: '2xs' },
    }),
  },
  Wm = $4({ baseStyle: U4, sizes: V4, defaultProps: { size: 'md', colorScheme: 'blue' } }),
  { defineMultiStyleConfig: I4, definePartsStyle: Om } = Cn(FI.keys),
  H4 = (t) => {
    var r
    const a = (r = Qr(Wm.baseStyle, t)) == null ? void 0 : r.control
    return {
      ...a,
      borderRadius: 'full',
      _checked: {
        ...(a == null ? void 0 : a._checked),
        _before: {
          content: '""',
          display: 'inline-block',
          pos: 'relative',
          w: '50%',
          h: '50%',
          borderRadius: '50%',
          bg: 'currentColor',
        },
      },
    }
  },
  W4 = Om((t) => {
    var r, a, o, l
    return {
      label: (a = (r = Wm).baseStyle) == null ? void 0 : a.call(r, t).label,
      container: (l = (o = Wm).baseStyle) == null ? void 0 : l.call(o, t).container,
      control: H4(t),
    }
  }),
  Y4 = {
    md: Om({ control: { w: '4', h: '4' }, label: { fontSize: 'md' } }),
    lg: Om({ control: { w: '5', h: '5' }, label: { fontSize: 'lg' } }),
    sm: Om({ control: { width: '3', height: '3' }, label: { fontSize: 'sm' } }),
  },
  G4 = I4({ baseStyle: W4, sizes: Y4, defaultProps: { size: 'md', colorScheme: 'blue' } }),
  { defineMultiStyleConfig: q4, definePartsStyle: K4 } = Cn(NI.keys),
  hm = xt('select-bg'),
  c_,
  X4 = {
    ...((c_ = It.baseStyle) == null ? void 0 : c_.field),
    'appearance': 'none',
    'paddingBottom': '1px',
    'lineHeight': 'normal',
    'bg': hm.reference,
    [hm.variable]: 'colors.white',
    '_dark': { [hm.variable]: 'colors.gray.700' },
    '> option, > optgroup': { bg: hm.reference },
  },
  Q4 = {
    width: '6',
    height: '100%',
    insetEnd: '2',
    position: 'relative',
    color: 'currentColor',
    fontSize: 'xl',
    _disabled: { opacity: 0.5 },
  },
  Z4 = K4({ field: X4, icon: Q4 }),
  mm = { paddingInlineEnd: '8' },
  f_,
  d_,
  p_,
  h_,
  m_,
  v_,
  g_,
  y_,
  J4 = {
    lg: {
      ...((f_ = It.sizes) == null ? void 0 : f_.lg),
      field: { ...((d_ = It.sizes) == null ? void 0 : d_.lg.field), ...mm },
    },
    md: {
      ...((p_ = It.sizes) == null ? void 0 : p_.md),
      field: { ...((h_ = It.sizes) == null ? void 0 : h_.md.field), ...mm },
    },
    sm: {
      ...((m_ = It.sizes) == null ? void 0 : m_.sm),
      field: { ...((v_ = It.sizes) == null ? void 0 : v_.sm.field), ...mm },
    },
    xs: {
      ...((g_ = It.sizes) == null ? void 0 : g_.xs),
      field: { ...((y_ = It.sizes) == null ? void 0 : y_.xs.field), ...mm },
      icon: { insetEnd: '1' },
    },
  },
  eH = q4({ baseStyle: Z4, sizes: J4, variants: It.variants, defaultProps: It.defaultProps }),
  V0 = xt('skeleton-start-color'),
  I0 = xt('skeleton-end-color'),
  tH = {
    [V0.variable]: 'colors.gray.100',
    [I0.variable]: 'colors.gray.400',
    _dark: { [V0.variable]: 'colors.gray.800', [I0.variable]: 'colors.gray.600' },
    background: V0.reference,
    borderColor: I0.reference,
    opacity: 0.7,
    borderRadius: 'sm',
  },
  nH = { baseStyle: tH },
  H0 = xt('skip-link-bg'),
  rH = {
    borderRadius: 'md',
    fontWeight: 'semibold',
    _focusVisible: {
      boxShadow: 'outline',
      padding: '4',
      position: 'fixed',
      top: '6',
      insetStart: '6',
      [H0.variable]: 'colors.white',
      _dark: { [H0.variable]: 'colors.gray.700' },
      bg: H0.reference,
    },
  },
  aH = { baseStyle: rH },
  { defineMultiStyleConfig: iH, definePartsStyle: Sv } = Cn(BI.keys),
  Md = xt('slider-thumb-size'),
  Pd = xt('slider-track-size'),
  ws = xt('slider-bg'),
  oH = (t) => {
    const { orientation: r } = t
    return {
      display: 'inline-block',
      position: 'relative',
      cursor: 'pointer',
      _disabled: { opacity: 0.6, cursor: 'default', pointerEvents: 'none' },
      ...Dx({ orientation: r, vertical: { h: '100%' }, horizontal: { w: '100%' } }),
    }
  },
  sH = (t) => ({
    ...Dx({
      orientation: t.orientation,
      horizontal: { h: Pd.reference },
      vertical: { w: Pd.reference },
    }),
    overflow: 'hidden',
    borderRadius: 'sm',
    [ws.variable]: 'colors.gray.200',
    _dark: { [ws.variable]: 'colors.whiteAlpha.200' },
    _disabled: {
      [ws.variable]: 'colors.gray.300',
      _dark: { [ws.variable]: 'colors.whiteAlpha.300' },
    },
    bg: ws.reference,
  }),
  lH = (t) => {
    const { orientation: r } = t
    return {
      ...Dx({
        orientation: r,
        vertical: {
          left: '50%',
          transform: 'translateX(-50%)',
          _active: { transform: 'translateX(-50%) scale(1.15)' },
        },
        horizontal: {
          top: '50%',
          transform: 'translateY(-50%)',
          _active: { transform: 'translateY(-50%) scale(1.15)' },
        },
      }),
      w: Md.reference,
      h: Md.reference,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'absolute',
      outline: 0,
      zIndex: 1,
      borderRadius: 'full',
      bg: 'white',
      boxShadow: 'base',
      border: '1px solid',
      borderColor: 'transparent',
      transitionProperty: 'transform',
      transitionDuration: 'normal',
      _focusVisible: { boxShadow: 'outline' },
      _disabled: { bg: 'gray.300' },
    }
  },
  uH = (t) => {
    const { colorScheme: r } = t
    return {
      width: 'inherit',
      height: 'inherit',
      [ws.variable]: `colors.${r}.500`,
      _dark: { [ws.variable]: `colors.${r}.200` },
      bg: ws.reference,
    }
  },
  cH = Sv((t) => ({ container: oH(t), track: sH(t), thumb: lH(t), filledTrack: uH(t) })),
  fH = Sv({ container: { [Md.variable]: 'sizes.4', [Pd.variable]: 'sizes.1' } }),
  dH = Sv({ container: { [Md.variable]: 'sizes.3.5', [Pd.variable]: 'sizes.1' } }),
  pH = Sv({ container: { [Md.variable]: 'sizes.2.5', [Pd.variable]: 'sizes.0.5' } }),
  hH = { lg: fH, md: dH, sm: pH },
  mH = iH({ baseStyle: cH, sizes: hH, defaultProps: { size: 'md', colorScheme: 'blue' } }),
  _l = ur('spinner-size'),
  vH = { width: [_l.reference], height: [_l.reference] },
  gH = {
    xs: { [_l.variable]: 'sizes.3' },
    sm: { [_l.variable]: 'sizes.4' },
    md: { [_l.variable]: 'sizes.6' },
    lg: { [_l.variable]: 'sizes.8' },
    xl: { [_l.variable]: 'sizes.12' },
  },
  yH = { baseStyle: vH, sizes: gH, defaultProps: { size: 'md' } },
  { defineMultiStyleConfig: bH, definePartsStyle: aA } = Cn(jI.keys),
  SH = { fontWeight: 'medium' },
  xH = { opacity: 0.8, marginBottom: '2' },
  CH = { verticalAlign: 'baseline', fontWeight: 'semibold' },
  wH = { marginEnd: 1, w: '3.5', h: '3.5', verticalAlign: 'middle' },
  EH = aA({ container: {}, label: SH, helpText: xH, number: CH, icon: wH }),
  TH = {
    md: aA({
      label: { fontSize: 'sm' },
      helpText: { fontSize: 'sm' },
      number: { fontSize: '2xl' },
    }),
  },
  RH = bH({ baseStyle: EH, sizes: TH, defaultProps: { size: 'md' } }),
  W0 = xt('kbd-bg'),
  _H = {
    [W0.variable]: 'colors.gray.100',
    _dark: { [W0.variable]: 'colors.whiteAlpha.100' },
    bg: W0.reference,
    borderRadius: 'md',
    borderWidth: '1px',
    borderBottomWidth: '3px',
    fontSize: '0.8em',
    fontWeight: 'bold',
    lineHeight: 'normal',
    px: '0.4em',
    whiteSpace: 'nowrap',
  },
  kH = { baseStyle: _H },
  DH = {
    transitionProperty: 'common',
    transitionDuration: 'fast',
    transitionTimingFunction: 'ease-out',
    cursor: 'pointer',
    textDecoration: 'none',
    outline: 'none',
    color: 'inherit',
    _hover: { textDecoration: 'underline' },
    _focusVisible: { boxShadow: 'outline' },
  },
  AH = { baseStyle: DH },
  { defineMultiStyleConfig: OH, definePartsStyle: MH } = Cn(OI.keys),
  PH = { marginEnd: '2', display: 'inline', verticalAlign: 'text-bottom' },
  LH = MH({ icon: PH }),
  zH = OH({ baseStyle: LH }),
  { defineMultiStyleConfig: $H, definePartsStyle: FH } = Cn(MI.keys),
  ji = xt('menu-bg'),
  Y0 = xt('menu-shadow'),
  NH = {
    [ji.variable]: '#fff',
    [Y0.variable]: 'shadows.sm',
    _dark: { [ji.variable]: 'colors.gray.700', [Y0.variable]: 'shadows.dark-lg' },
    color: 'inherit',
    minW: '3xs',
    py: '2',
    zIndex: 1,
    borderRadius: 'md',
    borderWidth: '1px',
    bg: ji.reference,
    boxShadow: Y0.reference,
  },
  BH = {
    py: '1.5',
    px: '3',
    transitionProperty: 'background',
    transitionDuration: 'ultra-fast',
    transitionTimingFunction: 'ease-in',
    _focus: { [ji.variable]: 'colors.gray.100', _dark: { [ji.variable]: 'colors.whiteAlpha.100' } },
    _active: {
      [ji.variable]: 'colors.gray.200',
      _dark: { [ji.variable]: 'colors.whiteAlpha.200' },
    },
    _expanded: {
      [ji.variable]: 'colors.gray.100',
      _dark: { [ji.variable]: 'colors.whiteAlpha.100' },
    },
    _disabled: { opacity: 0.4, cursor: 'not-allowed' },
    bg: ji.reference,
  },
  jH = { mx: 4, my: 2, fontWeight: 'semibold', fontSize: 'sm' },
  UH = { opacity: 0.6 },
  VH = { border: 0, borderBottom: '1px solid', borderColor: 'inherit', my: '2', opacity: 0.6 },
  IH = { transitionProperty: 'common', transitionDuration: 'normal' },
  HH = FH({ button: IH, list: NH, item: BH, groupTitle: jH, command: UH, divider: VH }),
  WH = $H({ baseStyle: HH }),
  { defineMultiStyleConfig: YH, definePartsStyle: $S } = Cn(PI.keys),
  G0 = xt('modal-bg'),
  q0 = xt('modal-shadow'),
  GH = { bg: 'blackAlpha.600', zIndex: 'modal' },
  qH = (t) => {
    const { isCentered: r, scrollBehavior: a } = t
    return {
      display: 'flex',
      zIndex: 'modal',
      justifyContent: 'center',
      alignItems: r ? 'center' : 'flex-start',
      overflow: a === 'inside' ? 'hidden' : 'auto',
      overscrollBehaviorY: 'none',
    }
  },
  KH = (t) => {
    const { scrollBehavior: r } = t
    return {
      borderRadius: 'md',
      color: 'inherit',
      my: '16',
      zIndex: 'modal',
      maxH: r === 'inside' ? 'calc(100% - 7.5rem)' : void 0,
      [G0.variable]: 'colors.white',
      [q0.variable]: 'shadows.lg',
      _dark: { [G0.variable]: 'colors.gray.700', [q0.variable]: 'shadows.dark-lg' },
      bg: G0.reference,
      boxShadow: q0.reference,
    }
  },
  XH = { px: '6', py: '4', fontSize: 'xl', fontWeight: 'semibold' },
  QH = { position: 'absolute', top: '2', insetEnd: '3' },
  ZH = (t) => {
    const { scrollBehavior: r } = t
    return { px: '6', py: '2', flex: '1', overflow: r === 'inside' ? 'auto' : void 0 }
  },
  JH = { px: '6', py: '4' },
  e6 = $S((t) => ({
    overlay: GH,
    dialogContainer: Qr(qH, t),
    dialog: Qr(KH, t),
    header: XH,
    closeButton: QH,
    body: Qr(ZH, t),
    footer: JH,
  }))
function di(t) {
  return $S(
    t === 'full'
      ? { dialog: { maxW: '100vw', minH: '$100vh', my: '0', borderRadius: '0' } }
      : { dialog: { maxW: t } }
  )
}
var t6 = {
    'xs': di('xs'),
    'sm': di('sm'),
    'md': di('md'),
    'lg': di('lg'),
    'xl': di('xl'),
    '2xl': di('2xl'),
    '3xl': di('3xl'),
    '4xl': di('4xl'),
    '5xl': di('5xl'),
    '6xl': di('6xl'),
    'full': di('full'),
  },
  n6 = YH({ baseStyle: e6, sizes: t6, defaultProps: { size: 'md' } }),
  { defineMultiStyleConfig: r6, definePartsStyle: iA } = Cn(LI.keys),
  Ox = ur('number-input-stepper-width'),
  oA = ur('number-input-input-padding'),
  a6 = _o(Ox).add('0.5rem').toString(),
  K0 = ur('number-input-bg'),
  X0 = ur('number-input-color'),
  Q0 = ur('number-input-border-color'),
  i6 = { [Ox.variable]: 'sizes.6', [oA.variable]: a6 },
  o6 = (t) => {
    var r, a
    return (a = (r = Qr(It.baseStyle, t)) == null ? void 0 : r.field) != null ? a : {}
  },
  s6 = { width: Ox.reference },
  l6 = {
    borderStart: '1px solid',
    borderStartColor: Q0.reference,
    color: X0.reference,
    bg: K0.reference,
    [X0.variable]: 'colors.chakra-body-text',
    [Q0.variable]: 'colors.chakra-border-color',
    _dark: { [X0.variable]: 'colors.whiteAlpha.800', [Q0.variable]: 'colors.whiteAlpha.300' },
    _active: {
      [K0.variable]: 'colors.gray.200',
      _dark: { [K0.variable]: 'colors.whiteAlpha.300' },
    },
    _disabled: { opacity: 0.4, cursor: 'not-allowed' },
  },
  u6 = iA((t) => {
    var r
    return { root: i6, field: (r = Qr(o6, t)) != null ? r : {}, stepperGroup: s6, stepper: l6 }
  })
function vm(t) {
  var r, a, o
  const l = (r = It.sizes) == null ? void 0 : r[t],
    f = { lg: 'md', md: 'md', sm: 'sm', xs: 'sm' },
    c = (o = (a = l.field) == null ? void 0 : a.fontSize) != null ? o : 'md',
    p = QD.fontSizes[c]
  return iA({
    field: { ...l.field, paddingInlineEnd: oA.reference, verticalAlign: 'top' },
    stepper: {
      fontSize: _o(p).multiply(0.75).toString(),
      _first: { borderTopEndRadius: f[t] },
      _last: { borderBottomEndRadius: f[t], mt: '-1px', borderTopWidth: 1 },
    },
  })
}
var c6 = { xs: vm('xs'), sm: vm('sm'), md: vm('md'), lg: vm('lg') },
  f6 = r6({ baseStyle: u6, sizes: c6, variants: It.variants, defaultProps: It.defaultProps }),
  b_,
  d6 = { ...((b_ = It.baseStyle) == null ? void 0 : b_.field), textAlign: 'center' },
  p6 = {
    lg: { fontSize: 'lg', w: 12, h: 12, borderRadius: 'md' },
    md: { fontSize: 'md', w: 10, h: 10, borderRadius: 'md' },
    sm: { fontSize: 'sm', w: 8, h: 8, borderRadius: 'sm' },
    xs: { fontSize: 'xs', w: 6, h: 6, borderRadius: 'sm' },
  },
  S_,
  x_,
  h6 = {
    outline: (t) => {
      var r, a, o
      return (o =
        (a = Qr((r = It.variants) == null ? void 0 : r.outline, t)) == null ? void 0 : a.field) !=
        null
        ? o
        : {}
    },
    flushed: (t) => {
      var r, a, o
      return (o =
        (a = Qr((r = It.variants) == null ? void 0 : r.flushed, t)) == null ? void 0 : a.field) !=
        null
        ? o
        : {}
    },
    filled: (t) => {
      var r, a, o
      return (o =
        (a = Qr((r = It.variants) == null ? void 0 : r.filled, t)) == null ? void 0 : a.field) !=
        null
        ? o
        : {}
    },
    unstyled: (x_ = (S_ = It.variants) == null ? void 0 : S_.unstyled.field) != null ? x_ : {},
  },
  m6 = { baseStyle: d6, sizes: p6, variants: h6, defaultProps: It.defaultProps },
  { defineMultiStyleConfig: v6, definePartsStyle: g6 } = Cn(zI.keys),
  gm = ur('popper-bg'),
  y6 = ur('popper-arrow-bg'),
  C_ = ur('popper-arrow-shadow-color'),
  b6 = { zIndex: 10 },
  S6 = {
    [gm.variable]: 'colors.white',
    bg: gm.reference,
    [y6.variable]: gm.reference,
    [C_.variable]: 'colors.gray.200',
    _dark: { [gm.variable]: 'colors.gray.700', [C_.variable]: 'colors.whiteAlpha.300' },
    width: 'xs',
    border: '1px solid',
    borderColor: 'inherit',
    borderRadius: 'md',
    boxShadow: 'sm',
    zIndex: 'inherit',
    _focusVisible: { outline: 0, boxShadow: 'outline' },
  },
  x6 = { px: 3, py: 2, borderBottomWidth: '1px' },
  C6 = { px: 3, py: 2 },
  w6 = { px: 3, py: 2, borderTopWidth: '1px' },
  E6 = { position: 'absolute', borderRadius: 'md', top: 1, insetEnd: 2, padding: 2 },
  T6 = g6({ popper: b6, content: S6, header: x6, body: C6, footer: w6, closeButton: E6 }),
  R6 = v6({ baseStyle: T6 }),
  { definePartsStyle: FS, defineMultiStyleConfig: _6 } = Cn(RI.keys),
  Z0 = xt('drawer-bg'),
  J0 = xt('drawer-box-shadow')
function ju(t) {
  return FS(t === 'full' ? { dialog: { maxW: '100vw', h: '100vh' } } : { dialog: { maxW: t } })
}
var k6 = { bg: 'blackAlpha.600', zIndex: 'overlay' },
  D6 = { display: 'flex', zIndex: 'modal', justifyContent: 'center' },
  A6 = (t) => {
    const { isFullHeight: r } = t
    return {
      ...(r && { height: '100vh' }),
      zIndex: 'modal',
      maxH: '100vh',
      color: 'inherit',
      [Z0.variable]: 'colors.white',
      [J0.variable]: 'shadows.lg',
      _dark: { [Z0.variable]: 'colors.gray.700', [J0.variable]: 'shadows.dark-lg' },
      bg: Z0.reference,
      boxShadow: J0.reference,
    }
  },
  O6 = { px: '6', py: '4', fontSize: 'xl', fontWeight: 'semibold' },
  M6 = { position: 'absolute', top: '2', insetEnd: '3' },
  P6 = { px: '6', py: '2', flex: '1', overflow: 'auto' },
  L6 = { px: '6', py: '4' },
  z6 = FS((t) => ({
    overlay: k6,
    dialogContainer: D6,
    dialog: Qr(A6, t),
    header: O6,
    closeButton: M6,
    body: P6,
    footer: L6,
  })),
  $6 = { xs: ju('xs'), sm: ju('md'), md: ju('lg'), lg: ju('2xl'), xl: ju('4xl'), full: ju('full') },
  F6 = _6({ baseStyle: z6, sizes: $6, defaultProps: { size: 'xs' } }),
  { definePartsStyle: N6, defineMultiStyleConfig: B6 } = Cn(_I.keys),
  j6 = { borderRadius: 'md', py: '1', transitionProperty: 'common', transitionDuration: 'normal' },
  U6 = {
    borderRadius: 'md',
    py: '1',
    transitionProperty: 'common',
    transitionDuration: 'normal',
    width: 'full',
    _focusVisible: { boxShadow: 'outline' },
    _placeholder: { opacity: 0.6 },
  },
  V6 = {
    borderRadius: 'md',
    py: '1',
    transitionProperty: 'common',
    transitionDuration: 'normal',
    width: 'full',
    _focusVisible: { boxShadow: 'outline' },
    _placeholder: { opacity: 0.6 },
  },
  I6 = N6({ preview: j6, input: U6, textarea: V6 }),
  H6 = B6({ baseStyle: I6 }),
  { definePartsStyle: W6, defineMultiStyleConfig: Y6 } = Cn(kI.keys),
  Qu = xt('form-control-color'),
  G6 = {
    marginStart: '1',
    [Qu.variable]: 'colors.red.500',
    _dark: { [Qu.variable]: 'colors.red.300' },
    color: Qu.reference,
  },
  q6 = {
    mt: '2',
    [Qu.variable]: 'colors.gray.600',
    _dark: { [Qu.variable]: 'colors.whiteAlpha.600' },
    color: Qu.reference,
    lineHeight: 'normal',
    fontSize: 'sm',
  },
  K6 = W6({
    container: { width: '100%', position: 'relative' },
    requiredIndicator: G6,
    helperText: q6,
  }),
  X6 = Y6({ baseStyle: K6 }),
  { definePartsStyle: Q6, defineMultiStyleConfig: Z6 } = Cn(DI.keys),
  Zu = xt('form-error-color'),
  J6 = {
    [Zu.variable]: 'colors.red.500',
    _dark: { [Zu.variable]: 'colors.red.300' },
    color: Zu.reference,
    mt: '2',
    fontSize: 'sm',
    lineHeight: 'normal',
  },
  e9 = {
    marginEnd: '0.5em',
    [Zu.variable]: 'colors.red.500',
    _dark: { [Zu.variable]: 'colors.red.300' },
    color: Zu.reference,
  },
  t9 = Q6({ text: J6, icon: e9 }),
  n9 = Z6({ baseStyle: t9 }),
  r9 = {
    fontSize: 'md',
    marginEnd: '3',
    mb: '2',
    fontWeight: 'medium',
    transitionProperty: 'common',
    transitionDuration: 'normal',
    opacity: 1,
    _disabled: { opacity: 0.4 },
  },
  a9 = { baseStyle: r9 },
  i9 = { fontFamily: 'heading', fontWeight: 'bold' },
  o9 = {
    '4xl': { fontSize: ['6xl', null, '7xl'], lineHeight: 1 },
    '3xl': { fontSize: ['5xl', null, '6xl'], lineHeight: 1 },
    '2xl': { fontSize: ['4xl', null, '5xl'], lineHeight: [1.2, null, 1] },
    'xl': { fontSize: ['3xl', null, '4xl'], lineHeight: [1.33, null, 1.2] },
    'lg': { fontSize: ['2xl', null, '3xl'], lineHeight: [1.33, null, 1.2] },
    'md': { fontSize: 'xl', lineHeight: 1.2 },
    'sm': { fontSize: 'md', lineHeight: 1.2 },
    'xs': { fontSize: 'sm', lineHeight: 1.2 },
  },
  s9 = { baseStyle: i9, sizes: o9, defaultProps: { size: 'xl' } },
  { defineMultiStyleConfig: l9, definePartsStyle: u9 } = Cn(EI.keys),
  c9 = {
    transitionProperty: 'common',
    transitionDuration: 'fast',
    transitionTimingFunction: 'ease-out',
    cursor: 'pointer',
    textDecoration: 'none',
    outline: 'none',
    color: 'inherit',
    _hover: { textDecoration: 'underline' },
    _focusVisible: { boxShadow: 'outline' },
  },
  f9 = u9({ link: c9 }),
  d9 = l9({ baseStyle: f9 }),
  p9 = {
    lineHeight: '1.2',
    borderRadius: 'md',
    fontWeight: 'semibold',
    transitionProperty: 'common',
    transitionDuration: 'normal',
    _focusVisible: { boxShadow: 'outline' },
    _disabled: { opacity: 0.4, cursor: 'not-allowed', boxShadow: 'none' },
    _hover: { _disabled: { bg: 'initial' } },
  },
  sA = (t) => {
    const { colorScheme: r, theme: a } = t
    if (r === 'gray')
      return {
        color: Ge('inherit', 'whiteAlpha.900')(t),
        _hover: { bg: Ge('gray.100', 'whiteAlpha.200')(t) },
        _active: { bg: Ge('gray.200', 'whiteAlpha.300')(t) },
      }
    const o = ac(`${r}.200`, 0.12)(a),
      l = ac(`${r}.200`, 0.24)(a)
    return {
      color: Ge(`${r}.600`, `${r}.200`)(t),
      bg: 'transparent',
      _hover: { bg: Ge(`${r}.50`, o)(t) },
      _active: { bg: Ge(`${r}.100`, l)(t) },
    }
  },
  h9 = (t) => {
    const { colorScheme: r } = t,
      a = Ge('gray.200', 'whiteAlpha.300')(t)
    return {
      'border': '1px solid',
      'borderColor': r === 'gray' ? a : 'currentColor',
      '.chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)': {
        marginEnd: '-1px',
      },
      '.chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)': {
        marginBottom: '-1px',
      },
      ...Qr(sA, t),
    }
  },
  m9 = {
    yellow: { bg: 'yellow.400', color: 'black', hoverBg: 'yellow.500', activeBg: 'yellow.600' },
    cyan: { bg: 'cyan.400', color: 'black', hoverBg: 'cyan.500', activeBg: 'cyan.600' },
  },
  v9 = (t) => {
    var r
    const { colorScheme: a } = t
    if (a === 'gray') {
      const h = Ge('gray.100', 'whiteAlpha.200')(t)
      return {
        bg: h,
        _hover: { bg: Ge('gray.200', 'whiteAlpha.300')(t), _disabled: { bg: h } },
        _active: { bg: Ge('gray.300', 'whiteAlpha.400')(t) },
      }
    }
    const {
        bg: o = `${a}.500`,
        color: l = 'white',
        hoverBg: f = `${a}.600`,
        activeBg: c = `${a}.700`,
      } = (r = m9[a]) != null ? r : {},
      p = Ge(o, `${a}.200`)(t)
    return {
      bg: p,
      color: Ge(l, 'gray.800')(t),
      _hover: { bg: Ge(f, `${a}.300`)(t), _disabled: { bg: p } },
      _active: { bg: Ge(c, `${a}.400`)(t) },
    }
  },
  g9 = (t) => {
    const { colorScheme: r } = t
    return {
      padding: 0,
      height: 'auto',
      lineHeight: 'normal',
      verticalAlign: 'baseline',
      color: Ge(`${r}.500`, `${r}.200`)(t),
      _hover: { textDecoration: 'underline', _disabled: { textDecoration: 'none' } },
      _active: { color: Ge(`${r}.700`, `${r}.500`)(t) },
    }
  },
  y9 = { bg: 'none', color: 'inherit', display: 'inline', lineHeight: 'inherit', m: '0', p: '0' },
  b9 = { ghost: sA, outline: h9, solid: v9, link: g9, unstyled: y9 },
  S9 = {
    lg: { h: '12', minW: '12', fontSize: 'lg', px: '6' },
    md: { h: '10', minW: '10', fontSize: 'md', px: '4' },
    sm: { h: '8', minW: '8', fontSize: 'sm', px: '3' },
    xs: { h: '6', minW: '6', fontSize: 'xs', px: '2' },
  },
  x9 = {
    baseStyle: p9,
    variants: b9,
    sizes: S9,
    defaultProps: { variant: 'solid', size: 'md', colorScheme: 'gray' },
  },
  { definePartsStyle: Ml, defineMultiStyleConfig: C9 } = Cn(WI.keys),
  Ym = xt('card-bg'),
  Oo = xt('card-padding'),
  lA = xt('card-shadow'),
  Mm = xt('card-radius'),
  uA = xt('card-border-width', '0'),
  cA = xt('card-border-color'),
  w9 = Ml({
    container: {
      [Ym.variable]: 'colors.chakra-body-bg',
      backgroundColor: Ym.reference,
      boxShadow: lA.reference,
      borderRadius: Mm.reference,
      color: 'chakra-body-text',
      borderWidth: uA.reference,
      borderColor: cA.reference,
    },
    body: { padding: Oo.reference, flex: '1 1 0%' },
    header: { padding: Oo.reference },
    footer: { padding: Oo.reference },
  }),
  E9 = {
    sm: Ml({ container: { [Mm.variable]: 'radii.base', [Oo.variable]: 'space.3' } }),
    md: Ml({ container: { [Mm.variable]: 'radii.md', [Oo.variable]: 'space.5' } }),
    lg: Ml({ container: { [Mm.variable]: 'radii.xl', [Oo.variable]: 'space.7' } }),
  },
  T9 = {
    elevated: Ml({
      container: { [lA.variable]: 'shadows.base', _dark: { [Ym.variable]: 'colors.gray.700' } },
    }),
    outline: Ml({
      container: { [uA.variable]: '1px', [cA.variable]: 'colors.chakra-border-color' },
    }),
    filled: Ml({ container: { [Ym.variable]: 'colors.chakra-subtle-bg' } }),
    unstyled: {
      body: { [Oo.variable]: 0 },
      header: { [Oo.variable]: 0 },
      footer: { [Oo.variable]: 0 },
    },
  },
  R9 = C9({
    baseStyle: w9,
    variants: T9,
    sizes: E9,
    defaultProps: { variant: 'elevated', size: 'md' },
  }),
  pd = ur('close-button-size'),
  Zf = ur('close-button-bg'),
  _9 = {
    w: [pd.reference],
    h: [pd.reference],
    borderRadius: 'md',
    transitionProperty: 'common',
    transitionDuration: 'normal',
    _disabled: { opacity: 0.4, cursor: 'not-allowed', boxShadow: 'none' },
    _hover: {
      [Zf.variable]: 'colors.blackAlpha.100',
      _dark: { [Zf.variable]: 'colors.whiteAlpha.100' },
    },
    _active: {
      [Zf.variable]: 'colors.blackAlpha.200',
      _dark: { [Zf.variable]: 'colors.whiteAlpha.200' },
    },
    _focusVisible: { boxShadow: 'outline' },
    bg: Zf.reference,
  },
  k9 = {
    lg: { [pd.variable]: 'sizes.10', fontSize: 'md' },
    md: { [pd.variable]: 'sizes.8', fontSize: 'xs' },
    sm: { [pd.variable]: 'sizes.6', fontSize: '2xs' },
  },
  D9 = { baseStyle: _9, sizes: k9, defaultProps: { size: 'md' } },
  { variants: A9, defaultProps: O9 } = fd,
  M9 = { fontFamily: 'mono', fontSize: 'sm', px: '0.2em', borderRadius: 'sm' },
  P9 = { baseStyle: M9, variants: A9, defaultProps: O9 },
  L9 = { w: '100%', mx: 'auto', maxW: 'prose', px: '4' },
  z9 = { baseStyle: L9 },
  $9 = { opacity: 0.6, borderColor: 'inherit' },
  F9 = { borderStyle: 'solid' },
  N9 = { borderStyle: 'dashed' },
  B9 = { solid: F9, dashed: N9 },
  j9 = { baseStyle: $9, variants: B9, defaultProps: { variant: 'solid' } },
  { definePartsStyle: U9, defineMultiStyleConfig: V9 } = Cn(xI.keys),
  I9 = { borderTopWidth: '1px', borderColor: 'inherit', _last: { borderBottomWidth: '1px' } },
  H9 = {
    transitionProperty: 'common',
    transitionDuration: 'normal',
    fontSize: 'md',
    _focusVisible: { boxShadow: 'outline' },
    _hover: { bg: 'blackAlpha.50' },
    _disabled: { opacity: 0.4, cursor: 'not-allowed' },
    px: '4',
    py: '2',
  },
  W9 = { pt: '2', px: '4', pb: '5' },
  Y9 = { fontSize: '1.25em' },
  G9 = U9({ container: I9, button: H9, panel: W9, icon: Y9 }),
  q9 = V9({ baseStyle: G9 }),
  { definePartsStyle: qd, defineMultiStyleConfig: K9 } = Cn(CI.keys),
  Oa = xt('alert-fg'),
  Lo = xt('alert-bg'),
  X9 = qd({
    container: { bg: Lo.reference, px: '4', py: '3' },
    title: { fontWeight: 'bold', lineHeight: '6', marginEnd: '2' },
    description: { lineHeight: '6' },
    icon: { color: Oa.reference, flexShrink: 0, marginEnd: '3', w: '5', h: '6' },
    spinner: { color: Oa.reference, flexShrink: 0, marginEnd: '3', w: '5', h: '5' },
  })
function Mx(t) {
  const { theme: r, colorScheme: a } = t,
    o = ac(`${a}.200`, 0.16)(r)
  return { light: `colors.${a}.100`, dark: o }
}
var Q9 = qd((t) => {
    const { colorScheme: r } = t,
      a = Mx(t)
    return {
      container: {
        [Oa.variable]: `colors.${r}.500`,
        [Lo.variable]: a.light,
        _dark: { [Oa.variable]: `colors.${r}.200`, [Lo.variable]: a.dark },
      },
    }
  }),
  Z9 = qd((t) => {
    const { colorScheme: r } = t,
      a = Mx(t)
    return {
      container: {
        [Oa.variable]: `colors.${r}.500`,
        [Lo.variable]: a.light,
        _dark: { [Oa.variable]: `colors.${r}.200`, [Lo.variable]: a.dark },
        paddingStart: '3',
        borderStartWidth: '4px',
        borderStartColor: Oa.reference,
      },
    }
  }),
  J9 = qd((t) => {
    const { colorScheme: r } = t,
      a = Mx(t)
    return {
      container: {
        [Oa.variable]: `colors.${r}.500`,
        [Lo.variable]: a.light,
        _dark: { [Oa.variable]: `colors.${r}.200`, [Lo.variable]: a.dark },
        pt: '2',
        borderTopWidth: '4px',
        borderTopColor: Oa.reference,
      },
    }
  }),
  eW = qd((t) => {
    const { colorScheme: r } = t
    return {
      container: {
        [Oa.variable]: 'colors.white',
        [Lo.variable]: `colors.${r}.500`,
        _dark: { [Oa.variable]: 'colors.gray.900', [Lo.variable]: `colors.${r}.200` },
        color: Oa.reference,
      },
    }
  }),
  tW = { 'subtle': Q9, 'left-accent': Z9, 'top-accent': J9, 'solid': eW },
  nW = K9({
    baseStyle: X9,
    variants: tW,
    defaultProps: { variant: 'subtle', colorScheme: 'blue' },
  }),
  { definePartsStyle: fA, defineMultiStyleConfig: rW } = Cn(wI.keys),
  Ju = xt('avatar-border-color'),
  eS = xt('avatar-bg'),
  aW = {
    borderRadius: 'full',
    border: '0.2em solid',
    [Ju.variable]: 'white',
    _dark: { [Ju.variable]: 'colors.gray.800' },
    borderColor: Ju.reference,
  },
  iW = {
    [eS.variable]: 'colors.gray.200',
    _dark: { [eS.variable]: 'colors.whiteAlpha.400' },
    bgColor: eS.reference,
  },
  w_ = xt('avatar-background'),
  oW = (t) => {
    const { name: r, theme: a } = t,
      o = r ? d3({ string: r }) : 'colors.gray.400',
      l = c3(o)(a)
    let f = 'white'
    return (
      l || (f = 'gray.800'),
      {
        'bg': w_.reference,
        '&:not([data-loaded])': { [w_.variable]: o },
        'color': f,
        [Ju.variable]: 'colors.white',
        '_dark': { [Ju.variable]: 'colors.gray.800' },
        'borderColor': Ju.reference,
        'verticalAlign': 'top',
      }
    )
  },
  sW = fA((t) => ({ badge: Qr(aW, t), excessLabel: Qr(iW, t), container: Qr(oW, t) }))
function ys(t) {
  const r = t !== '100%' ? JD[t] : void 0
  return fA({
    container: { width: t, height: t, fontSize: `calc(${r ?? t} / 2.5)` },
    excessLabel: { width: t, height: t },
    label: { fontSize: `calc(${r ?? t} / 2.5)`, lineHeight: t !== '100%' ? r ?? t : void 0 },
  })
}
var lW = {
    '2xs': ys(4),
    'xs': ys(6),
    'sm': ys(8),
    'md': ys(12),
    'lg': ys(16),
    'xl': ys(24),
    '2xl': ys(32),
    'full': ys('100%'),
  },
  uW = rW({ baseStyle: sW, sizes: lW, defaultProps: { size: 'md' } }),
  cW = {
    Accordion: q9,
    Alert: nW,
    Avatar: uW,
    Badge: fd,
    Breadcrumb: d9,
    Button: x9,
    Checkbox: Wm,
    CloseButton: D9,
    Code: P9,
    Container: z9,
    Divider: j9,
    Drawer: F6,
    Editable: H6,
    Form: X6,
    FormError: n9,
    FormLabel: a9,
    Heading: s9,
    Input: It,
    Kbd: kH,
    Link: AH,
    List: zH,
    Menu: WH,
    Modal: n6,
    NumberInput: f6,
    PinInput: m6,
    Popover: R6,
    Progress: L4,
    Radio: G4,
    Select: eH,
    Skeleton: nH,
    SkipLink: aH,
    Slider: mH,
    Spinner: yH,
    Stat: RH,
    Switch: k3,
    Table: z3,
    Tabs: X3,
    Tag: f4,
    Textarea: w4,
    Tooltip: R4,
    Card: R9,
  },
  fW = {
    colors: {
      'chakra-body-text': { _light: 'gray.800', _dark: 'whiteAlpha.900' },
      'chakra-body-bg': { _light: 'white', _dark: 'gray.800' },
      'chakra-border-color': { _light: 'gray.200', _dark: 'whiteAlpha.300' },
      'chakra-subtle-bg': { _light: 'gray.100', _dark: 'gray.700' },
      'chakra-placeholder-color': { _light: 'gray.500', _dark: 'whiteAlpha.400' },
    },
  },
  dW = {
    global: {
      'body': {
        fontFamily: 'body',
        color: 'chakra-body-text',
        bg: 'chakra-body-bg',
        transitionProperty: 'background-color',
        transitionDuration: 'normal',
        lineHeight: 'base',
      },
      '*::placeholder': { color: 'chakra-placeholder-color' },
      '*, *::before, &::after': { borderColor: 'chakra-border-color' },
    },
  },
  pW = 'ltr',
  hW = { useSystemColorMode: !1, initialColorMode: 'light', cssVarPrefix: 'chakra' },
  dA = { semanticTokens: fW, direction: pW, ...SI, components: cW, styles: dW, config: hW }
function sd(t) {
  return typeof t == 'function'
}
function mW(...t) {
  return (r) => t.reduce((a, o) => o(a), r)
}
var vW = (t) =>
    function (...a) {
      let o = [...a],
        l = a[a.length - 1]
      return (
        XV(l) && o.length > 1 ? (o = o.slice(0, o.length - 1)) : (l = t),
        mW(...o.map((f) => (c) => sd(f) ? f(c) : yW(c, f)))(l)
      )
    },
  gW = vW(dA)
function yW(...t) {
  return Ya({}, ...t, pA)
}
function pA(t, r, a, o) {
  if ((sd(t) || sd(r)) && Object.prototype.hasOwnProperty.call(o, a))
    return (...l) => {
      const f = sd(t) ? t(...l) : t,
        c = sd(r) ? r(...l) : r
      return Ya({}, f, c, pA)
    }
}
function bW(t, r) {
  const a = {}
  return (
    Object.keys(t).forEach((o) => {
      r.includes(o) || (a[o] = t[o])
    }),
    a
  )
}
function SW(t, r, a, o) {
  const l = typeof r == 'string' ? r.split('.') : [r]
  for (o = 0; o < l.length && t; o += 1) t = t[l[o]]
  return t === void 0 ? a : t
}
var xW = (t) => {
    const r = new WeakMap()
    return (o, l, f, c) => {
      if (typeof o > 'u') return t(o, l, f)
      r.has(o) || r.set(o, new Map())
      const p = r.get(o)
      if (p.has(l)) return p.get(l)
      const h = t(o, l, f, c)
      return p.set(l, h), h
    }
  },
  hA = xW(SW)
function mA(t, r) {
  const a = {}
  return (
    Object.keys(t).forEach((o) => {
      const l = t[o]
      r(l, o, t) && (a[o] = l)
    }),
    a
  )
}
var vA = (t) => mA(t, (r) => r != null)
function CW(t) {
  return typeof t == 'function'
}
function gA(t, ...r) {
  return CW(t) ? t(...r) : t
}
var wW = typeof Element < 'u',
  EW = typeof Map == 'function',
  TW = typeof Set == 'function',
  RW = typeof ArrayBuffer == 'function' && !!ArrayBuffer.isView
function Pm(t, r) {
  if (t === r) return !0
  if (t && r && typeof t == 'object' && typeof r == 'object') {
    if (t.constructor !== r.constructor) return !1
    var a, o, l
    if (Array.isArray(t)) {
      if (((a = t.length), a != r.length)) return !1
      for (o = a; o-- !== 0; ) if (!Pm(t[o], r[o])) return !1
      return !0
    }
    var f
    if (EW && t instanceof Map && r instanceof Map) {
      if (t.size !== r.size) return !1
      for (f = t.entries(); !(o = f.next()).done; ) if (!r.has(o.value[0])) return !1
      for (f = t.entries(); !(o = f.next()).done; )
        if (!Pm(o.value[1], r.get(o.value[0]))) return !1
      return !0
    }
    if (TW && t instanceof Set && r instanceof Set) {
      if (t.size !== r.size) return !1
      for (f = t.entries(); !(o = f.next()).done; ) if (!r.has(o.value[0])) return !1
      return !0
    }
    if (RW && ArrayBuffer.isView(t) && ArrayBuffer.isView(r)) {
      if (((a = t.length), a != r.length)) return !1
      for (o = a; o-- !== 0; ) if (t[o] !== r[o]) return !1
      return !0
    }
    if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf()
    if (t.toString !== Object.prototype.toString) return t.toString() === r.toString()
    if (((l = Object.keys(t)), (a = l.length), a !== Object.keys(r).length)) return !1
    for (o = a; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(r, l[o])) return !1
    if (wW && t instanceof Element) return !1
    for (o = a; o-- !== 0; )
      if (
        !((l[o] === '_owner' || l[o] === '__v' || l[o] === '__o') && t.$$typeof) &&
        !Pm(t[l[o]], r[l[o]])
      )
        return !1
    return !0
  }
  return t !== t && r !== r
}
var _W = function (r, a) {
  try {
    return Pm(r, a)
  } catch (o) {
    if ((o.message || '').match(/stack|recursion/i))
      return console.warn('react-fast-compare cannot handle circular refs'), !1
    throw o
  }
}
function yA(t, r = {}) {
  var a
  const { styleConfig: o, ...l } = r,
    { theme: f, colorMode: c } = PU(),
    p = t ? hA(f, `components.${t}`) : void 0,
    h = o || p,
    m = Ya(
      { theme: f, colorMode: c },
      (a = h == null ? void 0 : h.defaultProps) != null ? a : {},
      vA(bW(l, ['children']))
    ),
    g = R.useRef({})
  if (h) {
    const C = qV(h)(m)
    _W(g.current, C) || (g.current = C)
  }
  return g.current
}
function $l(t, r = {}) {
  return yA(t, r)
}
function bA(t, r = {}) {
  return yA(t, r)
}
var kW = new Set([
    ...$V,
    'textStyle',
    'layerStyle',
    'apply',
    'noOfLines',
    'focusBorderColor',
    'errorBorderColor',
    'as',
    '__css',
    'css',
    'sx',
  ]),
  DW = new Set(['htmlWidth', 'htmlHeight', 'htmlSize', 'htmlTranslate'])
function AW(t) {
  return DW.has(t) || !kW.has(t)
}
function OW(t) {
  const r = Object.assign({}, t)
  for (let a in r) r[a] === void 0 && delete r[a]
  return r
}
function MW(t, ...r) {
  if (t == null) throw new TypeError('Cannot convert undefined or null to object')
  const a = { ...t }
  for (const o of r)
    if (o != null)
      for (const l in o)
        Object.prototype.hasOwnProperty.call(o, l) && (l in a && delete a[l], (a[l] = o[l]))
  return a
}
var PW =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  LW = AD(function (t) {
    return (
      PW.test(t) || (t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91)
    )
  }),
  zW = LW,
  $W = function (r) {
    return r !== 'theme'
  },
  E_ = function (r) {
    return typeof r == 'string' && r.charCodeAt(0) > 96 ? zW : $W
  },
  T_ = function (r, a, o) {
    var l
    if (a) {
      var f = a.shouldForwardProp
      l =
        r.__emotion_forwardProp && f
          ? function (c) {
              return r.__emotion_forwardProp(c) && f(c)
            }
          : f
    }
    return typeof l != 'function' && o && (l = r.__emotion_forwardProp), l
  },
  R_ = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`,
  FW = function (r) {
    var a = r.cache,
      o = r.serialized,
      l = r.isStringTag
    return (
      fv(a, o, l),
      Sx(function () {
        return dv(a, o, l)
      }),
      null
    )
  },
  NW = function t(r, a) {
    if (r === void 0)
      throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`)
    var o = r.__emotion_real === r,
      l = (o && r.__emotion_base) || r,
      f,
      c
    a !== void 0 && ((f = a.label), (c = a.target))
    var p = T_(r, a, o),
      h = p || E_(l),
      m = !h('as')
    return function () {
      var g = arguments,
        b = o && r.__emotion_styles !== void 0 ? r.__emotion_styles.slice(0) : []
      if ((f !== void 0 && b.push('label:' + f + ';'), g[0] == null || g[0].raw === void 0))
        b.push.apply(b, g)
      else {
        g[0][0] === void 0 && console.error(R_), b.push(g[0][0])
        for (var C = g.length, w = 1; w < C; w++)
          g[0][w] === void 0 && console.error(R_), b.push(g[w], g[0][w])
      }
      var k = pv(function (D, E, M) {
        var z = (m && D.as) || l,
          P = '',
          B = [],
          j = D
        if (D.theme == null) {
          j = {}
          for (var Q in D) j[Q] = D[Q]
          j.theme = R.useContext(ks)
        }
        typeof D.className == 'string'
          ? (P = yx(E.registered, B, D.className))
          : D.className != null && (P = D.className + ' ')
        var Y = rc(b.concat(B), E.registered, j)
        ;(P += E.key + '-' + Y.name), c !== void 0 && (P += ' ' + c)
        var ne = m && p === void 0 ? E_(z) : h,
          he = {}
        for (var le in D) (m && le === 'as') || (ne(le) && (he[le] = D[le]))
        return (
          (he.className = P),
          (he.ref = M),
          R.createElement(
            R.Fragment,
            null,
            R.createElement(FW, { cache: E, serialized: Y, isStringTag: typeof z == 'string' }),
            R.createElement(z, he)
          )
        )
      })
      return (
        (k.displayName =
          f !== void 0
            ? f
            : 'Styled(' +
              (typeof l == 'string' ? l : l.displayName || l.name || 'Component') +
              ')'),
        (k.defaultProps = r.defaultProps),
        (k.__emotion_real = k),
        (k.__emotion_base = l),
        (k.__emotion_styles = b),
        (k.__emotion_forwardProp = p),
        Object.defineProperty(k, 'toString', {
          value: function () {
            return c === void 0 ? 'NO_COMPONENT_SELECTOR' : '.' + c
          },
        }),
        (k.withComponent = function (D, E) {
          return t(D, Bm({}, a, E, { shouldForwardProp: T_(k, E, !0) })).apply(void 0, b)
        }),
        k
      )
    }
  },
  BW = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'big',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'marquee',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
    'circle',
    'clipPath',
    'defs',
    'ellipse',
    'foreignObject',
    'g',
    'image',
    'line',
    'linearGradient',
    'mask',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'stop',
    'svg',
    'text',
    'tspan',
  ],
  Gm = NW.bind()
BW.forEach(function (t) {
  Gm[t] = Gm(t)
})
var __,
  jW = (__ = Gm.default) != null ? __ : Gm,
  UW =
    ({ baseStyle: t }) =>
    (r) => {
      const { theme: a, css: o, __css: l, sx: f, ...c } = r,
        p = mA(c, (b, C) => NV(C)),
        h = gA(t, r),
        m = MW({}, l, h, vA(p), f),
        g = XD(m)(r.theme)
      return o ? [g, o] : g
    }
function tS(t, r) {
  const { baseStyle: a, ...o } = r ?? {}
  o.shouldForwardProp || (o.shouldForwardProp = AW)
  const l = UW({ baseStyle: a }),
    f = jW(t, o)(l)
  return ca.forwardRef(function (h, m) {
    const { colorMode: g, forced: b } = Ex()
    return ca.createElement(f, { 'ref': m, 'data-theme': b ? g : void 0, ...h })
  })
}
function VW() {
  const t = new Map()
  return new Proxy(tS, {
    apply(r, a, o) {
      return tS(...o)
    },
    get(r, a) {
      return t.has(a) || t.set(a, tS(a)), t.get(a)
    },
  })
}
var Ht = VW()
function _n(t) {
  return R.forwardRef(t)
}
function IW(t = {}) {
  const {
      strict: r = !0,
      errorMessage:
        a = 'useContext: `context` is undefined. Seems you forgot to wrap component within the Provider',
      name: o,
    } = t,
    l = R.createContext(void 0)
  l.displayName = o
  function f() {
    var c
    const p = R.useContext(l)
    if (!p && r) {
      const h = new Error(a)
      throw (
        ((h.name = 'ContextError'), (c = Error.captureStackTrace) == null || c.call(Error, h, f), h)
      )
    }
    return p
  }
  return [l.Provider, f, l]
}
function HW(t) {
  const { cssVarsRoot: r, theme: a, children: o } = t,
    l = R.useMemo(() => zV(a), [a])
  return He(oU, { theme: l, children: [V(WW, { root: r }), o] })
}
function WW({ root: t = ':host, :root' }) {
  const r = [t, '[data-theme]'].join(',')
  return V(Gd, { styles: (a) => ({ [r]: a.__cssVars }) })
}
IW({
  name: 'StylesContext',
  errorMessage:
    'useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` ',
})
function YW() {
  const { colorMode: t } = Ex()
  return V(Gd, {
    styles: (r) => {
      const a = hA(r, 'styles.global'),
        o = gA(a, { theme: r, colorMode: t })
      return o ? XD(o)(r) : void 0
    },
  })
}
var Px = R.createContext({
  getDocument() {
    return document
  },
  getWindow() {
    return window
  },
})
Px.displayName = 'EnvironmentContext'
function GW({ defer: t } = {}) {
  const [, r] = R.useReducer((a) => a + 1, 0)
  return (
    kd(() => {
      t && r()
    }, [t]),
    R.useContext(Px)
  )
}
function SA(t) {
  const { children: r, environment: a, disabled: o } = t,
    l = R.useRef(null),
    f = R.useMemo(
      () =>
        a || {
          getDocument: () => {
            var p, h
            return (h = (p = l.current) == null ? void 0 : p.ownerDocument) != null ? h : document
          },
          getWindow: () => {
            var p, h
            return (h = (p = l.current) == null ? void 0 : p.ownerDocument.defaultView) != null
              ? h
              : window
          },
        },
      [a]
    ),
    c = !o || !a
  return He(Px.Provider, {
    value: f,
    children: [r, c && V('span', { id: '__chakra_env', hidden: !0, ref: l })],
  })
}
SA.displayName = 'EnvironmentProvider'
var qW = (t) => {
    const {
        children: r,
        colorModeManager: a,
        portalZIndex: o,
        resetScope: l,
        resetCSS: f = !0,
        theme: c = {},
        environment: p,
        cssVarsRoot: h,
        disableEnvironment: m,
      } = t,
      g = V(SA, { environment: p, disabled: m, children: r })
    return V(HW, {
      theme: c,
      cssVarsRoot: h,
      children: He(HD, {
        colorModeManager: a,
        options: c.config,
        children: [
          f ? V(yU, { scope: l }) : V(gU, {}),
          V(YW, {}),
          o ? V(UD, { zIndex: o, children: g }) : g,
        ],
      }),
    })
  },
  KW = (t, r) => t.find((a) => a.id === r)
function k_(t, r) {
  const a = xA(t, r),
    o = a ? t[a].findIndex((l) => l.id === r) : -1
  return { position: a, index: o }
}
function xA(t, r) {
  for (const [a, o] of Object.entries(t)) if (KW(o, r)) return a
}
function XW(t) {
  const r = t.includes('right'),
    a = t.includes('left')
  let o = 'center'
  return (
    r && (o = 'flex-end'),
    a && (o = 'flex-start'),
    { display: 'flex', flexDirection: 'column', alignItems: o }
  )
}
function QW(t) {
  const a = t === 'top' || t === 'bottom' ? '0 auto' : void 0,
    o = t.includes('top') ? 'env(safe-area-inset-top, 0px)' : void 0,
    l = t.includes('bottom') ? 'env(safe-area-inset-bottom, 0px)' : void 0,
    f = t.includes('left') ? void 0 : 'env(safe-area-inset-right, 0px)',
    c = t.includes('right') ? void 0 : 'env(safe-area-inset-left, 0px)'
  return {
    position: 'fixed',
    zIndex: 5500,
    pointerEvents: 'none',
    display: 'flex',
    flexDirection: 'column',
    margin: a,
    top: o,
    bottom: l,
    right: f,
    left: c,
  }
}
function Ld(t, r = []) {
  const a = R.useRef(t)
  return (
    R.useEffect(() => {
      a.current = t
    }),
    R.useCallback((...o) => {
      var l
      return (l = a.current) == null ? void 0 : l.call(a, ...o)
    }, r)
  )
}
function ZW(t, r) {
  const a = Ld(t)
  R.useEffect(() => {
    if (r == null) return
    let o = null
    return (
      (o = window.setTimeout(() => {
        a()
      }, r)),
      () => {
        o && window.clearTimeout(o)
      }
    )
  }, [r, a])
}
function zd(t, r) {
  const a = R.useRef(!1),
    o = R.useRef(!1)
  R.useEffect(() => {
    if (a.current && o.current) return t()
    o.current = !0
  }, r),
    R.useEffect(
      () => (
        (a.current = !0),
        () => {
          a.current = !1
        }
      ),
      []
    )
}
const CA = R.createContext({ transformPagePoint: (t) => t, isStatic: !1, reducedMotion: 'never' }),
  xv = R.createContext({}),
  Kd = R.createContext(null),
  Cv = typeof document < 'u',
  qm = Cv ? R.useLayoutEffect : R.useEffect,
  wA = R.createContext({ strict: !1 })
function JW(t, r, a, o) {
  const { visualElement: l } = R.useContext(xv),
    f = R.useContext(wA),
    c = R.useContext(Kd),
    p = R.useContext(CA).reducedMotion,
    h = R.useRef()
  ;(o = o || f.renderer),
    !h.current &&
      o &&
      (h.current = o(t, {
        visualState: r,
        parent: l,
        props: a,
        presenceContext: c,
        blockInitialAnimation: c ? c.initial === !1 : !1,
        reducedMotionConfig: p,
      }))
  const m = h.current
  return (
    R.useInsertionEffect(() => {
      m && m.update(a, c)
    }),
    qm(() => {
      m && m.render()
    }),
    R.useEffect(() => {
      m && m.updateFeatures()
    }),
    (window.HandoffAppearAnimations ? qm : R.useEffect)(() => {
      m && m.animationState && m.animationState.animateChanges()
    }),
    m
  )
}
function Hu(t) {
  return typeof t == 'object' && Object.prototype.hasOwnProperty.call(t, 'current')
}
function e8(t, r, a) {
  return R.useCallback(
    (o) => {
      o && t.mount && t.mount(o),
        r && (o ? r.mount(o) : r.unmount()),
        a && (typeof a == 'function' ? a(o) : Hu(a) && (a.current = o))
    },
    [r]
  )
}
function $d(t) {
  return typeof t == 'string' || Array.isArray(t)
}
function wv(t) {
  return typeof t == 'object' && typeof t.start == 'function'
}
const Lx = ['animate', 'whileInView', 'whileFocus', 'whileHover', 'whileTap', 'whileDrag', 'exit'],
  zx = ['initial', ...Lx]
function Ev(t) {
  return wv(t.animate) || zx.some((r) => $d(t[r]))
}
function EA(t) {
  return !!(Ev(t) || t.variants)
}
function t8(t, r) {
  if (Ev(t)) {
    const { initial: a, animate: o } = t
    return { initial: a === !1 || $d(a) ? a : void 0, animate: $d(o) ? o : void 0 }
  }
  return t.inherit !== !1 ? r : {}
}
function n8(t) {
  const { initial: r, animate: a } = t8(t, R.useContext(xv))
  return R.useMemo(() => ({ initial: r, animate: a }), [D_(r), D_(a)])
}
function D_(t) {
  return Array.isArray(t) ? t.join(' ') : t
}
const A_ = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag',
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId'],
  },
  Fd = {}
for (const t in A_) Fd[t] = { isEnabled: (r) => A_[t].some((a) => !!r[a]) }
function r8(t) {
  for (const r in t) Fd[r] = { ...Fd[r], ...t[r] }
}
function $x(t) {
  const r = R.useRef(null)
  return r.current === null && (r.current = t()), r.current
}
const hd = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
let a8 = 1
function i8() {
  return $x(() => {
    if (hd.hasEverUpdated) return a8++
  })
}
const Fx = R.createContext({}),
  TA = R.createContext({}),
  o8 = Symbol.for('motionComponentSymbol')
function s8({
  preloadedFeatures: t,
  createVisualElement: r,
  useRender: a,
  useVisualState: o,
  Component: l,
}) {
  t && r8(t)
  function f(p, h) {
    let m
    const g = { ...R.useContext(CA), ...p, layoutId: l8(p) },
      { isStatic: b } = g,
      C = n8(p),
      w = b ? void 0 : i8(),
      k = o(p, b)
    if (!b && Cv) {
      C.visualElement = JW(l, k, g, r)
      const D = R.useContext(TA),
        E = R.useContext(wA).strict
      C.visualElement && (m = C.visualElement.loadFeatures(g, E, t, w, D))
    }
    return R.createElement(
      xv.Provider,
      { value: C },
      m && C.visualElement ? R.createElement(m, { visualElement: C.visualElement, ...g }) : null,
      a(l, p, w, e8(k, C.visualElement, h), k, b, C.visualElement)
    )
  }
  const c = R.forwardRef(f)
  return (c[o8] = l), c
}
function l8({ layoutId: t }) {
  const r = R.useContext(Fx).id
  return r && t !== void 0 ? r + '-' + t : t
}
function u8(t) {
  function r(o, l = {}) {
    return s8(t(o, l))
  }
  if (typeof Proxy > 'u') return r
  const a = new Map()
  return new Proxy(r, { get: (o, l) => (a.has(l) || a.set(l, r(l)), a.get(l)) })
}
const c8 = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view',
]
function Nx(t) {
  return typeof t != 'string' || t.includes('-') ? !1 : !!(c8.indexOf(t) > -1 || /[A-Z]/.test(t))
}
const Km = {}
function f8(t) {
  Object.assign(Km, t)
}
const Tv = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
  ],
  Fl = new Set(Tv)
function RA(t, { layout: r, layoutId: a }) {
  return (
    Fl.has(t) || t.startsWith('origin') || ((r || a !== void 0) && (!!Km[t] || t === 'opacity'))
  )
}
const ha = (t) => !!(t && t.getVelocity),
  d8 = { x: 'translateX', y: 'translateY', z: 'translateZ', transformPerspective: 'perspective' },
  p8 = Tv.length
function h8(t, { enableHardwareAcceleration: r = !0, allowTransformNone: a = !0 }, o, l) {
  let f = ''
  for (let c = 0; c < p8; c++) {
    const p = Tv[c]
    if (t[p] !== void 0) {
      const h = d8[p] || p
      f += `${h}(${t[p]}) `
    }
  }
  return (
    r && !t.z && (f += 'translateZ(0)'),
    (f = f.trim()),
    l ? (f = l(t, o ? '' : f)) : a && o && (f = 'none'),
    f
  )
}
const _A = (t) => (r) => typeof r == 'string' && r.startsWith(t),
  kA = _A('--'),
  NS = _A('var(--'),
  m8 = (t, r) => (r && typeof t == 'number' ? r.transform(t) : t),
  Ll = (t, r, a) => Math.min(Math.max(a, t), r),
  Nl = { test: (t) => typeof t == 'number', parse: parseFloat, transform: (t) => t },
  md = { ...Nl, transform: (t) => Ll(0, 1, t) },
  ym = { ...Nl, default: 1 },
  vd = (t) => Math.round(t * 1e5) / 1e5,
  Nd = /(-)?([\d]*\.?[\d])+/g,
  BS =
    /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
  v8 =
    /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i
function Xd(t) {
  return typeof t == 'string'
}
const Qd = (t) => ({
    test: (r) => Xd(r) && r.endsWith(t) && r.split(' ').length === 1,
    parse: parseFloat,
    transform: (r) => `${r}${t}`,
  }),
  Ss = Qd('deg'),
  Yi = Qd('%'),
  Qe = Qd('px'),
  g8 = Qd('vh'),
  y8 = Qd('vw'),
  O_ = { ...Yi, parse: (t) => Yi.parse(t) / 100, transform: (t) => Yi.transform(t * 100) },
  M_ = { ...Nl, transform: Math.round },
  DA = {
    borderWidth: Qe,
    borderTopWidth: Qe,
    borderRightWidth: Qe,
    borderBottomWidth: Qe,
    borderLeftWidth: Qe,
    borderRadius: Qe,
    radius: Qe,
    borderTopLeftRadius: Qe,
    borderTopRightRadius: Qe,
    borderBottomRightRadius: Qe,
    borderBottomLeftRadius: Qe,
    width: Qe,
    maxWidth: Qe,
    height: Qe,
    maxHeight: Qe,
    size: Qe,
    top: Qe,
    right: Qe,
    bottom: Qe,
    left: Qe,
    padding: Qe,
    paddingTop: Qe,
    paddingRight: Qe,
    paddingBottom: Qe,
    paddingLeft: Qe,
    margin: Qe,
    marginTop: Qe,
    marginRight: Qe,
    marginBottom: Qe,
    marginLeft: Qe,
    rotate: Ss,
    rotateX: Ss,
    rotateY: Ss,
    rotateZ: Ss,
    scale: ym,
    scaleX: ym,
    scaleY: ym,
    scaleZ: ym,
    skew: Ss,
    skewX: Ss,
    skewY: Ss,
    distance: Qe,
    translateX: Qe,
    translateY: Qe,
    translateZ: Qe,
    x: Qe,
    y: Qe,
    z: Qe,
    perspective: Qe,
    transformPerspective: Qe,
    opacity: md,
    originX: O_,
    originY: O_,
    originZ: Qe,
    zIndex: M_,
    fillOpacity: md,
    strokeOpacity: md,
    numOctaves: M_,
  }
function Bx(t, r, a, o) {
  const { style: l, vars: f, transform: c, transformOrigin: p } = t
  let h = !1,
    m = !1,
    g = !0
  for (const b in r) {
    const C = r[b]
    if (kA(b)) {
      f[b] = C
      continue
    }
    const w = DA[b],
      k = m8(C, w)
    if (Fl.has(b)) {
      if (((h = !0), (c[b] = k), !g)) continue
      C !== (w.default || 0) && (g = !1)
    } else b.startsWith('origin') ? ((m = !0), (p[b] = k)) : (l[b] = k)
  }
  if (
    (r.transform ||
      (h || o ? (l.transform = h8(t.transform, a, g, o)) : l.transform && (l.transform = 'none')),
    m)
  ) {
    const { originX: b = '50%', originY: C = '50%', originZ: w = 0 } = p
    l.transformOrigin = `${b} ${C} ${w}`
  }
}
const jx = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} })
function AA(t, r, a) {
  for (const o in r) !ha(r[o]) && !RA(o, a) && (t[o] = r[o])
}
function b8({ transformTemplate: t }, r, a) {
  return R.useMemo(() => {
    const o = jx()
    return Bx(o, r, { enableHardwareAcceleration: !a }, t), Object.assign({}, o.vars, o.style)
  }, [r])
}
function S8(t, r, a) {
  const o = t.style || {},
    l = {}
  return AA(l, o, t), Object.assign(l, b8(t, r, a)), t.transformValues ? t.transformValues(l) : l
}
function x8(t, r, a) {
  const o = {},
    l = S8(t, r, a)
  return (
    t.drag &&
      t.dragListener !== !1 &&
      ((o.draggable = !1),
      (l.userSelect = l.WebkitUserSelect = l.WebkitTouchCallout = 'none'),
      (l.touchAction = t.drag === !0 ? 'none' : `pan-${t.drag === 'x' ? 'y' : 'x'}`)),
    t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (o.tabIndex = 0),
    (o.style = l),
    o
  )
}
const C8 = new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'transformValues',
  'custom',
  'inherit',
  'onLayoutAnimationStart',
  'onLayoutAnimationComplete',
  'onLayoutMeasure',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'ignoreStrict',
  'viewport',
])
function Xm(t) {
  return (
    t.startsWith('while') ||
    (t.startsWith('drag') && t !== 'draggable') ||
    t.startsWith('layout') ||
    t.startsWith('onTap') ||
    t.startsWith('onPan') ||
    C8.has(t)
  )
}
let OA = (t) => !Xm(t)
function w8(t) {
  t && (OA = (r) => (r.startsWith('on') ? !Xm(r) : t(r)))
}
try {
  w8(require('@emotion/is-prop-valid').default)
} catch {}
function E8(t, r, a) {
  const o = {}
  for (const l in t)
    (l === 'values' && typeof t.values == 'object') ||
      ((OA(l) ||
        (a === !0 && Xm(l)) ||
        (!r && !Xm(l)) ||
        (t.draggable && l.startsWith('onDrag'))) &&
        (o[l] = t[l]))
  return o
}
function P_(t, r, a) {
  return typeof t == 'string' ? t : Qe.transform(r + a * t)
}
function T8(t, r, a) {
  const o = P_(r, t.x, t.width),
    l = P_(a, t.y, t.height)
  return `${o} ${l}`
}
const R8 = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
  _8 = { offset: 'strokeDashoffset', array: 'strokeDasharray' }
function k8(t, r, a = 1, o = 0, l = !0) {
  t.pathLength = 1
  const f = l ? R8 : _8
  t[f.offset] = Qe.transform(-o)
  const c = Qe.transform(r),
    p = Qe.transform(a)
  t[f.array] = `${c} ${p}`
}
function Ux(
  t,
  {
    attrX: r,
    attrY: a,
    originX: o,
    originY: l,
    pathLength: f,
    pathSpacing: c = 1,
    pathOffset: p = 0,
    ...h
  },
  m,
  g,
  b
) {
  if ((Bx(t, h, m, b), g)) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox)
    return
  }
  ;(t.attrs = t.style), (t.style = {})
  const { attrs: C, style: w, dimensions: k } = t
  C.transform && (k && (w.transform = C.transform), delete C.transform),
    k &&
      (o !== void 0 || l !== void 0 || w.transform) &&
      (w.transformOrigin = T8(k, o !== void 0 ? o : 0.5, l !== void 0 ? l : 0.5)),
    r !== void 0 && (C.x = r),
    a !== void 0 && (C.y = a),
    f !== void 0 && k8(C, f, c, p, !1)
}
const MA = () => ({ ...jx(), attrs: {} }),
  Vx = (t) => typeof t == 'string' && t.toLowerCase() === 'svg'
function D8(t, r, a, o) {
  const l = R.useMemo(() => {
    const f = MA()
    return (
      Ux(f, r, { enableHardwareAcceleration: !1 }, Vx(o), t.transformTemplate),
      { ...f.attrs, style: { ...f.style } }
    )
  }, [r])
  if (t.style) {
    const f = {}
    AA(f, t.style, t), (l.style = { ...f, ...l.style })
  }
  return l
}
function A8(t = !1) {
  return (a, o, l, f, { latestValues: c }, p) => {
    const m = (Nx(a) ? D8 : x8)(o, c, p, a),
      b = { ...E8(o, typeof a == 'string', t), ...m, ref: f },
      { children: C } = o,
      w = R.useMemo(() => (ha(C) ? C.get() : C), [C])
    return l && (b['data-projection-id'] = l), R.createElement(a, { ...b, children: w })
  }
}
const Ix = (t) => t.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
function PA(t, { style: r, vars: a }, o, l) {
  Object.assign(t.style, r, l && l.getProjectionStyles(o))
  for (const f in a) t.style.setProperty(f, a[f])
}
const LA = new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust',
])
function zA(t, r, a, o) {
  PA(t, r, void 0, o)
  for (const l in r.attrs) t.setAttribute(LA.has(l) ? l : Ix(l), r.attrs[l])
}
function Hx(t, r) {
  const { style: a } = t,
    o = {}
  for (const l in a) (ha(a[l]) || (r.style && ha(r.style[l])) || RA(l, t)) && (o[l] = a[l])
  return o
}
function $A(t, r) {
  const a = Hx(t, r)
  for (const o in t)
    if (ha(t[o]) || ha(r[o])) {
      const l = o === 'x' || o === 'y' ? 'attr' + o.toUpperCase() : o
      a[l] = t[o]
    }
  return a
}
function Wx(t, r, a, o = {}, l = {}) {
  return (
    typeof r == 'function' && (r = r(a !== void 0 ? a : t.custom, o, l)),
    typeof r == 'string' && (r = t.variants && t.variants[r]),
    typeof r == 'function' && (r = r(a !== void 0 ? a : t.custom, o, l)),
    r
  )
}
const Qm = (t) => Array.isArray(t),
  O8 = (t) => !!(t && typeof t == 'object' && t.mix && t.toValue),
  M8 = (t) => (Qm(t) ? t[t.length - 1] || 0 : t)
function Lm(t) {
  const r = ha(t) ? t.get() : t
  return O8(r) ? r.toValue() : r
}
function P8({ scrapeMotionValuesFromProps: t, createRenderState: r, onMount: a }, o, l, f) {
  const c = { latestValues: L8(o, l, f, t), renderState: r() }
  return a && (c.mount = (p) => a(o, p, c)), c
}
const FA = (t) => (r, a) => {
  const o = R.useContext(xv),
    l = R.useContext(Kd),
    f = () => P8(t, r, o, l)
  return a ? f() : $x(f)
}
function L8(t, r, a, o) {
  const l = {},
    f = o(t, {})
  for (const C in f) l[C] = Lm(f[C])
  let { initial: c, animate: p } = t
  const h = Ev(t),
    m = EA(t)
  r &&
    m &&
    !h &&
    t.inherit !== !1 &&
    (c === void 0 && (c = r.initial), p === void 0 && (p = r.animate))
  let g = a ? a.initial === !1 : !1
  g = g || c === !1
  const b = g ? p : c
  return (
    b &&
      typeof b != 'boolean' &&
      !wv(b) &&
      (Array.isArray(b) ? b : [b]).forEach((w) => {
        const k = Wx(t, w)
        if (!k) return
        const { transitionEnd: D, transition: E, ...M } = k
        for (const z in M) {
          let P = M[z]
          if (Array.isArray(P)) {
            const B = g ? P.length - 1 : 0
            P = P[B]
          }
          P !== null && (l[z] = P)
        }
        for (const z in D) l[z] = D[z]
      }),
    l
  )
}
const z8 = {
    useVisualState: FA({
      scrapeMotionValuesFromProps: $A,
      createRenderState: MA,
      onMount: (t, r, { renderState: a, latestValues: o }) => {
        try {
          a.dimensions = typeof r.getBBox == 'function' ? r.getBBox() : r.getBoundingClientRect()
        } catch {
          a.dimensions = { x: 0, y: 0, width: 0, height: 0 }
        }
        Ux(a, o, { enableHardwareAcceleration: !1 }, Vx(r.tagName), t.transformTemplate), zA(r, a)
      },
    }),
  },
  $8 = { useVisualState: FA({ scrapeMotionValuesFromProps: Hx, createRenderState: jx }) }
function F8(t, { forwardMotionProps: r = !1 }, a, o) {
  return {
    ...(Nx(t) ? z8 : $8),
    preloadedFeatures: a,
    useRender: A8(r),
    createVisualElement: o,
    Component: t,
  }
}
function Ao(t, r, a, o = { passive: !0 }) {
  return t.addEventListener(r, a, o), () => t.removeEventListener(r, a)
}
const NA = (t) =>
  t.pointerType === 'mouse' ? typeof t.button != 'number' || t.button <= 0 : t.isPrimary !== !1
function Rv(t, r = 'page') {
  return { point: { x: t[r + 'X'], y: t[r + 'Y'] } }
}
const N8 = (t) => (r) => NA(r) && t(r, Rv(r))
function Mo(t, r, a, o) {
  return Ao(t, r, N8(a), o)
}
const B8 = (t, r) => (a) => r(t(a)),
  Ts = (...t) => t.reduce(B8)
function BA(t) {
  let r = null
  return () => {
    const a = () => {
      r = null
    }
    return r === null ? ((r = t), a) : !1
  }
}
const L_ = BA('dragHorizontal'),
  z_ = BA('dragVertical')
function jA(t) {
  let r = !1
  if (t === 'y') r = z_()
  else if (t === 'x') r = L_()
  else {
    const a = L_(),
      o = z_()
    a && o
      ? (r = () => {
          a(), o()
        })
      : (a && a(), o && o())
  }
  return r
}
function UA() {
  const t = jA(!0)
  return t ? (t(), !1) : !0
}
class Ls {
  constructor(r) {
    ;(this.isMounted = !1), (this.node = r)
  }
  update() {}
}
function j8(t) {
  let r = [],
    a = [],
    o = 0,
    l = !1,
    f = !1
  const c = new WeakSet(),
    p = {
      schedule: (h, m = !1, g = !1) => {
        const b = g && l,
          C = b ? r : a
        return m && c.add(h), C.indexOf(h) === -1 && (C.push(h), b && l && (o = r.length)), h
      },
      cancel: (h) => {
        const m = a.indexOf(h)
        m !== -1 && a.splice(m, 1), c.delete(h)
      },
      process: (h) => {
        if (l) {
          f = !0
          return
        }
        if (((l = !0), ([r, a] = [a, r]), (a.length = 0), (o = r.length), o))
          for (let m = 0; m < o; m++) {
            const g = r[m]
            g(h), c.has(g) && (p.schedule(g), t())
          }
        ;(l = !1), f && ((f = !1), p.process(h))
      },
    }
  return p
}
const Fr = { delta: 0, timestamp: 0, isProcessing: !1 },
  U8 = 40
let jS = !0,
  Bd = !1
const Zd = ['read', 'update', 'preRender', 'render', 'postRender'],
  _v = Zd.reduce((t, r) => ((t[r] = j8(() => (Bd = !0))), t), {}),
  Rn = Zd.reduce((t, r) => {
    const a = _v[r]
    return (t[r] = (o, l = !1, f = !1) => (Bd || I8(), a.schedule(o, l, f))), t
  }, {}),
  Ds = Zd.reduce((t, r) => ((t[r] = _v[r].cancel), t), {}),
  nS = Zd.reduce((t, r) => ((t[r] = () => _v[r].process(Fr)), t), {}),
  V8 = (t) => _v[t].process(Fr),
  VA = (t) => {
    ;(Bd = !1),
      (Fr.delta = jS ? 1e3 / 60 : Math.max(Math.min(t - Fr.timestamp, U8), 1)),
      (Fr.timestamp = t),
      (Fr.isProcessing = !0),
      Zd.forEach(V8),
      (Fr.isProcessing = !1),
      Bd && ((jS = !1), requestAnimationFrame(VA))
  },
  I8 = () => {
    ;(Bd = !0), (jS = !0), Fr.isProcessing || requestAnimationFrame(VA)
  }
function $_(t, r) {
  const a = 'pointer' + (r ? 'enter' : 'leave'),
    o = 'onHover' + (r ? 'Start' : 'End'),
    l = (f, c) => {
      if (f.type === 'touch' || UA()) return
      const p = t.getProps()
      t.animationState && p.whileHover && t.animationState.setActive('whileHover', r),
        p[o] && Rn.update(() => p[o](f, c))
    }
  return Mo(t.current, a, l, { passive: !t.getProps()[o] })
}
class H8 extends Ls {
  mount() {
    this.unmount = Ts($_(this.node, !0), $_(this.node, !1))
  }
  unmount() {}
}
class W8 extends Ls {
  constructor() {
    super(...arguments), (this.isActive = !1)
  }
  onFocus() {
    let r = !1
    try {
      r = this.node.current.matches(':focus-visible')
    } catch {
      r = !0
    }
    !r ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !0), (this.isActive = !0))
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !1), (this.isActive = !1))
  }
  mount() {
    this.unmount = Ts(
      Ao(this.node.current, 'focus', () => this.onFocus()),
      Ao(this.node.current, 'blur', () => this.onBlur())
    )
  }
  unmount() {}
}
const IA = (t, r) => (r ? (t === r ? !0 : IA(t, r.parentElement)) : !1),
  vr = (t) => t
function rS(t, r) {
  if (!r) return
  const a = new PointerEvent('pointer' + t)
  r(a, Rv(a))
}
class Y8 extends Ls {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = vr),
      (this.removeEndListeners = vr),
      (this.removeAccessibleListeners = vr),
      (this.startPointerPress = (r, a) => {
        if ((this.removeEndListeners(), this.isPressing)) return
        const o = this.node.getProps(),
          f = Mo(
            window,
            'pointerup',
            (p, h) => {
              if (!this.checkPressEnd()) return
              const { onTap: m, onTapCancel: g } = this.node.getProps()
              Rn.update(() => {
                IA(this.node.current, p.target) ? m && m(p, h) : g && g(p, h)
              })
            },
            { passive: !(o.onTap || o.onPointerUp) }
          ),
          c = Mo(window, 'pointercancel', (p, h) => this.cancelPress(p, h), {
            passive: !(o.onTapCancel || o.onPointerCancel),
          })
        ;(this.removeEndListeners = Ts(f, c)), this.startPress(r, a)
      }),
      (this.startAccessiblePress = () => {
        const r = (f) => {
            if (f.key !== 'Enter' || this.isPressing) return
            const c = (p) => {
              p.key !== 'Enter' ||
                !this.checkPressEnd() ||
                rS('up', (h, m) => {
                  const { onTap: g } = this.node.getProps()
                  g && Rn.update(() => g(h, m))
                })
            }
            this.removeEndListeners(),
              (this.removeEndListeners = Ao(this.node.current, 'keyup', c)),
              rS('down', (p, h) => {
                this.startPress(p, h)
              })
          },
          a = Ao(this.node.current, 'keydown', r),
          o = () => {
            this.isPressing && rS('cancel', (f, c) => this.cancelPress(f, c))
          },
          l = Ao(this.node.current, 'blur', o)
        this.removeAccessibleListeners = Ts(a, l)
      })
  }
  startPress(r, a) {
    this.isPressing = !0
    const { onTapStart: o, whileTap: l } = this.node.getProps()
    l && this.node.animationState && this.node.animationState.setActive('whileTap', !0),
      o && Rn.update(() => o(r, a))
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive('whileTap', !1),
      !UA()
    )
  }
  cancelPress(r, a) {
    if (!this.checkPressEnd()) return
    const { onTapCancel: o } = this.node.getProps()
    o && Rn.update(() => o(r, a))
  }
  mount() {
    const r = this.node.getProps(),
      a = Mo(this.node.current, 'pointerdown', this.startPointerPress, {
        passive: !(r.onTapStart || r.onPointerStart),
      }),
      o = Ao(this.node.current, 'focus', this.startAccessiblePress)
    this.removeStartListeners = Ts(a, o)
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
  }
}
const US = new WeakMap(),
  aS = new WeakMap(),
  G8 = (t) => {
    const r = US.get(t.target)
    r && r(t)
  },
  q8 = (t) => {
    t.forEach(G8)
  }
function K8({ root: t, ...r }) {
  const a = t || document
  aS.has(a) || aS.set(a, {})
  const o = aS.get(a),
    l = JSON.stringify(r)
  return o[l] || (o[l] = new IntersectionObserver(q8, { root: t, ...r })), o[l]
}
function X8(t, r, a) {
  const o = K8(r)
  return (
    US.set(t, a),
    o.observe(t),
    () => {
      US.delete(t), o.unobserve(t)
    }
  )
}
const Q8 = { some: 0, all: 1 }
class Z8 extends Ls {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1)
  }
  startObserver() {
    this.unmount()
    const { viewport: r = {} } = this.node.getProps(),
      { root: a, margin: o, amount: l = 'some', once: f } = r,
      c = {
        root: a ? a.current : void 0,
        rootMargin: o,
        threshold: typeof l == 'number' ? l : Q8[l],
      },
      p = (h) => {
        const { isIntersecting: m } = h
        if (this.isInView === m || ((this.isInView = m), f && !m && this.hasEnteredView)) return
        m && (this.hasEnteredView = !0),
          this.node.animationState && this.node.animationState.setActive('whileInView', m)
        const { onViewportEnter: g, onViewportLeave: b } = this.node.getProps(),
          C = m ? g : b
        C && C(h)
      }
    return X8(this.node.current, c, p)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > 'u') return
    const { props: r, prevProps: a } = this.node
    ;['amount', 'margin', 'root'].some(J8(r, a)) && this.startObserver()
  }
  unmount() {}
}
function J8({ viewport: t = {} }, { viewport: r = {} } = {}) {
  return (a) => t[a] !== r[a]
}
const e7 = {
  inView: { Feature: Z8 },
  tap: { Feature: Y8 },
  focus: { Feature: W8 },
  hover: { Feature: H8 },
}
function HA(t, r) {
  if (!Array.isArray(r)) return !1
  const a = r.length
  if (a !== t.length) return !1
  for (let o = 0; o < a; o++) if (r[o] !== t[o]) return !1
  return !0
}
function t7(t) {
  const r = {}
  return t.values.forEach((a, o) => (r[o] = a.get())), r
}
function n7(t) {
  const r = {}
  return t.values.forEach((a, o) => (r[o] = a.getVelocity())), r
}
function kv(t, r, a) {
  const o = t.getProps()
  return Wx(o, r, a !== void 0 ? a : o.custom, t7(t), n7(t))
}
const r7 = 'framerAppearId',
  a7 = 'data-' + Ix(r7)
let Jd = vr,
  mi = vr
;(Jd = (t, r) => {
  !t && typeof console < 'u' && console.warn(r)
}),
  (mi = (t, r) => {
    if (!t) throw new Error(r)
  })
const Rs = (t) => t * 1e3,
  Po = (t) => t / 1e3,
  i7 = { current: !1 },
  WA = (t) => Array.isArray(t) && typeof t[0] == 'number'
function YA(t) {
  return !!(!t || (typeof t == 'string' && GA[t]) || WA(t) || (Array.isArray(t) && t.every(YA)))
}
const ld = ([t, r, a, o]) => `cubic-bezier(${t}, ${r}, ${a}, ${o})`,
  GA = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: ld([0, 0.65, 0.55, 1]),
    circOut: ld([0.55, 0, 1, 0.45]),
    backIn: ld([0.31, 0.01, 0.66, -0.59]),
    backOut: ld([0.33, 1.53, 0.69, 0.99]),
  }
function qA(t) {
  if (t) return WA(t) ? ld(t) : Array.isArray(t) ? t.map(qA) : GA[t]
}
function o7(
  t,
  r,
  a,
  { delay: o = 0, duration: l, repeat: f = 0, repeatType: c = 'loop', ease: p, times: h } = {}
) {
  const m = { [r]: a }
  h && (m.offset = h)
  const g = qA(p)
  return (
    Array.isArray(g) && (m.easing = g),
    t.animate(m, {
      delay: o,
      duration: l,
      easing: Array.isArray(g) ? 'linear' : g,
      fill: 'both',
      iterations: f + 1,
      direction: c === 'reverse' ? 'alternate' : 'normal',
    })
  )
}
const F_ = { waapi: () => Object.hasOwnProperty.call(Element.prototype, 'animate') },
  iS = {},
  KA = {}
for (const t in F_) KA[t] = () => (iS[t] === void 0 && (iS[t] = F_[t]()), iS[t])
function s7(t, { repeat: r, repeatType: a = 'loop' }) {
  const o = r && a !== 'loop' && r % 2 === 1 ? 0 : t.length - 1
  return t[o]
}
const XA = (t, r, a) => (((1 - 3 * a + 3 * r) * t + (3 * a - 6 * r)) * t + 3 * r) * t,
  l7 = 1e-7,
  u7 = 12
function c7(t, r, a, o, l) {
  let f,
    c,
    p = 0
  do (c = r + (a - r) / 2), (f = XA(c, o, l) - t), f > 0 ? (a = c) : (r = c)
  while (Math.abs(f) > l7 && ++p < u7)
  return c
}
function ep(t, r, a, o) {
  if (t === r && a === o) return vr
  const l = (f) => c7(f, 0, 1, t, a)
  return (f) => (f === 0 || f === 1 ? f : XA(l(f), r, o))
}
const f7 = ep(0.42, 0, 1, 1),
  d7 = ep(0, 0, 0.58, 1),
  QA = ep(0.42, 0, 0.58, 1),
  p7 = (t) => Array.isArray(t) && typeof t[0] != 'number',
  ZA = (t) => (r) => r <= 0.5 ? t(2 * r) / 2 : (2 - t(2 * (1 - r))) / 2,
  JA = (t) => (r) => 1 - t(1 - r),
  eO = (t) => 1 - Math.sin(Math.acos(t)),
  Yx = JA(eO),
  h7 = ZA(Yx),
  tO = ep(0.33, 1.53, 0.69, 0.99),
  Gx = JA(tO),
  m7 = ZA(Gx),
  v7 = (t) => ((t *= 2) < 1 ? 0.5 * Gx(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1)))),
  N_ = {
    linear: vr,
    easeIn: f7,
    easeInOut: QA,
    easeOut: d7,
    circIn: eO,
    circInOut: h7,
    circOut: Yx,
    backIn: Gx,
    backInOut: m7,
    backOut: tO,
    anticipate: v7,
  },
  B_ = (t) => {
    if (Array.isArray(t)) {
      mi(t.length === 4, 'Cubic bezier arrays must contain four numerical values.')
      const [r, a, o, l] = t
      return ep(r, a, o, l)
    } else if (typeof t == 'string')
      return mi(N_[t] !== void 0, `Invalid easing type '${t}'`), N_[t]
    return t
  },
  qx = (t, r) => (a) =>
    !!(
      (Xd(a) && v8.test(a) && a.startsWith(t)) ||
      (r && Object.prototype.hasOwnProperty.call(a, r))
    ),
  nO = (t, r, a) => (o) => {
    if (!Xd(o)) return o
    const [l, f, c, p] = o.match(Nd)
    return {
      [t]: parseFloat(l),
      [r]: parseFloat(f),
      [a]: parseFloat(c),
      alpha: p !== void 0 ? parseFloat(p) : 1,
    }
  },
  g7 = (t) => Ll(0, 255, t),
  oS = { ...Nl, transform: (t) => Math.round(g7(t)) },
  kl = {
    test: qx('rgb', 'red'),
    parse: nO('red', 'green', 'blue'),
    transform: ({ red: t, green: r, blue: a, alpha: o = 1 }) =>
      'rgba(' +
      oS.transform(t) +
      ', ' +
      oS.transform(r) +
      ', ' +
      oS.transform(a) +
      ', ' +
      vd(md.transform(o)) +
      ')',
  }
function y7(t) {
  let r = '',
    a = '',
    o = '',
    l = ''
  return (
    t.length > 5
      ? ((r = t.substring(1, 3)),
        (a = t.substring(3, 5)),
        (o = t.substring(5, 7)),
        (l = t.substring(7, 9)))
      : ((r = t.substring(1, 2)),
        (a = t.substring(2, 3)),
        (o = t.substring(3, 4)),
        (l = t.substring(4, 5)),
        (r += r),
        (a += a),
        (o += o),
        (l += l)),
    {
      red: parseInt(r, 16),
      green: parseInt(a, 16),
      blue: parseInt(o, 16),
      alpha: l ? parseInt(l, 16) / 255 : 1,
    }
  )
}
const VS = { test: qx('#'), parse: y7, transform: kl.transform },
  Wu = {
    test: qx('hsl', 'hue'),
    parse: nO('hue', 'saturation', 'lightness'),
    transform: ({ hue: t, saturation: r, lightness: a, alpha: o = 1 }) =>
      'hsla(' +
      Math.round(t) +
      ', ' +
      Yi.transform(vd(r)) +
      ', ' +
      Yi.transform(vd(a)) +
      ', ' +
      vd(md.transform(o)) +
      ')',
  },
  Kr = {
    test: (t) => kl.test(t) || VS.test(t) || Wu.test(t),
    parse: (t) => (kl.test(t) ? kl.parse(t) : Wu.test(t) ? Wu.parse(t) : VS.parse(t)),
    transform: (t) => (Xd(t) ? t : t.hasOwnProperty('red') ? kl.transform(t) : Wu.transform(t)),
  },
  An = (t, r, a) => -a * t + a * r + t
function sS(t, r, a) {
  return (
    a < 0 && (a += 1),
    a > 1 && (a -= 1),
    a < 1 / 6 ? t + (r - t) * 6 * a : a < 1 / 2 ? r : a < 2 / 3 ? t + (r - t) * (2 / 3 - a) * 6 : t
  )
}
function b7({ hue: t, saturation: r, lightness: a, alpha: o }) {
  ;(t /= 360), (r /= 100), (a /= 100)
  let l = 0,
    f = 0,
    c = 0
  if (!r) l = f = c = a
  else {
    const p = a < 0.5 ? a * (1 + r) : a + r - a * r,
      h = 2 * a - p
    ;(l = sS(h, p, t + 1 / 3)), (f = sS(h, p, t)), (c = sS(h, p, t - 1 / 3))
  }
  return {
    red: Math.round(l * 255),
    green: Math.round(f * 255),
    blue: Math.round(c * 255),
    alpha: o,
  }
}
const lS = (t, r, a) => {
    const o = t * t
    return Math.sqrt(Math.max(0, a * (r * r - o) + o))
  },
  S7 = [VS, kl, Wu],
  x7 = (t) => S7.find((r) => r.test(t))
function j_(t) {
  const r = x7(t)
  mi(!!r, `'${t}' is not an animatable color. Use the equivalent color code instead.`)
  let a = r.parse(t)
  return r === Wu && (a = b7(a)), a
}
const rO = (t, r) => {
    const a = j_(t),
      o = j_(r),
      l = { ...a }
    return (f) => (
      (l.red = lS(a.red, o.red, f)),
      (l.green = lS(a.green, o.green, f)),
      (l.blue = lS(a.blue, o.blue, f)),
      (l.alpha = An(a.alpha, o.alpha, f)),
      kl.transform(l)
    )
  },
  aO = '${c}',
  iO = '${n}'
function C7(t) {
  var r, a
  return (
    isNaN(t) &&
    Xd(t) &&
    (((r = t.match(Nd)) === null || r === void 0 ? void 0 : r.length) || 0) +
      (((a = t.match(BS)) === null || a === void 0 ? void 0 : a.length) || 0) >
      0
  )
}
function Zm(t) {
  typeof t == 'number' && (t = `${t}`)
  const r = []
  let a = 0,
    o = 0
  const l = t.match(BS)
  l && ((a = l.length), (t = t.replace(BS, aO)), r.push(...l.map(Kr.parse)))
  const f = t.match(Nd)
  return (
    f && ((o = f.length), (t = t.replace(Nd, iO)), r.push(...f.map(Nl.parse))),
    { values: r, numColors: a, numNumbers: o, tokenised: t }
  )
}
function oO(t) {
  return Zm(t).values
}
function sO(t) {
  const { values: r, numColors: a, tokenised: o } = Zm(t),
    l = r.length
  return (f) => {
    let c = o
    for (let p = 0; p < l; p++)
      c = c.replace(p < a ? aO : iO, p < a ? Kr.transform(f[p]) : vd(f[p]))
    return c
  }
}
const w7 = (t) => (typeof t == 'number' ? 0 : t)
function E7(t) {
  const r = oO(t)
  return sO(t)(r.map(w7))
}
const As = { test: C7, parse: oO, createTransformer: sO, getAnimatableNone: E7 }
function lO(t, r) {
  return typeof t == 'number' ? (a) => An(t, r, a) : Kr.test(t) ? rO(t, r) : cO(t, r)
}
const uO = (t, r) => {
    const a = [...t],
      o = a.length,
      l = t.map((f, c) => lO(f, r[c]))
    return (f) => {
      for (let c = 0; c < o; c++) a[c] = l[c](f)
      return a
    }
  },
  T7 = (t, r) => {
    const a = { ...t, ...r },
      o = {}
    for (const l in a) t[l] !== void 0 && r[l] !== void 0 && (o[l] = lO(t[l], r[l]))
    return (l) => {
      for (const f in o) a[f] = o[f](l)
      return a
    }
  },
  cO = (t, r) => {
    const a = As.createTransformer(r),
      o = Zm(t),
      l = Zm(r)
    return o.numColors === l.numColors && o.numNumbers >= l.numNumbers
      ? Ts(uO(o.values, l.values), a)
      : (Jd(
          !0,
          `Complex values '${t}' and '${r}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`
        ),
        (c) => `${c > 0 ? r : t}`)
  },
  jd = (t, r, a) => {
    const o = r - t
    return o === 0 ? 1 : (a - t) / o
  },
  U_ = (t, r) => (a) => An(t, r, a)
function R7(t) {
  return typeof t == 'number'
    ? U_
    : typeof t == 'string'
    ? Kr.test(t)
      ? rO
      : cO
    : Array.isArray(t)
    ? uO
    : typeof t == 'object'
    ? T7
    : U_
}
function _7(t, r, a) {
  const o = [],
    l = a || R7(t[0]),
    f = t.length - 1
  for (let c = 0; c < f; c++) {
    let p = l(t[c], t[c + 1])
    if (r) {
      const h = Array.isArray(r) ? r[c] || vr : r
      p = Ts(h, p)
    }
    o.push(p)
  }
  return o
}
function fO(t, r, { clamp: a = !0, ease: o, mixer: l } = {}) {
  const f = t.length
  if ((mi(f === r.length, 'Both input and output ranges must be the same length'), f === 1))
    return () => r[0]
  t[0] > t[f - 1] && ((t = [...t].reverse()), (r = [...r].reverse()))
  const c = _7(r, o, l),
    p = c.length,
    h = (m) => {
      let g = 0
      if (p > 1) for (; g < t.length - 2 && !(m < t[g + 1]); g++);
      const b = jd(t[g], t[g + 1], m)
      return c[g](b)
    }
  return a ? (m) => h(Ll(t[0], t[f - 1], m)) : h
}
function k7(t, r) {
  const a = t[t.length - 1]
  for (let o = 1; o <= r; o++) {
    const l = jd(0, r, o)
    t.push(An(a, 1, l))
  }
}
function D7(t) {
  const r = [0]
  return k7(r, t.length - 1), r
}
function A7(t, r) {
  return t.map((a) => a * r)
}
function O7(t, r) {
  return t.map(() => r || QA).splice(0, t.length - 1)
}
function Jm({ duration: t = 300, keyframes: r, times: a, ease: o = 'easeInOut' }) {
  const l = p7(o) ? o.map(B_) : B_(o),
    f = { done: !1, value: r[0] },
    c = A7(a && a.length === r.length ? a : D7(r), t),
    p = fO(c, r, { ease: Array.isArray(l) ? l : O7(r, l) })
  return { calculatedDuration: t, next: (h) => ((f.value = p(h)), (f.done = h >= t), f) }
}
function dO(t, r) {
  return r ? t * (1e3 / r) : 0
}
const M7 = 5
function pO(t, r, a) {
  const o = Math.max(r - M7, 0)
  return dO(a - t(o), r - o)
}
const uS = 0.001,
  P7 = 0.01,
  V_ = 10,
  L7 = 0.05,
  z7 = 1
function $7({ duration: t = 800, bounce: r = 0.25, velocity: a = 0, mass: o = 1 }) {
  let l, f
  Jd(t <= Rs(V_), 'Spring duration must be 10 seconds or less')
  let c = 1 - r
  ;(c = Ll(L7, z7, c)),
    (t = Ll(P7, V_, Po(t))),
    c < 1
      ? ((l = (m) => {
          const g = m * c,
            b = g * t,
            C = g - a,
            w = IS(m, c),
            k = Math.exp(-b)
          return uS - (C / w) * k
        }),
        (f = (m) => {
          const b = m * c * t,
            C = b * a + a,
            w = Math.pow(c, 2) * Math.pow(m, 2) * t,
            k = Math.exp(-b),
            D = IS(Math.pow(m, 2), c)
          return ((-l(m) + uS > 0 ? -1 : 1) * ((C - w) * k)) / D
        }))
      : ((l = (m) => {
          const g = Math.exp(-m * t),
            b = (m - a) * t + 1
          return -uS + g * b
        }),
        (f = (m) => {
          const g = Math.exp(-m * t),
            b = (a - m) * (t * t)
          return g * b
        }))
  const p = 5 / t,
    h = N7(l, f, p)
  if (((t = Rs(t)), isNaN(h))) return { stiffness: 100, damping: 10, duration: t }
  {
    const m = Math.pow(h, 2) * o
    return { stiffness: m, damping: c * 2 * Math.sqrt(o * m), duration: t }
  }
}
const F7 = 12
function N7(t, r, a) {
  let o = a
  for (let l = 1; l < F7; l++) o = o - t(o) / r(o)
  return o
}
function IS(t, r) {
  return t * Math.sqrt(1 - r * r)
}
const B7 = ['duration', 'bounce'],
  j7 = ['stiffness', 'damping', 'mass']
function I_(t, r) {
  return r.some((a) => t[a] !== void 0)
}
function U7(t) {
  let r = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...t }
  if (!I_(t, j7) && I_(t, B7)) {
    const a = $7(t)
    ;(r = { ...r, ...a, velocity: 0, mass: 1 }), (r.isResolvedFromDuration = !0)
  }
  return r
}
function hO({ keyframes: t, restDelta: r, restSpeed: a, ...o }) {
  const l = t[0],
    f = t[t.length - 1],
    c = { done: !1, value: l },
    {
      stiffness: p,
      damping: h,
      mass: m,
      velocity: g,
      duration: b,
      isResolvedFromDuration: C,
    } = U7(o),
    w = g ? -Po(g) : 0,
    k = h / (2 * Math.sqrt(p * m)),
    D = f - l,
    E = Po(Math.sqrt(p / m)),
    M = Math.abs(D) < 5
  a || (a = M ? 0.01 : 2), r || (r = M ? 0.005 : 0.5)
  let z
  if (k < 1) {
    const P = IS(E, k)
    z = (B) => {
      const j = Math.exp(-k * E * B)
      return f - j * (((w + k * E * D) / P) * Math.sin(P * B) + D * Math.cos(P * B))
    }
  } else if (k === 1) z = (P) => f - Math.exp(-E * P) * (D + (w + E * D) * P)
  else {
    const P = E * Math.sqrt(k * k - 1)
    z = (B) => {
      const j = Math.exp(-k * E * B),
        Q = Math.min(P * B, 300)
      return f - (j * ((w + k * E * D) * Math.sinh(Q) + P * D * Math.cosh(Q))) / P
    }
  }
  return {
    calculatedDuration: (C && b) || null,
    next: (P) => {
      const B = z(P)
      if (C) c.done = P >= b
      else {
        let j = w
        P !== 0 && (k < 1 ? (j = pO(z, P, B)) : (j = 0))
        const Q = Math.abs(j) <= a,
          Y = Math.abs(f - B) <= r
        c.done = Q && Y
      }
      return (c.value = c.done ? f : B), c
    },
  }
}
function H_({
  keyframes: t,
  velocity: r = 0,
  power: a = 0.8,
  timeConstant: o = 325,
  bounceDamping: l = 10,
  bounceStiffness: f = 500,
  modifyTarget: c,
  min: p,
  max: h,
  restDelta: m = 0.5,
  restSpeed: g,
}) {
  const b = t[0],
    C = { done: !1, value: b },
    w = (ne) => (p !== void 0 && ne < p) || (h !== void 0 && ne > h),
    k = (ne) => (p === void 0 ? h : h === void 0 || Math.abs(p - ne) < Math.abs(h - ne) ? p : h)
  let D = a * r
  const E = b + D,
    M = c === void 0 ? E : c(E)
  M !== E && (D = M - b)
  const z = (ne) => -D * Math.exp(-ne / o),
    P = (ne) => M + z(ne),
    B = (ne) => {
      const he = z(ne),
        le = P(ne)
      ;(C.done = Math.abs(he) <= m), (C.value = C.done ? M : le)
    }
  let j, Q
  const Y = (ne) => {
    w(C.value) &&
      ((j = ne),
      (Q = hO({
        keyframes: [C.value, k(C.value)],
        velocity: pO(P, ne, C.value),
        damping: l,
        stiffness: f,
        restDelta: m,
        restSpeed: g,
      })))
  }
  return (
    Y(0),
    {
      calculatedDuration: null,
      next: (ne) => {
        let he = !1
        return (
          !Q && j === void 0 && ((he = !0), B(ne), Y(ne)),
          j !== void 0 && ne > j ? Q.next(ne - j) : (!he && B(ne), C)
        )
      },
    }
  )
}
const V7 = (t) => {
    const r = ({ timestamp: a }) => t(a)
    return {
      start: () => Rn.update(r, !0),
      stop: () => Ds.update(r),
      now: () => (Fr.isProcessing ? Fr.timestamp : performance.now()),
    }
  },
  I7 = { decay: H_, inertia: H_, tween: Jm, keyframes: Jm, spring: hO },
  W_ = 2e4
function Y_(t) {
  let r = 0
  const a = 50
  let o = t.next(r)
  for (; !o.done && r < W_; ) (r += a), (o = t.next(r))
  return r >= W_ ? 1 / 0 : r
}
function ev({
  autoplay: t = !0,
  delay: r = 0,
  driver: a = V7,
  keyframes: o,
  type: l = 'keyframes',
  repeat: f = 0,
  repeatDelay: c = 0,
  repeatType: p = 'loop',
  onPlay: h,
  onStop: m,
  onComplete: g,
  onUpdate: b,
  ...C
}) {
  let w = 1,
    k = !1,
    D,
    E
  const M = () => {
    D && D(),
      (E = new Promise((qe) => {
        D = qe
      }))
  }
  M()
  let z
  const P = I7[l] || Jm
  let B
  P !== Jm && typeof o[0] != 'number' && ((B = fO([0, 100], o, { clamp: !1 })), (o = [0, 100]))
  const j = P({ ...C, keyframes: o })
  let Q
  p === 'mirror' && (Q = P({ ...C, keyframes: [...o].reverse(), velocity: -(C.velocity || 0) }))
  let Y = 'idle',
    ne = null,
    he = null,
    le = null
  j.calculatedDuration === null && f && (j.calculatedDuration = Y_(j))
  const { calculatedDuration: pe } = j
  let Ne = 1 / 0,
    me = 1 / 0
  pe !== null && ((Ne = pe + c), (me = Ne * (f + 1) - c))
  let ge = 0
  const Oe = (qe) => {
      if (he === null) return
      w > 0 && (he = Math.min(he, qe)), ne !== null ? (ge = ne) : (ge = (qe - he) * w)
      const vt = ge - r,
        Pe = vt < 0
      ;(ge = Math.max(vt, 0)), Y === 'finished' && ne === null && (ge = me)
      let Ke = ge,
        Mt = j
      if (f) {
        const zt = ge / Ne
        let Qt = Math.floor(zt),
          Ct = zt % 1
        !Ct && zt >= 1 && (Ct = 1), Ct === 1 && Qt--, (Qt = Math.min(Qt, f + 1))
        const xe = !!(Qt % 2)
        xe && (p === 'reverse' ? ((Ct = 1 - Ct), c && (Ct -= c / Ne)) : p === 'mirror' && (Mt = Q))
        let wt = Ll(0, 1, Ct)
        ge > me && (wt = p === 'reverse' && xe ? 1 : 0), (Ke = wt * Ne)
      }
      const Rt = Pe ? { done: !1, value: o[0] } : Mt.next(Ke)
      B && (Rt.value = B(Rt.value))
      let { done: an } = Rt
      !Pe && pe !== null && (an = ge >= me)
      const _t = ne === null && (Y === 'finished' || (Y === 'running' && an) || (w < 0 && ge <= 0))
      return b && b(Rt.value), _t && ut(), Rt
    },
    ze = () => {
      z && z.stop(), (z = void 0)
    },
    ee = () => {
      ;(Y = 'idle'), ze(), M(), (he = le = null)
    },
    ut = () => {
      ;(Y = 'finished'), g && g(), ze(), M()
    },
    Bt = () => {
      if (k) return
      z || (z = a(Oe))
      const qe = z.now()
      h && h(),
        (Y = 'running'),
        ne !== null ? (he = qe - ne) : he || (he = qe),
        (le = he),
        (ne = null),
        z.start()
    }
  t && Bt()
  const rt = {
    then(qe, vt) {
      return E.then(qe, vt)
    },
    get time() {
      return Po(ge)
    },
    set time(qe) {
      ;(qe = Rs(qe)), (ge = qe), ne !== null || !z || w === 0 ? (ne = qe) : (he = z.now() - qe / w)
    },
    get duration() {
      const qe = j.calculatedDuration === null ? Y_(j) : j.calculatedDuration
      return Po(qe)
    },
    get speed() {
      return w
    },
    set speed(qe) {
      qe === w || !z || ((w = qe), (rt.time = Po(ge)))
    },
    get state() {
      return Y
    },
    play: Bt,
    pause: () => {
      ;(Y = 'paused'), (ne = ge)
    },
    stop: () => {
      ;(k = !0), Y !== 'idle' && ((Y = 'idle'), m && m(), ee())
    },
    cancel: () => {
      le !== null && Oe(le), ee()
    },
    complete: () => {
      Y = 'finished'
    },
    sample: (qe) => ((he = 0), Oe(qe)),
  }
  return rt
}
const H7 = new Set(['opacity', 'clipPath', 'filter', 'transform', 'backgroundColor']),
  bm = 10,
  W7 = 2e4,
  Y7 = (t, r) => r.type === 'spring' || t === 'backgroundColor' || !YA(r.ease)
function G7(t, r, { onUpdate: a, onComplete: o, ...l }) {
  if (
    !(
      KA.waapi() &&
      H7.has(r) &&
      !l.repeatDelay &&
      l.repeatType !== 'mirror' &&
      l.damping !== 0 &&
      l.type !== 'inertia'
    )
  )
    return !1
  let c = !1,
    p,
    h
  const m = () => {
    h = new Promise((D) => {
      p = D
    })
  }
  m()
  let { keyframes: g, duration: b = 300, ease: C } = l
  if (Y7(r, l)) {
    const D = ev({ ...l, repeat: 0, delay: 0 })
    let E = { done: !1, value: g[0] }
    const M = []
    let z = 0
    for (; !E.done && z < W7; ) (E = D.sample(z)), M.push(E.value), (z += bm)
    ;(g = M), (b = z - bm), (C = 'linear')
  }
  const w = o7(t.owner.current, r, g, { ...l, duration: b, ease: C }),
    k = () => {
      Rn.update(() => w.cancel()), p(), m()
    }
  return (
    (w.onfinish = () => {
      t.set(s7(g, l)), o && o(), k()
    }),
    {
      then(D, E) {
        return h.then(D, E)
      },
      get time() {
        return Po(w.currentTime || 0)
      },
      set time(D) {
        w.currentTime = Rs(D)
      },
      get speed() {
        return w.playbackRate
      },
      set speed(D) {
        w.playbackRate = D
      },
      get duration() {
        return Po(b)
      },
      play: () => {
        c || w.play()
      },
      pause: () => w.pause(),
      stop: () => {
        if (((c = !0), w.playState === 'idle')) return
        const { currentTime: D } = w
        if (D) {
          const E = ev({ ...l, autoplay: !1 })
          t.setWithVelocity(E.sample(D - bm).value, E.sample(D).value, bm)
        }
        k()
      },
      complete: () => w.finish(),
      cancel: k,
    }
  )
}
function q7({ keyframes: t, delay: r, onUpdate: a, onComplete: o }) {
  const l = () => (
    a && a(t[t.length - 1]),
    o && o(),
    {
      time: 0,
      speed: 1,
      duration: 0,
      play: vr,
      pause: vr,
      stop: vr,
      then: (f) => (f(), Promise.resolve()),
      cancel: vr,
      complete: vr,
    }
  )
  return r ? ev({ keyframes: [0, 1], duration: 0, delay: r, onComplete: l }) : l()
}
const K7 = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
  X7 = (t) => ({
    type: 'spring',
    stiffness: 550,
    damping: t === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  Q7 = { type: 'keyframes', duration: 0.8 },
  Z7 = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  J7 = (t, { keyframes: r }) =>
    r.length > 2 ? Q7 : Fl.has(t) ? (t.startsWith('scale') ? X7(r[1]) : K7) : Z7,
  HS = (t, r) =>
    t === 'zIndex'
      ? !1
      : !!(
          typeof r == 'number' ||
          Array.isArray(r) ||
          (typeof r == 'string' && As.test(r) && !r.startsWith('url('))
        ),
  eY = new Set(['brightness', 'contrast', 'saturate', 'opacity'])
function tY(t) {
  const [r, a] = t.slice(0, -1).split('(')
  if (r === 'drop-shadow') return t
  const [o] = a.match(Nd) || []
  if (!o) return t
  const l = a.replace(o, '')
  let f = eY.has(r) ? 1 : 0
  return o !== a && (f *= 100), r + '(' + f + l + ')'
}
const nY = /([a-z-]*)\(.*?\)/g,
  WS = {
    ...As,
    getAnimatableNone: (t) => {
      const r = t.match(nY)
      return r ? r.map(tY).join(' ') : t
    },
  },
  rY = {
    ...DA,
    color: Kr,
    backgroundColor: Kr,
    outlineColor: Kr,
    fill: Kr,
    stroke: Kr,
    borderColor: Kr,
    borderTopColor: Kr,
    borderRightColor: Kr,
    borderBottomColor: Kr,
    borderLeftColor: Kr,
    filter: WS,
    WebkitFilter: WS,
  },
  Kx = (t) => rY[t]
function Xx(t, r) {
  let a = Kx(t)
  return a !== WS && (a = As), a.getAnimatableNone ? a.getAnimatableNone(r) : void 0
}
function aY({
  when: t,
  delay: r,
  delayChildren: a,
  staggerChildren: o,
  staggerDirection: l,
  repeat: f,
  repeatType: c,
  repeatDelay: p,
  from: h,
  elapsed: m,
  ...g
}) {
  return !!Object.keys(g).length
}
function G_(t) {
  return t === 0 || (typeof t == 'string' && parseFloat(t) === 0 && t.indexOf(' ') === -1)
}
function q_(t) {
  return typeof t == 'number' ? 0 : Xx('', t)
}
function mO(t, r) {
  return t[r] || t.default || t
}
function iY(t, r, a, o) {
  const l = HS(r, a)
  let f = o.from !== void 0 ? o.from : t.get()
  if (
    (f === 'none' && l && typeof a == 'string'
      ? (f = Xx(r, a))
      : G_(f) && typeof a == 'string'
      ? (f = q_(a))
      : !Array.isArray(a) && G_(a) && typeof f == 'string' && (a = q_(f)),
    Array.isArray(a))
  ) {
    for (let c = 0; c < a.length; c++) a[c] === null && (a[c] = c === 0 ? f : a[c - 1])
    return a
  } else return [f, a]
}
const Qx =
  (t, r, a, o = {}) =>
  (l) => {
    const f = mO(o, t) || {},
      c = f.delay || o.delay || 0
    let { elapsed: p = 0 } = o
    p = p - Rs(c)
    const h = iY(r, t, a, f),
      m = h[0],
      g = h[h.length - 1],
      b = HS(t, m),
      C = HS(t, g)
    Jd(
      b === C,
      `You are trying to animate ${t} from "${m}" to "${g}". ${m} is not an animatable value - to enable this animation set ${m} to a value animatable to ${g} via the \`style\` property.`
    )
    let w = {
      keyframes: h,
      velocity: r.getVelocity(),
      ease: 'easeOut',
      ...f,
      delay: -p,
      onUpdate: (k) => {
        r.set(k), f.onUpdate && f.onUpdate(k)
      },
      onComplete: () => {
        l(), f.onComplete && f.onComplete()
      },
    }
    if (
      (aY(f) || (w = { ...w, ...J7(t, w) }),
      w.duration && (w.duration = Rs(w.duration)),
      w.repeatDelay && (w.repeatDelay = Rs(w.repeatDelay)),
      !b || !C || i7.current || f.type === !1)
    )
      return q7(w)
    if (r.owner && r.owner.current instanceof HTMLElement && !r.owner.getProps().onUpdate) {
      const k = G7(r, t, w)
      if (k) return k
    }
    return ev(w)
  }
function tv(t) {
  return !!(ha(t) && t.add)
}
const oY = (t) => /^\-?\d*\.?\d+$/.test(t),
  sY = (t) => /^0[^.\s]+$/.test(t)
function Zx(t, r) {
  t.indexOf(r) === -1 && t.push(r)
}
function Jx(t, r) {
  const a = t.indexOf(r)
  a > -1 && t.splice(a, 1)
}
class eC {
  constructor() {
    this.subscriptions = []
  }
  add(r) {
    return Zx(this.subscriptions, r), () => Jx(this.subscriptions, r)
  }
  notify(r, a, o) {
    const l = this.subscriptions.length
    if (l)
      if (l === 1) this.subscriptions[0](r, a, o)
      else
        for (let f = 0; f < l; f++) {
          const c = this.subscriptions[f]
          c && c(r, a, o)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
const K_ = new Set()
function tC(t, r, a) {
  t || K_.has(r) || (console.warn(r), a && console.warn(a), K_.add(r))
}
const lY = (t) => !isNaN(parseFloat(t))
class uY {
  constructor(r, a = {}) {
    ;(this.version = '10.10.0'),
      (this.timeDelta = 0),
      (this.lastUpdated = 0),
      (this.canTrackVelocity = !1),
      (this.events = {}),
      (this.updateAndNotify = (o, l = !0) => {
        ;(this.prev = this.current), (this.current = o)
        const { delta: f, timestamp: c } = Fr
        this.lastUpdated !== c &&
          ((this.timeDelta = f), (this.lastUpdated = c), Rn.postRender(this.scheduleVelocityCheck)),
          this.prev !== this.current &&
            this.events.change &&
            this.events.change.notify(this.current),
          this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()),
          l && this.events.renderRequest && this.events.renderRequest.notify(this.current)
      }),
      (this.scheduleVelocityCheck = () => Rn.postRender(this.velocityCheck)),
      (this.velocityCheck = ({ timestamp: o }) => {
        o !== this.lastUpdated &&
          ((this.prev = this.current),
          this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
      }),
      (this.hasAnimated = !1),
      (this.prev = this.current = r),
      (this.canTrackVelocity = lY(this.current)),
      (this.owner = a.owner)
  }
  onChange(r) {
    return (
      tC(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'),
      this.on('change', r)
    )
  }
  on(r, a) {
    this.events[r] || (this.events[r] = new eC())
    const o = this.events[r].add(a)
    return r === 'change'
      ? () => {
          o(),
            Rn.read(() => {
              this.events.change.getSize() || this.stop()
            })
        }
      : o
  }
  clearListeners() {
    for (const r in this.events) this.events[r].clear()
  }
  attach(r, a) {
    ;(this.passiveEffect = r), (this.stopPassiveEffect = a)
  }
  set(r, a = !0) {
    !a || !this.passiveEffect
      ? this.updateAndNotify(r, a)
      : this.passiveEffect(r, this.updateAndNotify)
  }
  setWithVelocity(r, a, o) {
    this.set(a), (this.prev = r), (this.timeDelta = o)
  }
  jump(r) {
    this.updateAndNotify(r),
      (this.prev = r),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
  get() {
    return this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    return this.canTrackVelocity
      ? dO(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      : 0
  }
  start(r) {
    return (
      this.stop(),
      new Promise((a) => {
        ;(this.hasAnimated = !0),
          (this.animation = r(a)),
          this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation()
      })
    )
  }
  stop() {
    this.animation &&
      (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation()
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
  }
}
function ic(t, r) {
  return new uY(t, r)
}
const vO = (t) => (r) => r.test(t),
  cY = { test: (t) => t === 'auto', parse: (t) => t },
  gO = [Nl, Qe, Yi, Ss, y8, g8, cY],
  Jf = (t) => gO.find(vO(t)),
  fY = [...gO, Kr, As],
  dY = (t) => fY.find(vO(t))
function pY(t, r, a) {
  t.hasValue(r) ? t.getValue(r).set(a) : t.addValue(r, ic(a))
}
function hY(t, r) {
  const a = kv(t, r)
  let { transitionEnd: o = {}, transition: l = {}, ...f } = a ? t.makeTargetAnimatable(a, !1) : {}
  f = { ...f, ...o }
  for (const c in f) {
    const p = M8(f[c])
    pY(t, c, p)
  }
}
function mY(t, r, a) {
  var o, l
  const f = Object.keys(r).filter((p) => !t.hasValue(p)),
    c = f.length
  if (c)
    for (let p = 0; p < c; p++) {
      const h = f[p],
        m = r[h]
      let g = null
      Array.isArray(m) && (g = m[0]),
        g === null &&
          (g =
            (l = (o = a[h]) !== null && o !== void 0 ? o : t.readValue(h)) !== null && l !== void 0
              ? l
              : r[h]),
        g != null &&
          (typeof g == 'string' && (oY(g) || sY(g))
            ? (g = parseFloat(g))
            : !dY(g) && As.test(m) && (g = Xx(h, m)),
          t.addValue(h, ic(g, { owner: t })),
          a[h] === void 0 && (a[h] = g),
          g !== null && t.setBaseTarget(h, g))
    }
}
function vY(t, r) {
  return r ? (r[t] || r.default || r).from : void 0
}
function gY(t, r, a) {
  const o = {}
  for (const l in t) {
    const f = vY(l, r)
    if (f !== void 0) o[l] = f
    else {
      const c = a.getValue(l)
      c && (o[l] = c.get())
    }
  }
  return o
}
function yY({ protectedKeys: t, needsAnimating: r }, a) {
  const o = t.hasOwnProperty(a) && r[a] !== !0
  return (r[a] = !1), o
}
function yO(t, r, { delay: a = 0, transitionOverride: o, type: l } = {}) {
  let {
    transition: f = t.getDefaultTransition(),
    transitionEnd: c,
    ...p
  } = t.makeTargetAnimatable(r)
  const h = t.getValue('willChange')
  o && (f = o)
  const m = [],
    g = l && t.animationState && t.animationState.getState()[l]
  for (const b in p) {
    const C = t.getValue(b),
      w = p[b]
    if (!C || w === void 0 || (g && yY(g, b))) continue
    const k = { delay: a, elapsed: 0, ...f }
    if (window.HandoffAppearAnimations && !C.hasAnimated) {
      const E = t.getProps()[a7]
      E && (k.elapsed = window.HandoffAppearAnimations(E, b, C, Rn))
    }
    C.start(Qx(b, C, w, t.shouldReduceMotion && Fl.has(b) ? { type: !1 } : k))
    const D = C.animation
    tv(h) && (h.add(b), D.then(() => h.remove(b))), m.push(D)
  }
  return (
    c &&
      Promise.all(m).then(() => {
        c && hY(t, c)
      }),
    m
  )
}
function YS(t, r, a = {}) {
  const o = kv(t, r, a.custom)
  let { transition: l = t.getDefaultTransition() || {} } = o || {}
  a.transitionOverride && (l = a.transitionOverride)
  const f = o ? () => Promise.all(yO(t, o, a)) : () => Promise.resolve(),
    c =
      t.variantChildren && t.variantChildren.size
        ? (h = 0) => {
            const { delayChildren: m = 0, staggerChildren: g, staggerDirection: b } = l
            return bY(t, r, m + h, g, b, a)
          }
        : () => Promise.resolve(),
    { when: p } = l
  if (p) {
    const [h, m] = p === 'beforeChildren' ? [f, c] : [c, f]
    return h().then(() => m())
  } else return Promise.all([f(), c(a.delay)])
}
function bY(t, r, a = 0, o = 0, l = 1, f) {
  const c = [],
    p = (t.variantChildren.size - 1) * o,
    h = l === 1 ? (m = 0) => m * o : (m = 0) => p - m * o
  return (
    Array.from(t.variantChildren)
      .sort(SY)
      .forEach((m, g) => {
        m.notify('AnimationStart', r),
          c.push(YS(m, r, { ...f, delay: a + h(g) }).then(() => m.notify('AnimationComplete', r)))
      }),
    Promise.all(c)
  )
}
function SY(t, r) {
  return t.sortNodePosition(r)
}
function xY(t, r, a = {}) {
  t.notify('AnimationStart', r)
  let o
  if (Array.isArray(r)) {
    const l = r.map((f) => YS(t, f, a))
    o = Promise.all(l)
  } else if (typeof r == 'string') o = YS(t, r, a)
  else {
    const l = typeof r == 'function' ? kv(t, r, a.custom) : r
    o = Promise.all(yO(t, l, a))
  }
  return o.then(() => t.notify('AnimationComplete', r))
}
const CY = [...Lx].reverse(),
  wY = Lx.length
function EY(t) {
  return (r) => Promise.all(r.map(({ animation: a, options: o }) => xY(t, a, o)))
}
function TY(t) {
  let r = EY(t)
  const a = _Y()
  let o = !0
  const l = (h, m) => {
    const g = kv(t, m)
    if (g) {
      const { transition: b, transitionEnd: C, ...w } = g
      h = { ...h, ...w, ...C }
    }
    return h
  }
  function f(h) {
    r = h(t)
  }
  function c(h, m) {
    const g = t.getProps(),
      b = t.getVariantContext(!0) || {},
      C = [],
      w = new Set()
    let k = {},
      D = 1 / 0
    for (let M = 0; M < wY; M++) {
      const z = CY[M],
        P = a[z],
        B = g[z] !== void 0 ? g[z] : b[z],
        j = $d(B),
        Q = z === m ? P.isActive : null
      Q === !1 && (D = M)
      let Y = B === b[z] && B !== g[z] && j
      if (
        (Y && o && t.manuallyAnimateOnMount && (Y = !1),
        (P.protectedKeys = { ...k }),
        (!P.isActive && Q === null) || (!B && !P.prevProp) || wv(B) || typeof B == 'boolean')
      )
        continue
      const ne = RY(P.prevProp, B)
      let he = ne || (z === m && P.isActive && !Y && j) || (M > D && j)
      const le = Array.isArray(B) ? B : [B]
      let pe = le.reduce(l, {})
      Q === !1 && (pe = {})
      const { prevResolvedValues: Ne = {} } = P,
        me = { ...Ne, ...pe },
        ge = (Oe) => {
          ;(he = !0), w.delete(Oe), (P.needsAnimating[Oe] = !0)
        }
      for (const Oe in me) {
        const ze = pe[Oe],
          ee = Ne[Oe]
        k.hasOwnProperty(Oe) ||
          (ze !== ee
            ? Qm(ze) && Qm(ee)
              ? !HA(ze, ee) || ne
                ? ge(Oe)
                : (P.protectedKeys[Oe] = !0)
              : ze !== void 0
              ? ge(Oe)
              : w.add(Oe)
            : ze !== void 0 && w.has(Oe)
            ? ge(Oe)
            : (P.protectedKeys[Oe] = !0))
      }
      ;(P.prevProp = B),
        (P.prevResolvedValues = pe),
        P.isActive && (k = { ...k, ...pe }),
        o && t.blockInitialAnimation && (he = !1),
        he && !Y && C.push(...le.map((Oe) => ({ animation: Oe, options: { type: z, ...h } })))
    }
    if (w.size) {
      const M = {}
      w.forEach((z) => {
        const P = t.getBaseTarget(z)
        P !== void 0 && (M[z] = P)
      }),
        C.push({ animation: M })
    }
    let E = !!C.length
    return (
      o && g.initial === !1 && !t.manuallyAnimateOnMount && (E = !1),
      (o = !1),
      E ? r(C) : Promise.resolve()
    )
  }
  function p(h, m, g) {
    var b
    if (a[h].isActive === m) return Promise.resolve()
    ;(b = t.variantChildren) === null ||
      b === void 0 ||
      b.forEach((w) => {
        var k
        return (k = w.animationState) === null || k === void 0 ? void 0 : k.setActive(h, m)
      }),
      (a[h].isActive = m)
    const C = c(g, h)
    for (const w in a) a[w].protectedKeys = {}
    return C
  }
  return { animateChanges: c, setActive: p, setAnimateFunction: f, getState: () => a }
}
function RY(t, r) {
  return typeof r == 'string' ? r !== t : Array.isArray(r) ? !HA(r, t) : !1
}
function Cl(t = !1) {
  return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} }
}
function _Y() {
  return {
    animate: Cl(!0),
    whileInView: Cl(),
    whileHover: Cl(),
    whileTap: Cl(),
    whileDrag: Cl(),
    whileFocus: Cl(),
    exit: Cl(),
  }
}
class kY extends Ls {
  constructor(r) {
    super(r), r.animationState || (r.animationState = TY(r))
  }
  updateAnimationControlsSubscription() {
    const { animate: r } = this.node.getProps()
    this.unmount(), wv(r) && (this.unmount = r.subscribe(this.node))
  }
  mount() {
    this.updateAnimationControlsSubscription()
  }
  update() {
    const { animate: r } = this.node.getProps(),
      { animate: a } = this.node.prevProps || {}
    r !== a && this.updateAnimationControlsSubscription()
  }
  unmount() {}
}
let DY = 0
class AY extends Ls {
  constructor() {
    super(...arguments), (this.id = DY++)
  }
  update() {
    if (!this.node.presenceContext) return
    const { isPresent: r, onExitComplete: a, custom: o } = this.node.presenceContext,
      { isPresent: l } = this.node.prevPresenceContext || {}
    if (!this.node.animationState || r === l) return
    const f = this.node.animationState.setActive('exit', !r, {
      custom: o ?? this.node.getProps().custom,
    })
    a && !r && f.then(() => a(this.id))
  }
  mount() {
    const { register: r } = this.node.presenceContext || {}
    r && (this.unmount = r(this.id))
  }
  unmount() {}
}
const OY = { animation: { Feature: kY }, exit: { Feature: AY } },
  X_ = (t, r) => Math.abs(t - r)
function MY(t, r) {
  const a = X_(t.x, r.x),
    o = X_(t.y, r.y)
  return Math.sqrt(a ** 2 + o ** 2)
}
class bO {
  constructor(r, a, { transformPagePoint: o } = {}) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const m = fS(this.lastMoveEventInfo, this.history),
          g = this.startEvent !== null,
          b = MY(m.offset, { x: 0, y: 0 }) >= 3
        if (!g && !b) return
        const { point: C } = m,
          { timestamp: w } = Fr
        this.history.push({ ...C, timestamp: w })
        const { onStart: k, onMove: D } = this.handlers
        g || (k && k(this.lastMoveEvent, m), (this.startEvent = this.lastMoveEvent)),
          D && D(this.lastMoveEvent, m)
      }),
      (this.handlePointerMove = (m, g) => {
        ;(this.lastMoveEvent = m),
          (this.lastMoveEventInfo = cS(g, this.transformPagePoint)),
          Rn.update(this.updatePoint, !0)
      }),
      (this.handlePointerUp = (m, g) => {
        if ((this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo))) return
        const { onEnd: b, onSessionEnd: C } = this.handlers,
          w = fS(
            m.type === 'pointercancel' ? this.lastMoveEventInfo : cS(g, this.transformPagePoint),
            this.history
          )
        this.startEvent && b && b(m, w), C && C(m, w)
      }),
      !NA(r))
    )
      return
    ;(this.handlers = a), (this.transformPagePoint = o)
    const l = Rv(r),
      f = cS(l, this.transformPagePoint),
      { point: c } = f,
      { timestamp: p } = Fr
    this.history = [{ ...c, timestamp: p }]
    const { onSessionStart: h } = a
    h && h(r, fS(f, this.history)),
      (this.removeListeners = Ts(
        Mo(window, 'pointermove', this.handlePointerMove),
        Mo(window, 'pointerup', this.handlePointerUp),
        Mo(window, 'pointercancel', this.handlePointerUp)
      ))
  }
  updateHandlers(r) {
    this.handlers = r
  }
  end() {
    this.removeListeners && this.removeListeners(), Ds.update(this.updatePoint)
  }
}
function cS(t, r) {
  return r ? { point: r(t.point) } : t
}
function Q_(t, r) {
  return { x: t.x - r.x, y: t.y - r.y }
}
function fS({ point: t }, r) {
  return { point: t, delta: Q_(t, SO(r)), offset: Q_(t, PY(r)), velocity: LY(r, 0.1) }
}
function PY(t) {
  return t[0]
}
function SO(t) {
  return t[t.length - 1]
}
function LY(t, r) {
  if (t.length < 2) return { x: 0, y: 0 }
  let a = t.length - 1,
    o = null
  const l = SO(t)
  for (; a >= 0 && ((o = t[a]), !(l.timestamp - o.timestamp > Rs(r))); ) a--
  if (!o) return { x: 0, y: 0 }
  const f = Po(l.timestamp - o.timestamp)
  if (f === 0) return { x: 0, y: 0 }
  const c = { x: (l.x - o.x) / f, y: (l.y - o.y) / f }
  return c.x === 1 / 0 && (c.x = 0), c.y === 1 / 0 && (c.y = 0), c
}
function Pa(t) {
  return t.max - t.min
}
function GS(t, r = 0, a = 0.01) {
  return Math.abs(t - r) <= a
}
function Z_(t, r, a, o = 0.5) {
  ;(t.origin = o),
    (t.originPoint = An(r.min, r.max, t.origin)),
    (t.scale = Pa(a) / Pa(r)),
    (GS(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1),
    (t.translate = An(a.min, a.max, t.origin) - t.originPoint),
    (GS(t.translate) || isNaN(t.translate)) && (t.translate = 0)
}
function gd(t, r, a, o) {
  Z_(t.x, r.x, a.x, o ? o.originX : void 0), Z_(t.y, r.y, a.y, o ? o.originY : void 0)
}
function J_(t, r, a) {
  ;(t.min = a.min + r.min), (t.max = t.min + Pa(r))
}
function zY(t, r, a) {
  J_(t.x, r.x, a.x), J_(t.y, r.y, a.y)
}
function ek(t, r, a) {
  ;(t.min = r.min - a.min), (t.max = t.min + Pa(r))
}
function yd(t, r, a) {
  ek(t.x, r.x, a.x), ek(t.y, r.y, a.y)
}
function $Y(t, { min: r, max: a }, o) {
  return (
    r !== void 0 && t < r
      ? (t = o ? An(r, t, o.min) : Math.max(t, r))
      : a !== void 0 && t > a && (t = o ? An(a, t, o.max) : Math.min(t, a)),
    t
  )
}
function tk(t, r, a) {
  return {
    min: r !== void 0 ? t.min + r : void 0,
    max: a !== void 0 ? t.max + a - (t.max - t.min) : void 0,
  }
}
function FY(t, { top: r, left: a, bottom: o, right: l }) {
  return { x: tk(t.x, a, l), y: tk(t.y, r, o) }
}
function nk(t, r) {
  let a = r.min - t.min,
    o = r.max - t.max
  return r.max - r.min < t.max - t.min && ([a, o] = [o, a]), { min: a, max: o }
}
function NY(t, r) {
  return { x: nk(t.x, r.x), y: nk(t.y, r.y) }
}
function BY(t, r) {
  let a = 0.5
  const o = Pa(t),
    l = Pa(r)
  return (
    l > o ? (a = jd(r.min, r.max - o, t.min)) : o > l && (a = jd(t.min, t.max - l, r.min)),
    Ll(0, 1, a)
  )
}
function jY(t, r) {
  const a = {}
  return r.min !== void 0 && (a.min = r.min - t.min), r.max !== void 0 && (a.max = r.max - t.min), a
}
const qS = 0.35
function UY(t = qS) {
  return (
    t === !1 ? (t = 0) : t === !0 && (t = qS),
    { x: rk(t, 'left', 'right'), y: rk(t, 'top', 'bottom') }
  )
}
function rk(t, r, a) {
  return { min: ak(t, r), max: ak(t, a) }
}
function ak(t, r) {
  return typeof t == 'number' ? t : t[r] || 0
}
const ik = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  bd = () => ({ x: ik(), y: ik() }),
  ok = () => ({ min: 0, max: 0 }),
  Yn = () => ({ x: ok(), y: ok() })
function Ni(t) {
  return [t('x'), t('y')]
}
function xO({ top: t, left: r, right: a, bottom: o }) {
  return { x: { min: r, max: a }, y: { min: t, max: o } }
}
function VY({ x: t, y: r }) {
  return { top: r.min, right: t.max, bottom: r.max, left: t.min }
}
function IY(t, r) {
  if (!r) return t
  const a = r({ x: t.left, y: t.top }),
    o = r({ x: t.right, y: t.bottom })
  return { top: a.y, left: a.x, bottom: o.y, right: o.x }
}
function dS(t) {
  return t === void 0 || t === 1
}
function KS({ scale: t, scaleX: r, scaleY: a }) {
  return !dS(t) || !dS(r) || !dS(a)
}
function El(t) {
  return KS(t) || CO(t) || t.z || t.rotate || t.rotateX || t.rotateY
}
function CO(t) {
  return sk(t.x) || sk(t.y)
}
function sk(t) {
  return t && t !== '0%'
}
function nv(t, r, a) {
  const o = t - a,
    l = r * o
  return a + l
}
function lk(t, r, a, o, l) {
  return l !== void 0 && (t = nv(t, l, o)), nv(t, a, o) + r
}
function XS(t, r = 0, a = 1, o, l) {
  ;(t.min = lk(t.min, r, a, o, l)), (t.max = lk(t.max, r, a, o, l))
}
function wO(t, { x: r, y: a }) {
  XS(t.x, r.translate, r.scale, r.originPoint), XS(t.y, a.translate, a.scale, a.originPoint)
}
function HY(t, r, a, o = !1) {
  const l = a.length
  if (!l) return
  r.x = r.y = 1
  let f, c
  for (let p = 0; p < l; p++) {
    ;(f = a[p]), (c = f.projectionDelta)
    const h = f.instance
    ;(h && h.style && h.style.display === 'contents') ||
      (o &&
        f.options.layoutScroll &&
        f.scroll &&
        f !== f.root &&
        Yu(t, { x: -f.scroll.offset.x, y: -f.scroll.offset.y }),
      c && ((r.x *= c.x.scale), (r.y *= c.y.scale), wO(t, c)),
      o && El(f.latestValues) && Yu(t, f.latestValues))
  }
  ;(r.x = uk(r.x)), (r.y = uk(r.y))
}
function uk(t) {
  return Number.isInteger(t) || t > 1.0000000000001 || t < 0.999999999999 ? t : 1
}
function Cs(t, r) {
  ;(t.min = t.min + r), (t.max = t.max + r)
}
function ck(t, r, [a, o, l]) {
  const f = r[l] !== void 0 ? r[l] : 0.5,
    c = An(t.min, t.max, f)
  XS(t, r[a], r[o], c, r.scale)
}
const WY = ['x', 'scaleX', 'originX'],
  YY = ['y', 'scaleY', 'originY']
function Yu(t, r) {
  ck(t.x, r, WY), ck(t.y, r, YY)
}
function EO(t, r) {
  return xO(IY(t.getBoundingClientRect(), r))
}
function GY(t, r, a) {
  const o = EO(t, a),
    { scroll: l } = r
  return l && (Cs(o.x, l.offset.x), Cs(o.y, l.offset.y)), o
}
const qY = new WeakMap()
class KY {
  constructor(r) {
    ;(this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Yn()),
      (this.visualElement = r)
  }
  start(r, { snapToCursor: a = !1 } = {}) {
    const { presenceContext: o } = this.visualElement
    if (o && o.isPresent === !1) return
    const l = (h) => {
        this.stopAnimation(), a && this.snapToCursor(Rv(h, 'page').point)
      },
      f = (h, m) => {
        const { drag: g, dragPropagation: b, onDragStart: C } = this.getProps()
        if (
          g &&
          !b &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = jA(g)),
          !this.openGlobalLock)
        )
          return
        ;(this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Ni((k) => {
            let D = this.getAxisMotionValue(k).get() || 0
            if (Yi.test(D)) {
              const { projection: E } = this.visualElement
              if (E && E.layout) {
                const M = E.layout.layoutBox[k]
                M && (D = Pa(M) * (parseFloat(D) / 100))
              }
            }
            this.originPoint[k] = D
          }),
          C && Rn.update(() => C(h, m))
        const { animationState: w } = this.visualElement
        w && w.setActive('whileDrag', !0)
      },
      c = (h, m) => {
        const {
          dragPropagation: g,
          dragDirectionLock: b,
          onDirectionLock: C,
          onDrag: w,
        } = this.getProps()
        if (!g && !this.openGlobalLock) return
        const { offset: k } = m
        if (b && this.currentDirection === null) {
          ;(this.currentDirection = XY(k)),
            this.currentDirection !== null && C && C(this.currentDirection)
          return
        }
        this.updateAxis('x', m.point, k),
          this.updateAxis('y', m.point, k),
          this.visualElement.render(),
          w && w(h, m)
      },
      p = (h, m) => this.stop(h, m)
    this.panSession = new bO(
      r,
      { onSessionStart: l, onStart: f, onMove: c, onSessionEnd: p },
      { transformPagePoint: this.visualElement.getTransformPagePoint() }
    )
  }
  stop(r, a) {
    const o = this.isDragging
    if ((this.cancel(), !o)) return
    const { velocity: l } = a
    this.startAnimation(l)
    const { onDragEnd: f } = this.getProps()
    f && Rn.update(() => f(r, a))
  }
  cancel() {
    this.isDragging = !1
    const { projection: r, animationState: a } = this.visualElement
    r && (r.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0)
    const { dragPropagation: o } = this.getProps()
    !o && this.openGlobalLock && (this.openGlobalLock(), (this.openGlobalLock = null)),
      a && a.setActive('whileDrag', !1)
  }
  updateAxis(r, a, o) {
    const { drag: l } = this.getProps()
    if (!o || !Sm(r, l, this.currentDirection)) return
    const f = this.getAxisMotionValue(r)
    let c = this.originPoint[r] + o[r]
    this.constraints && this.constraints[r] && (c = $Y(c, this.constraints[r], this.elastic[r])),
      f.set(c)
  }
  resolveConstraints() {
    const { dragConstraints: r, dragElastic: a } = this.getProps(),
      { layout: o } = this.visualElement.projection || {},
      l = this.constraints
    r && Hu(r)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : r && o
      ? (this.constraints = FY(o.layoutBox, r))
      : (this.constraints = !1),
      (this.elastic = UY(a)),
      l !== this.constraints &&
        o &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Ni((f) => {
          this.getAxisMotionValue(f) &&
            (this.constraints[f] = jY(o.layoutBox[f], this.constraints[f]))
        })
  }
  resolveRefConstraints() {
    const { dragConstraints: r, onMeasureDragConstraints: a } = this.getProps()
    if (!r || !Hu(r)) return !1
    const o = r.current
    mi(
      o !== null,
      "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."
    )
    const { projection: l } = this.visualElement
    if (!l || !l.layout) return !1
    const f = GY(o, l.root, this.visualElement.getTransformPagePoint())
    let c = NY(l.layout.layoutBox, f)
    if (a) {
      const p = a(VY(c))
      ;(this.hasMutatedConstraints = !!p), p && (c = xO(p))
    }
    return c
  }
  startAnimation(r) {
    const {
        drag: a,
        dragMomentum: o,
        dragElastic: l,
        dragTransition: f,
        dragSnapToOrigin: c,
        onDragTransitionEnd: p,
      } = this.getProps(),
      h = this.constraints || {},
      m = Ni((g) => {
        if (!Sm(g, a, this.currentDirection)) return
        let b = (h && h[g]) || {}
        c && (b = { min: 0, max: 0 })
        const C = l ? 200 : 1e6,
          w = l ? 40 : 1e7,
          k = {
            type: 'inertia',
            velocity: o ? r[g] : 0,
            bounceStiffness: C,
            bounceDamping: w,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...f,
            ...b,
          }
        return this.startAxisValueAnimation(g, k)
      })
    return Promise.all(m).then(p)
  }
  startAxisValueAnimation(r, a) {
    const o = this.getAxisMotionValue(r)
    return o.start(Qx(r, o, 0, a))
  }
  stopAnimation() {
    Ni((r) => this.getAxisMotionValue(r).stop())
  }
  getAxisMotionValue(r) {
    const a = '_drag' + r.toUpperCase(),
      o = this.visualElement.getProps(),
      l = o[a]
    return l || this.visualElement.getValue(r, (o.initial ? o.initial[r] : void 0) || 0)
  }
  snapToCursor(r) {
    Ni((a) => {
      const { drag: o } = this.getProps()
      if (!Sm(a, o, this.currentDirection)) return
      const { projection: l } = this.visualElement,
        f = this.getAxisMotionValue(a)
      if (l && l.layout) {
        const { min: c, max: p } = l.layout.layoutBox[a]
        f.set(r[a] - An(c, p, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: r, dragConstraints: a } = this.getProps(),
      { projection: o } = this.visualElement
    if (!Hu(a) || !o || !this.constraints) return
    this.stopAnimation()
    const l = { x: 0, y: 0 }
    Ni((c) => {
      const p = this.getAxisMotionValue(c)
      if (p) {
        const h = p.get()
        l[c] = BY({ min: h, max: h }, this.constraints[c])
      }
    })
    const { transformTemplate: f } = this.visualElement.getProps()
    ;(this.visualElement.current.style.transform = f ? f({}, '') : 'none'),
      o.root && o.root.updateScroll(),
      o.updateLayout(),
      this.resolveConstraints(),
      Ni((c) => {
        if (!Sm(c, r, null)) return
        const p = this.getAxisMotionValue(c),
          { min: h, max: m } = this.constraints[c]
        p.set(An(h, m, l[c]))
      })
  }
  addListeners() {
    if (!this.visualElement.current) return
    qY.set(this.visualElement, this)
    const r = this.visualElement.current,
      a = Mo(r, 'pointerdown', (h) => {
        const { drag: m, dragListener: g = !0 } = this.getProps()
        m && g && this.start(h)
      }),
      o = () => {
        const { dragConstraints: h } = this.getProps()
        Hu(h) && (this.constraints = this.resolveRefConstraints())
      },
      { projection: l } = this.visualElement,
      f = l.addEventListener('measure', o)
    l && !l.layout && (l.root && l.root.updateScroll(), l.updateLayout()), o()
    const c = Ao(window, 'resize', () => this.scalePositionWithinConstraints()),
      p = l.addEventListener('didUpdate', ({ delta: h, hasLayoutChanged: m }) => {
        this.isDragging &&
          m &&
          (Ni((g) => {
            const b = this.getAxisMotionValue(g)
            b && ((this.originPoint[g] += h[g].translate), b.set(b.get() + h[g].translate))
          }),
          this.visualElement.render())
      })
    return () => {
      c(), a(), f(), p && p()
    }
  }
  getProps() {
    const r = this.visualElement.getProps(),
      {
        drag: a = !1,
        dragDirectionLock: o = !1,
        dragPropagation: l = !1,
        dragConstraints: f = !1,
        dragElastic: c = qS,
        dragMomentum: p = !0,
      } = r
    return {
      ...r,
      drag: a,
      dragDirectionLock: o,
      dragPropagation: l,
      dragConstraints: f,
      dragElastic: c,
      dragMomentum: p,
    }
  }
}
function Sm(t, r, a) {
  return (r === !0 || r === t) && (a === null || a === t)
}
function XY(t, r = 10) {
  let a = null
  return Math.abs(t.y) > r ? (a = 'y') : Math.abs(t.x) > r && (a = 'x'), a
}
class QY extends Ls {
  constructor(r) {
    super(r),
      (this.removeGroupControls = vr),
      (this.removeListeners = vr),
      (this.controls = new KY(r))
  }
  mount() {
    const { dragControls: r } = this.node.getProps()
    r && (this.removeGroupControls = r.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || vr)
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners()
  }
}
const fk = (t) => (r, a) => {
  t && Rn.update(() => t(r, a))
}
class ZY extends Ls {
  constructor() {
    super(...arguments), (this.removePointerDownListener = vr)
  }
  onPointerDown(r) {
    this.session = new bO(r, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
    })
  }
  createPanHandlers() {
    const { onPanSessionStart: r, onPanStart: a, onPan: o, onPanEnd: l } = this.node.getProps()
    return {
      onSessionStart: fk(r),
      onStart: fk(a),
      onMove: o,
      onEnd: (f, c) => {
        delete this.session, l && Rn.update(() => l(f, c))
      },
    }
  }
  mount() {
    this.removePointerDownListener = Mo(this.node.current, 'pointerdown', (r) =>
      this.onPointerDown(r)
    )
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end()
  }
}
function JY() {
  const t = R.useContext(Kd)
  if (t === null) return [!0, null]
  const { isPresent: r, onExitComplete: a, register: o } = t,
    l = R.useId()
  return R.useEffect(() => o(l), []), !r && a ? [!1, () => a && a(l)] : [!0]
}
function eG() {
  return tG(R.useContext(Kd))
}
function tG(t) {
  return t === null ? !0 : t.isPresent
}
function dk(t, r) {
  return r.max === r.min ? 0 : (t / (r.max - r.min)) * 100
}
const ed = {
    correct: (t, r) => {
      if (!r.target) return t
      if (typeof t == 'string')
        if (Qe.test(t)) t = parseFloat(t)
        else return t
      const a = dk(t, r.target.x),
        o = dk(t, r.target.y)
      return `${a}% ${o}%`
    },
  },
  TO = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/
function nG(t) {
  const r = TO.exec(t)
  if (!r) return [,]
  const [, a, o] = r
  return [a, o]
}
const rG = 4
function QS(t, r, a = 1) {
  mi(
    a <= rG,
    `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`
  )
  const [o, l] = nG(t)
  if (!o) return
  const f = window.getComputedStyle(r).getPropertyValue(o)
  return f ? f.trim() : NS(l) ? QS(l, r, a + 1) : l
}
function aG(t, { ...r }, a) {
  const o = t.current
  if (!(o instanceof Element)) return { target: r, transitionEnd: a }
  a && (a = { ...a }),
    t.values.forEach((l) => {
      const f = l.get()
      if (!NS(f)) return
      const c = QS(f, o)
      c && l.set(c)
    })
  for (const l in r) {
    const f = r[l]
    if (!NS(f)) continue
    const c = QS(f, o)
    c && ((r[l] = c), a || (a = {}), a[l] === void 0 && (a[l] = f))
  }
  return { target: r, transitionEnd: a }
}
const pk = '_$css',
  iG = {
    correct: (t, { treeScale: r, projectionDelta: a }) => {
      const o = t,
        l = t.includes('var('),
        f = []
      l && (t = t.replace(TO, (w) => (f.push(w), pk)))
      const c = As.parse(t)
      if (c.length > 5) return o
      const p = As.createTransformer(t),
        h = typeof c[0] != 'number' ? 1 : 0,
        m = a.x.scale * r.x,
        g = a.y.scale * r.y
      ;(c[0 + h] /= m), (c[1 + h] /= g)
      const b = An(m, g, 0.5)
      typeof c[2 + h] == 'number' && (c[2 + h] /= b), typeof c[3 + h] == 'number' && (c[3 + h] /= b)
      let C = p(c)
      if (l) {
        let w = 0
        C = C.replace(pk, () => {
          const k = f[w]
          return w++, k
        })
      }
      return C
    },
  }
class oG extends ca.Component {
  componentDidMount() {
    const { visualElement: r, layoutGroup: a, switchLayoutGroup: o, layoutId: l } = this.props,
      { projection: f } = r
    f8(sG),
      f &&
        (a.group && a.group.add(f),
        o && o.register && l && o.register(f),
        f.root.didUpdate(),
        f.addEventListener('animationComplete', () => {
          this.safeToRemove()
        }),
        f.setOptions({ ...f.options, onExitComplete: () => this.safeToRemove() })),
      (hd.hasEverUpdated = !0)
  }
  getSnapshotBeforeUpdate(r) {
    const { layoutDependency: a, visualElement: o, drag: l, isPresent: f } = this.props,
      c = o.projection
    return (
      c &&
        ((c.isPresent = f),
        l || r.layoutDependency !== a || a === void 0 ? c.willUpdate() : this.safeToRemove(),
        r.isPresent !== f &&
          (f
            ? c.promote()
            : c.relegate() ||
              Rn.postRender(() => {
                const p = c.getStack()
                ;(!p || !p.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: r } = this.props.visualElement
    r && (r.root.didUpdate(), !r.currentAnimation && r.isLead() && this.safeToRemove())
  }
  componentWillUnmount() {
    const { visualElement: r, layoutGroup: a, switchLayoutGroup: o } = this.props,
      { projection: l } = r
    l &&
      (l.scheduleCheckAfterUnmount(),
      a && a.group && a.group.remove(l),
      o && o.deregister && o.deregister(l))
  }
  safeToRemove() {
    const { safeToRemove: r } = this.props
    r && r()
  }
  render() {
    return null
  }
}
function RO(t) {
  const [r, a] = JY(),
    o = R.useContext(Fx)
  return ca.createElement(oG, {
    ...t,
    layoutGroup: o,
    switchLayoutGroup: R.useContext(TA),
    isPresent: r,
    safeToRemove: a,
  })
}
const sG = {
    borderRadius: {
      ...ed,
      applyTo: [
        'borderTopLeftRadius',
        'borderTopRightRadius',
        'borderBottomLeftRadius',
        'borderBottomRightRadius',
      ],
    },
    borderTopLeftRadius: ed,
    borderTopRightRadius: ed,
    borderBottomLeftRadius: ed,
    borderBottomRightRadius: ed,
    boxShadow: iG,
  },
  _O = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
  lG = _O.length,
  hk = (t) => (typeof t == 'string' ? parseFloat(t) : t),
  mk = (t) => typeof t == 'number' || Qe.test(t)
function uG(t, r, a, o, l, f) {
  l
    ? ((t.opacity = An(0, a.opacity !== void 0 ? a.opacity : 1, cG(o))),
      (t.opacityExit = An(r.opacity !== void 0 ? r.opacity : 1, 0, fG(o))))
    : f &&
      (t.opacity = An(
        r.opacity !== void 0 ? r.opacity : 1,
        a.opacity !== void 0 ? a.opacity : 1,
        o
      ))
  for (let c = 0; c < lG; c++) {
    const p = `border${_O[c]}Radius`
    let h = vk(r, p),
      m = vk(a, p)
    if (h === void 0 && m === void 0) continue
    h || (h = 0),
      m || (m = 0),
      h === 0 || m === 0 || mk(h) === mk(m)
        ? ((t[p] = Math.max(An(hk(h), hk(m), o), 0)), (Yi.test(m) || Yi.test(h)) && (t[p] += '%'))
        : (t[p] = m)
  }
  ;(r.rotate || a.rotate) && (t.rotate = An(r.rotate || 0, a.rotate || 0, o))
}
function vk(t, r) {
  return t[r] !== void 0 ? t[r] : t.borderRadius
}
const cG = kO(0, 0.5, Yx),
  fG = kO(0.5, 0.95, vr)
function kO(t, r, a) {
  return (o) => (o < t ? 0 : o > r ? 1 : a(jd(t, r, o)))
}
function gk(t, r) {
  ;(t.min = r.min), (t.max = r.max)
}
function Ha(t, r) {
  gk(t.x, r.x), gk(t.y, r.y)
}
function yk(t, r, a, o, l) {
  return (t -= r), (t = nv(t, 1 / a, o)), l !== void 0 && (t = nv(t, 1 / l, o)), t
}
function dG(t, r = 0, a = 1, o = 0.5, l, f = t, c = t) {
  if (
    (Yi.test(r) && ((r = parseFloat(r)), (r = An(c.min, c.max, r / 100) - c.min)),
    typeof r != 'number')
  )
    return
  let p = An(f.min, f.max, o)
  t === f && (p -= r), (t.min = yk(t.min, r, a, p, l)), (t.max = yk(t.max, r, a, p, l))
}
function bk(t, r, [a, o, l], f, c) {
  dG(t, r[a], r[o], r[l], r.scale, f, c)
}
const pG = ['x', 'scaleX', 'originX'],
  hG = ['y', 'scaleY', 'originY']
function Sk(t, r, a, o) {
  bk(t.x, r, pG, a ? a.x : void 0, o ? o.x : void 0),
    bk(t.y, r, hG, a ? a.y : void 0, o ? o.y : void 0)
}
function xk(t) {
  return t.translate === 0 && t.scale === 1
}
function DO(t) {
  return xk(t.x) && xk(t.y)
}
function ZS(t, r) {
  return t.x.min === r.x.min && t.x.max === r.x.max && t.y.min === r.y.min && t.y.max === r.y.max
}
function Ck(t) {
  return Pa(t.x) / Pa(t.y)
}
class mG {
  constructor() {
    this.members = []
  }
  add(r) {
    Zx(this.members, r), r.scheduleRender()
  }
  remove(r) {
    if ((Jx(this.members, r), r === this.prevLead && (this.prevLead = void 0), r === this.lead)) {
      const a = this.members[this.members.length - 1]
      a && this.promote(a)
    }
  }
  relegate(r) {
    const a = this.members.findIndex((l) => r === l)
    if (a === 0) return !1
    let o
    for (let l = a; l >= 0; l--) {
      const f = this.members[l]
      if (f.isPresent !== !1) {
        o = f
        break
      }
    }
    return o ? (this.promote(o), !0) : !1
  }
  promote(r, a) {
    const o = this.lead
    if (r !== o && ((this.prevLead = o), (this.lead = r), r.show(), o)) {
      o.instance && o.scheduleRender(),
        r.scheduleRender(),
        (r.resumeFrom = o),
        a && (r.resumeFrom.preserveOpacity = !0),
        o.snapshot &&
          ((r.snapshot = o.snapshot),
          (r.snapshot.latestValues = o.animationValues || o.latestValues)),
        r.root && r.root.isUpdating && (r.isLayoutDirty = !0)
      const { crossfade: l } = r.options
      l === !1 && o.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach((r) => {
      const { options: a, resumingFrom: o } = r
      a.onExitComplete && a.onExitComplete(),
        o && o.options.onExitComplete && o.options.onExitComplete()
    })
  }
  scheduleRender() {
    this.members.forEach((r) => {
      r.instance && r.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function wk(t, r, a) {
  let o = ''
  const l = t.x.translate / r.x,
    f = t.y.translate / r.y
  if (
    ((l || f) && (o = `translate3d(${l}px, ${f}px, 0) `),
    (r.x !== 1 || r.y !== 1) && (o += `scale(${1 / r.x}, ${1 / r.y}) `),
    a)
  ) {
    const { rotate: h, rotateX: m, rotateY: g } = a
    h && (o += `rotate(${h}deg) `), m && (o += `rotateX(${m}deg) `), g && (o += `rotateY(${g}deg) `)
  }
  const c = t.x.scale * r.x,
    p = t.y.scale * r.y
  return (c !== 1 || p !== 1) && (o += `scale(${c}, ${p})`), o || 'none'
}
const vG = (t, r) => t.depth - r.depth
class gG {
  constructor() {
    ;(this.children = []), (this.isDirty = !1)
  }
  add(r) {
    Zx(this.children, r), (this.isDirty = !0)
  }
  remove(r) {
    Jx(this.children, r), (this.isDirty = !0)
  }
  forEach(r) {
    this.isDirty && this.children.sort(vG), (this.isDirty = !1), this.children.forEach(r)
  }
}
function yG(t, r) {
  const a = performance.now(),
    o = ({ timestamp: l }) => {
      const f = l - a
      f >= r && (Ds.read(o), t(f - r))
    }
  return Rn.read(o, !0), () => Ds.read(o)
}
function bG(t) {
  window.MotionDebug && window.MotionDebug.record(t)
}
function SG(t) {
  return t instanceof SVGElement && t.tagName !== 'svg'
}
function xG(t, r, a) {
  const o = ha(t) ? t : ic(t)
  return o.start(Qx('', o, r, a)), o.animation
}
const Ek = ['', 'X', 'Y', 'Z'],
  Tk = 1e3
let CG = 0
const Tl = {
  type: 'projectionFrame',
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
}
function AO({
  attachResizeListener: t,
  defaultParent: r,
  measureScroll: a,
  checkIsScrollRoot: o,
  resetTransform: l,
}) {
  return class {
    constructor(c, p = {}, h = r == null ? void 0 : r()) {
      ;(this.id = CG++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.potentialNodes = new Map()),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;(Tl.totalNodes = Tl.resolvedTargetDeltas = Tl.recalculatedProjection = 0),
            this.nodes.forEach(TG),
            this.nodes.forEach(DG),
            this.nodes.forEach(AG),
            this.nodes.forEach(RG),
            bG(Tl)
        }),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.elementId = c),
        (this.latestValues = p),
        (this.root = h ? h.root || h : this),
        (this.path = h ? [...h.path, h] : []),
        (this.parent = h),
        (this.depth = h ? h.depth + 1 : 0),
        c && this.root.registerPotentialNode(c, this)
      for (let m = 0; m < this.path.length; m++) this.path[m].shouldResetTransform = !0
      this.root === this && (this.nodes = new gG())
    }
    addEventListener(c, p) {
      return (
        this.eventHandlers.has(c) || this.eventHandlers.set(c, new eC()),
        this.eventHandlers.get(c).add(p)
      )
    }
    notifyListeners(c, ...p) {
      const h = this.eventHandlers.get(c)
      h && h.notify(...p)
    }
    hasListeners(c) {
      return this.eventHandlers.has(c)
    }
    registerPotentialNode(c, p) {
      this.potentialNodes.set(c, p)
    }
    mount(c, p = !1) {
      if (this.instance) return
      ;(this.isSVG = SG(c)), (this.instance = c)
      const { layoutId: h, layout: m, visualElement: g } = this.options
      if (
        (g && !g.current && g.mount(c),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.elementId && this.root.potentialNodes.delete(this.elementId),
        p && (m || h) && (this.isLayoutDirty = !0),
        t)
      ) {
        let b
        const C = () => (this.root.updateBlockedByResize = !1)
        t(c, () => {
          ;(this.root.updateBlockedByResize = !0),
            b && b(),
            (b = yG(C, 250)),
            hd.hasAnimatedSinceResize && ((hd.hasAnimatedSinceResize = !1), this.nodes.forEach(_k))
        })
      }
      h && this.root.registerSharedNode(h, this),
        this.options.animate !== !1 &&
          g &&
          (h || m) &&
          this.addEventListener(
            'didUpdate',
            ({ delta: b, hasLayoutChanged: C, hasRelativeTargetChanged: w, layout: k }) => {
              if (this.isTreeAnimationBlocked()) {
                ;(this.target = void 0), (this.relativeTarget = void 0)
                return
              }
              const D = this.options.transition || g.getDefaultTransition() || zG,
                { onLayoutAnimationStart: E, onLayoutAnimationComplete: M } = g.getProps(),
                z = !this.targetLayout || !ZS(this.targetLayout, k) || w,
                P = !C && w
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                P ||
                (C && (z || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(b, P)
                const B = { ...mO(D, 'layout'), onPlay: E, onComplete: M }
                ;(g.shouldReduceMotion || this.options.layoutRoot) &&
                  ((B.delay = 0), (B.type = !1)),
                  this.startAnimation(B)
              } else
                !C && this.animationProgress === 0 && _k(this),
                  this.isLead() && this.options.onExitComplete && this.options.onExitComplete()
              this.targetLayout = k
            }
          )
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this)
      const c = this.getStack()
      c && c.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Ds.preRender(this.updateProjection)
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || !1
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0), this.nodes && this.nodes.forEach(OG), this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: c } = this.options
      return c && c.getProps().transformTemplate
    }
    willUpdate(c = !0) {
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if ((!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)) return
      this.isLayoutDirty = !0
      for (let g = 0; g < this.path.length; g++) {
        const b = this.path[g]
        ;(b.shouldResetTransform = !0),
          b.updateScroll('snapshot'),
          b.options.layoutRoot && b.willUpdate(!1)
      }
      const { layoutId: p, layout: h } = this.options
      if (p === void 0 && !h) return
      const m = this.getTransformTemplate()
      ;(this.prevTransformTemplateValue = m ? m(this.latestValues, '') : void 0),
        this.updateSnapshot(),
        c && this.notifyListeners('willUpdate')
    }
    didUpdate() {
      if (this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Rk)
        return
      }
      this.isUpdating &&
        ((this.isUpdating = !1),
        this.potentialNodes.size && (this.potentialNodes.forEach($G), this.potentialNodes.clear()),
        this.nodes.forEach(kG),
        this.nodes.forEach(wG),
        this.nodes.forEach(EG),
        this.clearAllSnapshots(),
        nS.update(),
        nS.preRender(),
        nS.render())
    }
    clearAllSnapshots() {
      this.nodes.forEach(_G), this.sharedNodes.forEach(MG)
    }
    scheduleUpdateProjection() {
      Rn.preRender(this.updateProjection, !1, !0)
    }
    scheduleCheckAfterUnmount() {
      Rn.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure())
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let h = 0; h < this.path.length; h++) this.path[h].updateScroll()
      const c = this.layout
      ;(this.layout = this.measure(!1)),
        (this.layoutCorrected = Yn()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners('measure', this.layout.layoutBox)
      const { visualElement: p } = this.options
      p && p.notify('LayoutMeasure', this.layout.layoutBox, c ? c.layoutBox : void 0)
    }
    updateScroll(c = 'measure') {
      let p = !!(this.options.layoutScroll && this.instance)
      this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === c &&
        (p = !1),
        p &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: c,
            isRoot: o(this.instance),
            offset: a(this.instance),
          })
    }
    resetTransform() {
      if (!l) return
      const c = this.isLayoutDirty || this.shouldResetTransform,
        p = this.projectionDelta && !DO(this.projectionDelta),
        h = this.getTransformTemplate(),
        m = h ? h(this.latestValues, '') : void 0,
        g = m !== this.prevTransformTemplateValue
      c &&
        (p || El(this.latestValues) || g) &&
        (l(this.instance, m), (this.shouldResetTransform = !1), this.scheduleRender())
    }
    measure(c = !0) {
      const p = this.measurePageBox()
      let h = this.removeElementScroll(p)
      return (
        c && (h = this.removeTransform(h)),
        FG(h),
        {
          animationId: this.root.animationId,
          measuredBox: p,
          layoutBox: h,
          latestValues: {},
          source: this.id,
        }
      )
    }
    measurePageBox() {
      const { visualElement: c } = this.options
      if (!c) return Yn()
      const p = c.measureViewportBox(),
        { scroll: h } = this.root
      return h && (Cs(p.x, h.offset.x), Cs(p.y, h.offset.y)), p
    }
    removeElementScroll(c) {
      const p = Yn()
      Ha(p, c)
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h],
          { scroll: g, options: b } = m
        if (m !== this.root && g && b.layoutScroll) {
          if (g.isRoot) {
            Ha(p, c)
            const { scroll: C } = this.root
            C && (Cs(p.x, -C.offset.x), Cs(p.y, -C.offset.y))
          }
          Cs(p.x, g.offset.x), Cs(p.y, g.offset.y)
        }
      }
      return p
    }
    applyTransform(c, p = !1) {
      const h = Yn()
      Ha(h, c)
      for (let m = 0; m < this.path.length; m++) {
        const g = this.path[m]
        !p &&
          g.options.layoutScroll &&
          g.scroll &&
          g !== g.root &&
          Yu(h, { x: -g.scroll.offset.x, y: -g.scroll.offset.y }),
          El(g.latestValues) && Yu(h, g.latestValues)
      }
      return El(this.latestValues) && Yu(h, this.latestValues), h
    }
    removeTransform(c) {
      const p = Yn()
      Ha(p, c)
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h]
        if (!m.instance || !El(m.latestValues)) continue
        KS(m.latestValues) && m.updateSnapshot()
        const g = Yn(),
          b = m.measurePageBox()
        Ha(g, b), Sk(p, m.latestValues, m.snapshot ? m.snapshot.layoutBox : void 0, g)
      }
      return El(this.latestValues) && Sk(p, this.latestValues), p
    }
    setTargetDelta(c) {
      ;(this.targetDelta = c), this.root.scheduleUpdateProjection(), (this.isProjectionDirty = !0)
    }
    setOptions(c) {
      this.options = { ...this.options, ...c, crossfade: c.crossfade !== void 0 ? c.crossfade : !0 }
    }
    clearMeasurements() {
      ;(this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1)
    }
    resolveTargetDelta(c = !1) {
      var p
      const h = this.getLead()
      this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty),
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty)
      const m = !!this.resumingFrom || this !== h
      if (
        !(
          c ||
          (m && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((p = this.parent) === null || p === void 0) && p.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        )
      )
        return
      const { layout: b, layoutId: C } = this.options
      if (!(!this.layout || !(b || C))) {
        if (
          ((this.resolvedRelativeTargetAt = Fr.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const w = this.getClosestProjectingParent()
          w && w.layout
            ? ((this.relativeParent = w),
              (this.relativeTarget = Yn()),
              (this.relativeTargetOrigin = Yn()),
              yd(this.relativeTargetOrigin, this.layout.layoutBox, w.layout.layoutBox),
              Ha(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target || ((this.target = Yn()), (this.targetWithTransforms = Yn())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.relativeParent.resolvedRelativeTargetAt !== Fr.timestamp &&
                  this.relativeParent.resolveTargetDelta(!0),
                zY(this.target, this.relativeTarget, this.relativeParent.target))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : Ha(this.target, this.layout.layoutBox),
                wO(this.target, this.targetDelta))
              : Ha(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1
            const w = this.getClosestProjectingParent()
            w && !!w.resumingFrom == !!this.resumingFrom && !w.options.layoutScroll && w.target
              ? ((this.relativeParent = w),
                (this.relativeTarget = Yn()),
                (this.relativeTargetOrigin = Yn()),
                yd(this.relativeTargetOrigin, this.target, w.target),
                Ha(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0)
          }
          Tl.resolvedTargetDeltas++
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || KS(this.parent.latestValues) || CO(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
    }
    calcProjection() {
      var c
      const p = this.getLead(),
        h = !!this.resumingFrom || this !== p
      let m = !0
      if (
        ((this.isProjectionDirty ||
          (!((c = this.parent) === null || c === void 0) && c.isProjectionDirty)) &&
          (m = !1),
        h && (this.isSharedProjectionDirty || this.isTransformDirty) && (m = !1),
        this.resolvedRelativeTargetAt === Fr.timestamp && (m = !1),
        m)
      )
        return
      const { layout: g, layoutId: b } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(g || b))
      )
        return
      Ha(this.layoutCorrected, this.layout.layoutBox),
        HY(this.layoutCorrected, this.treeScale, this.path, h)
      const { target: C } = p
      if (!C) return
      this.projectionDelta ||
        ((this.projectionDelta = bd()), (this.projectionDeltaWithTransform = bd()))
      const w = this.treeScale.x,
        k = this.treeScale.y,
        D = this.projectionTransform
      gd(this.projectionDelta, this.layoutCorrected, C, this.latestValues),
        (this.projectionTransform = wk(this.projectionDelta, this.treeScale)),
        (this.projectionTransform !== D || this.treeScale.x !== w || this.treeScale.y !== k) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners('projectionUpdate', C)),
        Tl.recalculatedProjection++
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(c = !0) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), c)) {
        const p = this.getStack()
        p && p.scheduleRender()
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
    }
    setAnimationOrigin(c, p = !1) {
      const h = this.snapshot,
        m = h ? h.latestValues : {},
        g = { ...this.latestValues },
        b = bd()
      ;(!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !p)
      const C = Yn(),
        w = h ? h.source : void 0,
        k = this.layout ? this.layout.source : void 0,
        D = w !== k,
        E = this.getStack(),
        M = !E || E.members.length <= 1,
        z = !!(D && !M && this.options.crossfade === !0 && !this.path.some(LG))
      this.animationProgress = 0
      let P
      ;(this.mixTargetDelta = (B) => {
        const j = B / 1e3
        kk(b.x, c.x, j),
          kk(b.y, c.y, j),
          this.setTargetDelta(b),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (yd(C, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            PG(this.relativeTarget, this.relativeTargetOrigin, C, j),
            P && ZS(this.relativeTarget, P) && (this.isProjectionDirty = !1),
            P || (P = Yn()),
            Ha(P, this.relativeTarget)),
          D && ((this.animationValues = g), uG(g, m, this.latestValues, j, z, M)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = j)
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
    }
    startAnimation(c) {
      this.notifyListeners('animationStart'),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (Ds.update(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = Rn.update(() => {
          ;(hd.hasAnimatedSinceResize = !0),
            (this.currentAnimation = xG(0, Tk, {
              ...c,
              onUpdate: (p) => {
                this.mixTargetDelta(p), c.onUpdate && c.onUpdate(p)
              },
              onComplete: () => {
                c.onComplete && c.onComplete(), this.completeAnimation()
              },
            })),
            this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0)
        }))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0))
      const c = this.getStack()
      c && c.exitAnimationComplete(),
        (this.resumingFrom = this.currentAnimation = this.animationValues = void 0),
        this.notifyListeners('animationComplete')
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(Tk), this.currentAnimation.stop()),
        this.completeAnimation()
    }
    applyTransformsToTarget() {
      const c = this.getLead()
      let { targetWithTransforms: p, target: h, layout: m, latestValues: g } = c
      if (!(!p || !h || !m)) {
        if (
          this !== c &&
          this.layout &&
          m &&
          OO(this.options.animationType, this.layout.layoutBox, m.layoutBox)
        ) {
          h = this.target || Yn()
          const b = Pa(this.layout.layoutBox.x)
          ;(h.x.min = c.target.x.min), (h.x.max = h.x.min + b)
          const C = Pa(this.layout.layoutBox.y)
          ;(h.y.min = c.target.y.min), (h.y.max = h.y.min + C)
        }
        Ha(p, h), Yu(p, g), gd(this.projectionDeltaWithTransform, this.layoutCorrected, p, g)
      }
    }
    registerSharedNode(c, p) {
      this.sharedNodes.has(c) || this.sharedNodes.set(c, new mG()), this.sharedNodes.get(c).add(p)
      const m = p.options.initialPromotionConfig
      p.promote({
        transition: m ? m.transition : void 0,
        preserveFollowOpacity:
          m && m.shouldPreserveFollowOpacity ? m.shouldPreserveFollowOpacity(p) : void 0,
      })
    }
    isLead() {
      const c = this.getStack()
      return c ? c.lead === this : !0
    }
    getLead() {
      var c
      const { layoutId: p } = this.options
      return p ? ((c = this.getStack()) === null || c === void 0 ? void 0 : c.lead) || this : this
    }
    getPrevLead() {
      var c
      const { layoutId: p } = this.options
      return p ? ((c = this.getStack()) === null || c === void 0 ? void 0 : c.prevLead) : void 0
    }
    getStack() {
      const { layoutId: c } = this.options
      if (c) return this.root.sharedNodes.get(c)
    }
    promote({ needsReset: c, transition: p, preserveFollowOpacity: h } = {}) {
      const m = this.getStack()
      m && m.promote(this, h),
        c && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        p && this.setOptions({ transition: p })
    }
    relegate() {
      const c = this.getStack()
      return c ? c.relegate(this) : !1
    }
    resetRotation() {
      const { visualElement: c } = this.options
      if (!c) return
      let p = !1
      const { latestValues: h } = c
      if (((h.rotate || h.rotateX || h.rotateY || h.rotateZ) && (p = !0), !p)) return
      const m = {}
      for (let g = 0; g < Ek.length; g++) {
        const b = 'rotate' + Ek[g]
        h[b] && ((m[b] = h[b]), c.setStaticValue(b, 0))
      }
      c.render()
      for (const g in m) c.setStaticValue(g, m[g])
      c.scheduleRender()
    }
    getProjectionStyles(c = {}) {
      var p, h
      const m = {}
      if (!this.instance || this.isSVG) return m
      if (this.isVisible) m.visibility = ''
      else return { visibility: 'hidden' }
      const g = this.getTransformTemplate()
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (m.opacity = ''),
          (m.pointerEvents = Lm(c.pointerEvents) || ''),
          (m.transform = g ? g(this.latestValues, '') : 'none'),
          m
        )
      const b = this.getLead()
      if (!this.projectionDelta || !this.layout || !b.target) {
        const D = {}
        return (
          this.options.layoutId &&
            ((D.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1),
            (D.pointerEvents = Lm(c.pointerEvents) || '')),
          this.hasProjected &&
            !El(this.latestValues) &&
            ((D.transform = g ? g({}, '') : 'none'), (this.hasProjected = !1)),
          D
        )
      }
      const C = b.animationValues || b.latestValues
      this.applyTransformsToTarget(),
        (m.transform = wk(this.projectionDeltaWithTransform, this.treeScale, C)),
        g && (m.transform = g(C, m.transform))
      const { x: w, y: k } = this.projectionDelta
      ;(m.transformOrigin = `${w.origin * 100}% ${k.origin * 100}% 0`),
        b.animationValues
          ? (m.opacity =
              b === this
                ? (h = (p = C.opacity) !== null && p !== void 0 ? p : this.latestValues.opacity) !==
                    null && h !== void 0
                  ? h
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : C.opacityExit)
          : (m.opacity =
              b === this
                ? C.opacity !== void 0
                  ? C.opacity
                  : ''
                : C.opacityExit !== void 0
                ? C.opacityExit
                : 0)
      for (const D in Km) {
        if (C[D] === void 0) continue
        const { correct: E, applyTo: M } = Km[D],
          z = m.transform === 'none' ? C[D] : E(C[D], b)
        if (M) {
          const P = M.length
          for (let B = 0; B < P; B++) m[M[B]] = z
        } else m[D] = z
      }
      return (
        this.options.layoutId &&
          (m.pointerEvents = b === this ? Lm(c.pointerEvents) || '' : 'none'),
        m
      )
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      this.root.nodes.forEach((c) => {
        var p
        return (p = c.currentAnimation) === null || p === void 0 ? void 0 : p.stop()
      }),
        this.root.nodes.forEach(Rk),
        this.root.sharedNodes.clear()
    }
  }
}
function wG(t) {
  t.updateLayout()
}
function EG(t) {
  var r
  const a = ((r = t.resumeFrom) === null || r === void 0 ? void 0 : r.snapshot) || t.snapshot
  if (t.isLead() && t.layout && a && t.hasListeners('didUpdate')) {
    const { layoutBox: o, measuredBox: l } = t.layout,
      { animationType: f } = t.options,
      c = a.source !== t.layout.source
    f === 'size'
      ? Ni((b) => {
          const C = c ? a.measuredBox[b] : a.layoutBox[b],
            w = Pa(C)
          ;(C.min = o[b].min), (C.max = C.min + w)
        })
      : OO(f, a.layoutBox, o) &&
        Ni((b) => {
          const C = c ? a.measuredBox[b] : a.layoutBox[b],
            w = Pa(o[b])
          ;(C.max = C.min + w),
            t.relativeTarget &&
              !t.currentAnimation &&
              ((t.isProjectionDirty = !0), (t.relativeTarget[b].max = t.relativeTarget[b].min + w))
        })
    const p = bd()
    gd(p, o, a.layoutBox)
    const h = bd()
    c ? gd(h, t.applyTransform(l, !0), a.measuredBox) : gd(h, o, a.layoutBox)
    const m = !DO(p)
    let g = !1
    if (!t.resumeFrom) {
      const b = t.getClosestProjectingParent()
      if (b && !b.resumeFrom) {
        const { snapshot: C, layout: w } = b
        if (C && w) {
          const k = Yn()
          yd(k, a.layoutBox, C.layoutBox)
          const D = Yn()
          yd(D, o, w.layoutBox),
            ZS(k, D) || (g = !0),
            b.options.layoutRoot &&
              ((t.relativeTarget = D), (t.relativeTargetOrigin = k), (t.relativeParent = b))
        }
      }
    }
    t.notifyListeners('didUpdate', {
      layout: o,
      snapshot: a,
      delta: h,
      layoutDelta: p,
      hasLayoutChanged: m,
      hasRelativeTargetChanged: g,
    })
  } else if (t.isLead()) {
    const { onExitComplete: o } = t.options
    o && o()
  }
  t.options.transition = void 0
}
function TG(t) {
  Tl.totalNodes++,
    t.parent &&
      (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty),
      t.isSharedProjectionDirty ||
        (t.isSharedProjectionDirty = !!(
          t.isProjectionDirty ||
          t.parent.isProjectionDirty ||
          t.parent.isSharedProjectionDirty
        )),
      t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
}
function RG(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
}
function _G(t) {
  t.clearSnapshot()
}
function Rk(t) {
  t.clearMeasurements()
}
function kG(t) {
  const { visualElement: r } = t.options
  r && r.getProps().onBeforeLayoutMeasure && r.notify('BeforeLayoutMeasure'), t.resetTransform()
}
function _k(t) {
  t.finishAnimation(), (t.targetDelta = t.relativeTarget = t.target = void 0)
}
function DG(t) {
  t.resolveTargetDelta()
}
function AG(t) {
  t.calcProjection()
}
function OG(t) {
  t.resetRotation()
}
function MG(t) {
  t.removeLeadSnapshot()
}
function kk(t, r, a) {
  ;(t.translate = An(r.translate, 0, a)),
    (t.scale = An(r.scale, 1, a)),
    (t.origin = r.origin),
    (t.originPoint = r.originPoint)
}
function Dk(t, r, a, o) {
  ;(t.min = An(r.min, a.min, o)), (t.max = An(r.max, a.max, o))
}
function PG(t, r, a, o) {
  Dk(t.x, r.x, a.x, o), Dk(t.y, r.y, a.y, o)
}
function LG(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0
}
const zG = { duration: 0.45, ease: [0.4, 0, 0.1, 1] }
function $G(t, r) {
  let a = t.root
  for (let f = t.path.length - 1; f >= 0; f--)
    if (t.path[f].instance) {
      a = t.path[f]
      break
    }
  const l = (a && a !== t.root ? a.instance : document).querySelector(`[data-projection-id="${r}"]`)
  l && t.mount(l, !0)
}
function Ak(t) {
  ;(t.min = Math.round(t.min)), (t.max = Math.round(t.max))
}
function FG(t) {
  Ak(t.x), Ak(t.y)
}
function OO(t, r, a) {
  return t === 'position' || (t === 'preserve-aspect' && !GS(Ck(r), Ck(a), 0.2))
}
const NG = AO({
    attachResizeListener: (t, r) => Ao(t, 'resize', r),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  pS = { current: void 0 },
  MO = AO({
    measureScroll: (t) => ({ x: t.scrollLeft, y: t.scrollTop }),
    defaultParent: () => {
      if (!pS.current) {
        const t = new NG(0, {})
        t.mount(window), t.setOptions({ layoutScroll: !0 }), (pS.current = t)
      }
      return pS.current
    },
    resetTransform: (t, r) => {
      t.style.transform = r !== void 0 ? r : 'none'
    },
    checkIsScrollRoot: (t) => window.getComputedStyle(t).position === 'fixed',
  }),
  BG = { pan: { Feature: ZY }, drag: { Feature: QY, ProjectionNode: MO, MeasureLayout: RO } },
  jG = new Set(['width', 'height', 'top', 'left', 'right', 'bottom', 'x', 'y']),
  PO = (t) => jG.has(t),
  UG = (t) => Object.keys(t).some(PO),
  xm = (t) => t === Nl || t === Qe,
  Ok = (t, r) => parseFloat(t.split(', ')[r]),
  Mk =
    (t, r) =>
    (a, { transform: o }) => {
      if (o === 'none' || !o) return 0
      const l = o.match(/^matrix3d\((.+)\)$/)
      if (l) return Ok(l[1], r)
      {
        const f = o.match(/^matrix\((.+)\)$/)
        return f ? Ok(f[1], t) : 0
      }
    },
  VG = new Set(['x', 'y', 'z']),
  IG = Tv.filter((t) => !VG.has(t))
function HG(t) {
  const r = []
  return (
    IG.forEach((a) => {
      const o = t.getValue(a)
      o !== void 0 && (r.push([a, o.get()]), o.set(a.startsWith('scale') ? 1 : 0))
    }),
    r.length && t.render(),
    r
  )
}
const Pk = {
    width: ({ x: t }, { paddingLeft: r = '0', paddingRight: a = '0' }) =>
      t.max - t.min - parseFloat(r) - parseFloat(a),
    height: ({ y: t }, { paddingTop: r = '0', paddingBottom: a = '0' }) =>
      t.max - t.min - parseFloat(r) - parseFloat(a),
    top: (t, { top: r }) => parseFloat(r),
    left: (t, { left: r }) => parseFloat(r),
    bottom: ({ y: t }, { top: r }) => parseFloat(r) + (t.max - t.min),
    right: ({ x: t }, { left: r }) => parseFloat(r) + (t.max - t.min),
    x: Mk(4, 13),
    y: Mk(5, 14),
  },
  WG = (t, r, a) => {
    const o = r.measureViewportBox(),
      l = r.current,
      f = getComputedStyle(l),
      { display: c } = f,
      p = {}
    c === 'none' && r.setStaticValue('display', t.display || 'block'),
      a.forEach((m) => {
        p[m] = Pk[m](o, f)
      }),
      r.render()
    const h = r.measureViewportBox()
    return (
      a.forEach((m) => {
        const g = r.getValue(m)
        g && g.jump(p[m]), (t[m] = Pk[m](h, f))
      }),
      t
    )
  },
  YG = (t, r, a = {}, o = {}) => {
    ;(r = { ...r }), (o = { ...o })
    const l = Object.keys(r).filter(PO)
    let f = [],
      c = !1
    const p = []
    if (
      (l.forEach((h) => {
        const m = t.getValue(h)
        if (!t.hasValue(h)) return
        let g = a[h],
          b = Jf(g)
        const C = r[h]
        let w
        if (Qm(C)) {
          const k = C.length,
            D = C[0] === null ? 1 : 0
          ;(g = C[D]), (b = Jf(g))
          for (let E = D; E < k; E++)
            w
              ? mi(Jf(C[E]) === w, 'All keyframes must be of the same type')
              : ((w = Jf(C[E])),
                mi(
                  w === b || (xm(b) && xm(w)),
                  'Keyframes must be of the same dimension as the current value'
                ))
        } else w = Jf(C)
        if (b !== w)
          if (xm(b) && xm(w)) {
            const k = m.get()
            typeof k == 'string' && m.set(parseFloat(k)),
              typeof C == 'string'
                ? (r[h] = parseFloat(C))
                : Array.isArray(C) && w === Qe && (r[h] = C.map(parseFloat))
          } else
            b != null && b.transform && w != null && w.transform && (g === 0 || C === 0)
              ? g === 0
                ? m.set(w.transform(g))
                : (r[h] = b.transform(C))
              : (c || ((f = HG(t)), (c = !0)),
                p.push(h),
                (o[h] = o[h] !== void 0 ? o[h] : r[h]),
                m.jump(C))
      }),
      p.length)
    ) {
      const h = p.indexOf('height') >= 0 ? window.pageYOffset : null,
        m = WG(r, t, p)
      return (
        f.length &&
          f.forEach(([g, b]) => {
            t.getValue(g).set(b)
          }),
        t.render(),
        Cv && h !== null && window.scrollTo({ top: h }),
        { target: m, transitionEnd: o }
      )
    } else return { target: r, transitionEnd: o }
  }
function GG(t, r, a, o) {
  return UG(r) ? YG(t, r, a, o) : { target: r, transitionEnd: o }
}
const qG = (t, r, a, o) => {
    const l = aG(t, r, o)
    return (r = l.target), (o = l.transitionEnd), GG(t, r, a, o)
  },
  JS = { current: null },
  LO = { current: !1 }
function KG() {
  if (((LO.current = !0), !!Cv))
    if (window.matchMedia) {
      const t = window.matchMedia('(prefers-reduced-motion)'),
        r = () => (JS.current = t.matches)
      t.addListener(r), r()
    } else JS.current = !1
}
function XG(t, r, a) {
  const { willChange: o } = r
  for (const l in r) {
    const f = r[l],
      c = a[l]
    if (ha(f))
      t.addValue(l, f),
        tv(o) && o.add(l),
        tC(
          f.version === '10.10.0',
          `Attempting to mix Framer Motion versions ${f.version} with 10.10.0 may not work as expected.`
        )
    else if (ha(c)) t.addValue(l, ic(f, { owner: t })), tv(o) && o.remove(l)
    else if (c !== f)
      if (t.hasValue(l)) {
        const p = t.getValue(l)
        !p.hasAnimated && p.set(f)
      } else {
        const p = t.getStaticValue(l)
        t.addValue(l, ic(p !== void 0 ? p : f, { owner: t }))
      }
  }
  for (const l in a) r[l] === void 0 && t.removeValue(l)
  return r
}
const Lk = new WeakMap(),
  zO = Object.keys(Fd),
  QG = zO.length,
  zk = [
    'AnimationStart',
    'AnimationComplete',
    'Update',
    'BeforeLayoutMeasure',
    'LayoutMeasure',
    'LayoutAnimationStart',
    'LayoutAnimationComplete',
  ],
  ZG = zx.length
class JG {
  constructor(
    { parent: r, props: a, presenceContext: o, reducedMotionConfig: l, visualState: f },
    c = {}
  ) {
    ;(this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify('Update', this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
      }),
      (this.scheduleRender = () => Rn.render(this.render, !1, !0))
    const { latestValues: p, renderState: h } = f
    ;(this.latestValues = p),
      (this.baseTarget = { ...p }),
      (this.initialValues = a.initial ? { ...p } : {}),
      (this.renderState = h),
      (this.parent = r),
      (this.props = a),
      (this.presenceContext = o),
      (this.depth = r ? r.depth + 1 : 0),
      (this.reducedMotionConfig = l),
      (this.options = c),
      (this.isControllingVariants = Ev(a)),
      (this.isVariantNode = EA(a)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(r && r.current))
    const { willChange: m, ...g } = this.scrapeMotionValuesFromProps(a, {})
    for (const b in g) {
      const C = g[b]
      p[b] !== void 0 && ha(C) && (C.set(p[b], !1), tv(m) && m.add(b))
    }
  }
  scrapeMotionValuesFromProps(r, a) {
    return {}
  }
  mount(r) {
    ;(this.current = r),
      Lk.set(r, this),
      this.projection && this.projection.mount(r),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((a, o) => this.bindToMotionValue(o, a)),
      LO.current || KG(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === 'never'
          ? !1
          : this.reducedMotionConfig === 'always'
          ? !0
          : JS.current),
      tC(
        this.shouldReduceMotion !== !0,
        'You have Reduced Motion enabled on your device. Animations may not appear as expected.'
      ),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext)
  }
  unmount() {
    Lk.delete(this.current),
      this.projection && this.projection.unmount(),
      Ds.update(this.notifyUpdate),
      Ds.render(this.render),
      this.valueSubscriptions.forEach((r) => r()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this)
    for (const r in this.events) this.events[r].clear()
    for (const r in this.features) this.features[r].unmount()
    this.current = null
  }
  bindToMotionValue(r, a) {
    const o = Fl.has(r),
      l = a.on('change', (c) => {
        ;(this.latestValues[r] = c),
          this.props.onUpdate && Rn.update(this.notifyUpdate, !1, !0),
          o && this.projection && (this.projection.isTransformDirty = !0)
      }),
      f = a.on('renderRequest', this.scheduleRender)
    this.valueSubscriptions.set(r, () => {
      l(), f()
    })
  }
  sortNodePosition(r) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== r.type
      ? 0
      : this.sortInstanceNodePosition(this.current, r.current)
  }
  loadFeatures({ children: r, ...a }, o, l, f, c) {
    let p, h
    if (l && o) {
      const m =
        'You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.'
      a.ignoreStrict ? Jd(!1, m) : mi(!1, m)
    }
    for (let m = 0; m < QG; m++) {
      const g = zO[m],
        { isEnabled: b, Feature: C, ProjectionNode: w, MeasureLayout: k } = Fd[g]
      w && (p = w),
        b(a) && (!this.features[g] && C && (this.features[g] = new C(this)), k && (h = k))
    }
    if (!this.projection && p) {
      this.projection = new p(f, this.latestValues, this.parent && this.parent.projection)
      const {
        layoutId: m,
        layout: g,
        drag: b,
        dragConstraints: C,
        layoutScroll: w,
        layoutRoot: k,
      } = a
      this.projection.setOptions({
        layoutId: m,
        layout: g,
        alwaysMeasureLayout: !!b || (C && Hu(C)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof g == 'string' ? g : 'both',
        initialPromotionConfig: c,
        layoutScroll: w,
        layoutRoot: k,
      })
    }
    return h
  }
  updateFeatures() {
    for (const r in this.features) {
      const a = this.features[r]
      a.isMounted ? a.update(this.props, this.prevProps) : (a.mount(), (a.isMounted = !0))
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props)
  }
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Yn()
  }
  getStaticValue(r) {
    return this.latestValues[r]
  }
  setStaticValue(r, a) {
    this.latestValues[r] = a
  }
  makeTargetAnimatable(r, a = !0) {
    return this.makeTargetAnimatableFromInstance(r, this.props, a)
  }
  update(r, a) {
    ;(r.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = r),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = a)
    for (let o = 0; o < zk.length; o++) {
      const l = zk[o]
      this.propEventSubscriptions[l] &&
        (this.propEventSubscriptions[l](), delete this.propEventSubscriptions[l])
      const f = r['on' + l]
      f && (this.propEventSubscriptions[l] = this.on(l, f))
    }
    ;(this.prevMotionValues = XG(
      this,
      this.scrapeMotionValuesFromProps(r, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue()
  }
  getProps() {
    return this.props
  }
  getVariant(r) {
    return this.props.variants ? this.props.variants[r] : void 0
  }
  getDefaultTransition() {
    return this.props.transition
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
  }
  getVariantContext(r = !1) {
    if (r) return this.parent ? this.parent.getVariantContext() : void 0
    if (!this.isControllingVariants) {
      const o = this.parent ? this.parent.getVariantContext() || {} : {}
      return this.props.initial !== void 0 && (o.initial = this.props.initial), o
    }
    const a = {}
    for (let o = 0; o < ZG; o++) {
      const l = zx[o],
        f = this.props[l]
      ;($d(f) || f === !1) && (a[l] = f)
    }
    return a
  }
  addVariantChild(r) {
    const a = this.getClosestVariantNode()
    if (a) return a.variantChildren && a.variantChildren.add(r), () => a.variantChildren.delete(r)
  }
  addValue(r, a) {
    a !== this.values.get(r) && (this.removeValue(r), this.bindToMotionValue(r, a)),
      this.values.set(r, a),
      (this.latestValues[r] = a.get())
  }
  removeValue(r) {
    this.values.delete(r)
    const a = this.valueSubscriptions.get(r)
    a && (a(), this.valueSubscriptions.delete(r)),
      delete this.latestValues[r],
      this.removeValueFromRenderState(r, this.renderState)
  }
  hasValue(r) {
    return this.values.has(r)
  }
  getValue(r, a) {
    if (this.props.values && this.props.values[r]) return this.props.values[r]
    let o = this.values.get(r)
    return o === void 0 && a !== void 0 && ((o = ic(a, { owner: this })), this.addValue(r, o)), o
  }
  readValue(r) {
    return this.latestValues[r] !== void 0 || !this.current
      ? this.latestValues[r]
      : this.readValueFromInstance(this.current, r, this.options)
  }
  setBaseTarget(r, a) {
    this.baseTarget[r] = a
  }
  getBaseTarget(r) {
    var a
    const { initial: o } = this.props,
      l =
        typeof o == 'string' || typeof o == 'object'
          ? (a = Wx(this.props, o)) === null || a === void 0
            ? void 0
            : a[r]
          : void 0
    if (o && l !== void 0) return l
    const f = this.getBaseTargetFromProps(this.props, r)
    return f !== void 0 && !ha(f)
      ? f
      : this.initialValues[r] !== void 0 && l === void 0
      ? void 0
      : this.baseTarget[r]
  }
  on(r, a) {
    return this.events[r] || (this.events[r] = new eC()), this.events[r].add(a)
  }
  notify(r, ...a) {
    this.events[r] && this.events[r].notify(...a)
  }
}
class $O extends JG {
  sortInstanceNodePosition(r, a) {
    return r.compareDocumentPosition(a) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(r, a) {
    return r.style ? r.style[a] : void 0
  }
  removeValueFromRenderState(r, { vars: a, style: o }) {
    delete a[r], delete o[r]
  }
  makeTargetAnimatableFromInstance(
    { transition: r, transitionEnd: a, ...o },
    { transformValues: l },
    f
  ) {
    let c = gY(o, r || {}, this)
    if ((l && (a && (a = l(a)), o && (o = l(o)), c && (c = l(c))), f)) {
      mY(this, o, c)
      const p = qG(this, o, c, a)
      ;(a = p.transitionEnd), (o = p.target)
    }
    return { transition: r, transitionEnd: a, ...o }
  }
}
function eq(t) {
  return window.getComputedStyle(t)
}
class tq extends $O {
  readValueFromInstance(r, a) {
    if (Fl.has(a)) {
      const o = Kx(a)
      return (o && o.default) || 0
    } else {
      const o = eq(r),
        l = (kA(a) ? o.getPropertyValue(a) : o[a]) || 0
      return typeof l == 'string' ? l.trim() : l
    }
  }
  measureInstanceViewportBox(r, { transformPagePoint: a }) {
    return EO(r, a)
  }
  build(r, a, o, l) {
    Bx(r, a, o, l.transformTemplate)
  }
  scrapeMotionValuesFromProps(r, a) {
    return Hx(r, a)
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription)
    const { children: r } = this.props
    ha(r) &&
      (this.childSubscription = r.on('change', (a) => {
        this.current && (this.current.textContent = `${a}`)
      }))
  }
  renderInstance(r, a, o, l) {
    PA(r, a, o, l)
  }
}
class nq extends $O {
  constructor() {
    super(...arguments), (this.isSVGTag = !1)
  }
  getBaseTargetFromProps(r, a) {
    return r[a]
  }
  readValueFromInstance(r, a) {
    if (Fl.has(a)) {
      const o = Kx(a)
      return (o && o.default) || 0
    }
    return (a = LA.has(a) ? a : Ix(a)), r.getAttribute(a)
  }
  measureInstanceViewportBox() {
    return Yn()
  }
  scrapeMotionValuesFromProps(r, a) {
    return $A(r, a)
  }
  build(r, a, o, l) {
    Ux(r, a, o, this.isSVGTag, l.transformTemplate)
  }
  renderInstance(r, a, o, l) {
    zA(r, a, o, l)
  }
  mount(r) {
    ;(this.isSVGTag = Vx(r.tagName)), super.mount(r)
  }
}
const rq = (t, r) =>
    Nx(t)
      ? new nq(r, { enableHardwareAcceleration: !1 })
      : new tq(r, { enableHardwareAcceleration: !0 }),
  aq = { layout: { ProjectionNode: MO, MeasureLayout: RO } },
  iq = { ...OY, ...e7, ...BG, ...aq },
  FO = u8((t, r) => F8(t, r, iq, rq))
function NO() {
  const t = R.useRef(!1)
  return (
    qm(
      () => (
        (t.current = !0),
        () => {
          t.current = !1
        }
      ),
      []
    ),
    t
  )
}
function oq() {
  const t = NO(),
    [r, a] = R.useState(0),
    o = R.useCallback(() => {
      t.current && a(r + 1)
    }, [r])
  return [R.useCallback(() => Rn.postRender(o), [o]), r]
}
class sq extends R.Component {
  getSnapshotBeforeUpdate(r) {
    const a = this.props.childRef.current
    if (a && r.isPresent && !this.props.isPresent) {
      const o = this.props.sizeRef.current
      ;(o.height = a.offsetHeight || 0),
        (o.width = a.offsetWidth || 0),
        (o.top = a.offsetTop),
        (o.left = a.offsetLeft)
    }
    return null
  }
  componentDidUpdate() {}
  render() {
    return this.props.children
  }
}
function lq({ children: t, isPresent: r }) {
  const a = R.useId(),
    o = R.useRef(null),
    l = R.useRef({ width: 0, height: 0, top: 0, left: 0 })
  return (
    R.useInsertionEffect(() => {
      const { width: f, height: c, top: p, left: h } = l.current
      if (r || !o.current || !f || !c) return
      o.current.dataset.motionPopId = a
      const m = document.createElement('style')
      return (
        document.head.appendChild(m),
        m.sheet &&
          m.sheet.insertRule(`
          [data-motion-pop-id="${a}"] {
            position: absolute !important;
            width: ${f}px !important;
            height: ${c}px !important;
            top: ${p}px !important;
            left: ${h}px !important;
          }
        `),
        () => {
          document.head.removeChild(m)
        }
      )
    }, [r]),
    R.createElement(sq, { isPresent: r, childRef: o, sizeRef: l }, R.cloneElement(t, { ref: o }))
  )
}
const hS = ({
  children: t,
  initial: r,
  isPresent: a,
  onExitComplete: o,
  custom: l,
  presenceAffectsLayout: f,
  mode: c,
}) => {
  const p = $x(uq),
    h = R.useId(),
    m = R.useMemo(
      () => ({
        id: h,
        initial: r,
        isPresent: a,
        custom: l,
        onExitComplete: (g) => {
          p.set(g, !0)
          for (const b of p.values()) if (!b) return
          o && o()
        },
        register: (g) => (p.set(g, !1), () => p.delete(g)),
      }),
      f ? void 0 : [a]
    )
  return (
    R.useMemo(() => {
      p.forEach((g, b) => p.set(b, !1))
    }, [a]),
    R.useEffect(() => {
      !a && !p.size && o && o()
    }, [a]),
    c === 'popLayout' && (t = R.createElement(lq, { isPresent: a }, t)),
    R.createElement(Kd.Provider, { value: m }, t)
  )
}
function uq() {
  return new Map()
}
function cq(t) {
  return R.useEffect(() => () => t(), [])
}
const Vu = (t) => t.key || ''
function fq(t, r) {
  t.forEach((a) => {
    const o = Vu(a)
    r.set(o, a)
  })
}
function dq(t) {
  const r = []
  return (
    R.Children.forEach(t, (a) => {
      R.isValidElement(a) && r.push(a)
    }),
    r
  )
}
const pq = ({
  children: t,
  custom: r,
  initial: a = !0,
  onExitComplete: o,
  exitBeforeEnter: l,
  presenceAffectsLayout: f = !0,
  mode: c = 'sync',
}) => {
  mi(!l, "Replace exitBeforeEnter with mode='wait'")
  let [p] = oq()
  const h = R.useContext(Fx).forceRender
  h && (p = h)
  const m = NO(),
    g = dq(t)
  let b = g
  const C = new Set(),
    w = R.useRef(b),
    k = R.useRef(new Map()).current,
    D = R.useRef(!0)
  if (
    (qm(() => {
      ;(D.current = !1), fq(g, k), (w.current = b)
    }),
    cq(() => {
      ;(D.current = !0), k.clear(), C.clear()
    }),
    D.current)
  )
    return R.createElement(
      R.Fragment,
      null,
      b.map((P) =>
        R.createElement(
          hS,
          {
            key: Vu(P),
            isPresent: !0,
            initial: a ? void 0 : !1,
            presenceAffectsLayout: f,
            mode: c,
          },
          P
        )
      )
    )
  b = [...b]
  const E = w.current.map(Vu),
    M = g.map(Vu),
    z = E.length
  for (let P = 0; P < z; P++) {
    const B = E[P]
    M.indexOf(B) === -1 && C.add(B)
  }
  return (
    c === 'wait' && C.size && (b = []),
    C.forEach((P) => {
      if (M.indexOf(P) !== -1) return
      const B = k.get(P)
      if (!B) return
      const j = E.indexOf(P),
        Q = () => {
          k.delete(P), C.delete(P)
          const Y = w.current.findIndex((ne) => ne.key === P)
          if ((w.current.splice(Y, 1), !C.size)) {
            if (((w.current = g), m.current === !1)) return
            p(), o && o()
          }
        }
      b.splice(
        j,
        0,
        R.createElement(
          hS,
          {
            key: Vu(B),
            isPresent: !1,
            onExitComplete: Q,
            custom: r,
            presenceAffectsLayout: f,
            mode: c,
          },
          B
        )
      )
    }),
    (b = b.map((P) => {
      const B = P.key
      return C.has(B)
        ? P
        : R.createElement(hS, { key: Vu(P), isPresent: !0, presenceAffectsLayout: f, mode: c }, P)
    })),
    c === 'wait' &&
      b.length > 1 &&
      console.warn(
        `You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`
      ),
    R.createElement(R.Fragment, null, C.size ? b : b.map((P) => R.cloneElement(P)))
  )
}
var hq = {
    initial: (t) => {
      const { position: r } = t,
        a = ['top', 'bottom'].includes(r) ? 'y' : 'x'
      let o = ['top-right', 'bottom-right'].includes(r) ? 1 : -1
      return r === 'bottom' && (o = 1), { opacity: 0, [a]: o * 24 }
    },
    animate: {
      opacity: 1,
      y: 0,
      x: 0,
      scale: 1,
      transition: { duration: 0.4, ease: [0.4, 0, 0.2, 1] },
    },
    exit: { opacity: 0, scale: 0.85, transition: { duration: 0.2, ease: [0.4, 0, 1, 1] } },
  },
  BO = R.memo((t) => {
    const {
        id: r,
        message: a,
        onCloseComplete: o,
        onRequestRemove: l,
        requestClose: f = !1,
        position: c = 'bottom',
        duration: p = 5e3,
        containerStyle: h,
        motionVariants: m = hq,
        toastSpacing: g = '0.5rem',
      } = t,
      [b, C] = R.useState(p),
      w = eG()
    zd(() => {
      w || o == null || o()
    }, [w]),
      zd(() => {
        C(p)
      }, [p])
    const k = () => C(null),
      D = () => C(p),
      E = () => {
        w && l()
      }
    R.useEffect(() => {
      w && f && l()
    }, [w, f, l]),
      ZW(E, b)
    const M = R.useMemo(
        () => ({ pointerEvents: 'auto', maxWidth: 560, minWidth: 300, margin: g, ...h }),
        [h, g]
      ),
      z = R.useMemo(() => XW(c), [c])
    return V(FO.li, {
      layout: !0,
      className: 'chakra-toast',
      variants: m,
      initial: 'initial',
      animate: 'animate',
      exit: 'exit',
      onHoverStart: k,
      onHoverEnd: D,
      custom: { position: c },
      style: z,
      children: V(Ht.div, {
        'role': 'status',
        'aria-atomic': 'true',
        'className': 'chakra-toast__inner',
        '__css': M,
        'children': ko(a, { id: r, onClose: E }),
      }),
    })
  })
BO.displayName = 'ToastComponent'
var $k = {
    path: He('g', {
      stroke: 'currentColor',
      strokeWidth: '1.5',
      children: [
        V('path', {
          strokeLinecap: 'round',
          fill: 'none',
          d: 'M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25',
        }),
        V('path', {
          fill: 'currentColor',
          strokeLinecap: 'round',
          d: 'M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0',
        }),
        V('circle', { fill: 'none', strokeMiterlimit: '10', cx: '12', cy: '12', r: '11.25' }),
      ],
    }),
    viewBox: '0 0 24 24',
  },
  tp = _n((t, r) => {
    const {
        as: a,
        viewBox: o,
        color: l = 'currentColor',
        focusable: f = !1,
        children: c,
        className: p,
        __css: h,
        ...m
      } = t,
      g = lr('chakra-icon', p),
      b = $l('Icon', t),
      C = {
        w: '1em',
        h: '1em',
        display: 'inline-block',
        lineHeight: '1em',
        flexShrink: 0,
        color: l,
        ...h,
        ...b,
      },
      w = { ref: r, focusable: f, className: g, __css: C },
      k = o ?? $k.viewBox
    if (a && typeof a != 'string') return V(Ht.svg, { as: a, ...w, ...m })
    const D = c ?? $k.path
    return V(Ht.svg, { verticalAlign: 'middle', viewBox: k, ...w, ...m, children: D })
  })
tp.displayName = 'Icon'
function mq(t) {
  return V(tp, {
    viewBox: '0 0 24 24',
    ...t,
    children: V('path', {
      fill: 'currentColor',
      d: 'M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z',
    }),
  })
}
function vq(t) {
  return V(tp, {
    viewBox: '0 0 24 24',
    ...t,
    children: V('path', {
      fill: 'currentColor',
      d: 'M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z',
    }),
  })
}
function Fk(t) {
  return V(tp, {
    viewBox: '0 0 24 24',
    ...t,
    children: V('path', {
      fill: 'currentColor',
      d: 'M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z',
    }),
  })
}
var gq = fU({ '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' } }),
  nC = _n((t, r) => {
    const a = $l('Spinner', t),
      {
        label: o = 'Loading...',
        thickness: l = '2px',
        speed: f = '0.45s',
        emptyColor: c = 'transparent',
        className: p,
        ...h
      } = Ps(t),
      m = lr('chakra-spinner', p),
      g = {
        display: 'inline-block',
        borderColor: 'currentColor',
        borderStyle: 'solid',
        borderRadius: '99999px',
        borderWidth: l,
        borderBottomColor: c,
        borderLeftColor: c,
        animation: `${gq} ${f} linear infinite`,
        ...a,
      }
    return V(Ht.div, {
      ref: r,
      __css: g,
      className: m,
      ...h,
      children: o && V(Ht.span, { srOnly: !0, children: o }),
    })
  })
nC.displayName = 'Spinner'
var [yq, bq] = zo({ name: 'AlertContext', hookName: 'useAlertContext', providerName: '<Alert />' }),
  [Sq, rC] = zo({
    name: 'AlertStylesContext',
    hookName: 'useAlertStyles',
    providerName: '<Alert />',
  }),
  jO = {
    info: { icon: vq, colorScheme: 'blue' },
    warning: { icon: Fk, colorScheme: 'orange' },
    success: { icon: mq, colorScheme: 'green' },
    error: { icon: Fk, colorScheme: 'red' },
    loading: { icon: nC, colorScheme: 'blue' },
  }
function xq(t) {
  return jO[t].colorScheme
}
function Cq(t) {
  return jO[t].icon
}
var UO = _n(function (r, a) {
  const l = { display: 'inline', ...rC().description }
  return V(Ht.div, { ref: a, ...r, className: lr('chakra-alert__desc', r.className), __css: l })
})
UO.displayName = 'AlertDescription'
function VO(t) {
  const { status: r } = bq(),
    a = Cq(r),
    o = rC(),
    l = r === 'loading' ? o.spinner : o.icon
  return V(Ht.span, {
    display: 'inherit',
    ...t,
    className: lr('chakra-alert__icon', t.className),
    __css: l,
    children: t.children || V(a, { h: '100%', w: '100%' }),
  })
}
VO.displayName = 'AlertIcon'
var IO = _n(function (r, a) {
  const o = rC()
  return V(Ht.div, {
    ref: a,
    ...r,
    className: lr('chakra-alert__title', r.className),
    __css: o.title,
  })
})
IO.displayName = 'AlertTitle'
var HO = _n(function (r, a) {
  var o
  const { status: l = 'info', addRole: f = !0, ...c } = Ps(r),
    p = (o = r.colorScheme) != null ? o : xq(l),
    h = bA('Alert', { ...r, colorScheme: p }),
    m = {
      width: '100%',
      display: 'flex',
      alignItems: 'center',
      position: 'relative',
      overflow: 'hidden',
      ...h.container,
    }
  return V(yq, {
    value: { status: l },
    children: V(Sq, {
      value: h,
      children: V(Ht.div, {
        role: f ? 'alert' : void 0,
        ref: a,
        ...c,
        className: lr('chakra-alert', r.className),
        __css: m,
      }),
    }),
  })
})
HO.displayName = 'Alert'
function wq(t) {
  return V(tp, {
    'focusable': 'false',
    'aria-hidden': !0,
    ...t,
    'children': V('path', {
      fill: 'currentColor',
      d: 'M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z',
    }),
  })
}
var WO = _n(function (r, a) {
  const o = $l('CloseButton', r),
    { children: l, isDisabled: f, __css: c, ...p } = Ps(r),
    h = {
      outline: 0,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      flexShrink: 0,
    }
  return V(Ht.button, {
    'type': 'button',
    'aria-label': 'Close',
    'ref': a,
    'disabled': f,
    '__css': { ...h, ...o, ...c },
    ...p,
    'children': l || V(wq, { width: '1em', height: '1em' }),
  })
})
WO.displayName = 'CloseButton'
var Eq = {
    'top': [],
    'top-left': [],
    'top-right': [],
    'bottom-left': [],
    'bottom': [],
    'bottom-right': [],
  },
  Sd = Tq(Eq)
function Tq(t) {
  let r = t
  const a = new Set(),
    o = (l) => {
      ;(r = l(r)), a.forEach((f) => f())
    }
  return {
    getState: () => r,
    subscribe: (l) => (
      a.add(l),
      () => {
        o(() => t), a.delete(l)
      }
    ),
    removeToast: (l, f) => {
      o((c) => ({ ...c, [f]: c[f].filter((p) => p.id != l) }))
    },
    notify: (l, f) => {
      const c = Rq(l, f),
        { position: p, id: h } = c
      return (
        o((m) => {
          var g, b
          const w = p.includes('top')
            ? [c, ...((g = m[p]) != null ? g : [])]
            : [...((b = m[p]) != null ? b : []), c]
          return { ...m, [p]: w }
        }),
        h
      )
    },
    update: (l, f) => {
      l &&
        o((c) => {
          const p = { ...c },
            { position: h, index: m } = k_(p, l)
          return h && m !== -1 && (p[h][m] = { ...p[h][m], ...f, message: kq(f) }), p
        })
    },
    closeAll: ({ positions: l } = {}) => {
      o((f) =>
        (l ?? ['bottom', 'bottom-right', 'bottom-left', 'top', 'top-left', 'top-right']).reduce(
          (h, m) => ((h[m] = f[m].map((g) => ({ ...g, requestClose: !0 }))), h),
          { ...f }
        )
      )
    },
    close: (l) => {
      o((f) => {
        const c = xA(f, l)
        return c ? { ...f, [c]: f[c].map((p) => (p.id == l ? { ...p, requestClose: !0 } : p)) } : f
      })
    },
    isActive: (l) => !!k_(Sd.getState(), l).position,
  }
}
var Nk = 0
function Rq(t, r = {}) {
  var a, o
  Nk += 1
  const l = (a = r.id) != null ? a : Nk,
    f = (o = r.position) != null ? o : 'bottom'
  return {
    id: l,
    message: t,
    position: f,
    duration: r.duration,
    onCloseComplete: r.onCloseComplete,
    onRequestRemove: () => Sd.removeToast(String(l), f),
    status: r.status,
    requestClose: !1,
    containerStyle: r.containerStyle,
  }
}
var _q = (t) => {
  const {
      status: r,
      variant: a = 'solid',
      id: o,
      title: l,
      isClosable: f,
      onClose: c,
      description: p,
      colorScheme: h,
      icon: m,
    } = t,
    g = o
      ? { root: `toast-${o}`, title: `toast-${o}-title`, description: `toast-${o}-description` }
      : void 0
  return He(HO, {
    addRole: !1,
    status: r,
    variant: a,
    id: g == null ? void 0 : g.root,
    alignItems: 'start',
    borderRadius: 'md',
    boxShadow: 'lg',
    paddingEnd: 8,
    textAlign: 'start',
    width: 'auto',
    colorScheme: h,
    children: [
      V(VO, { children: m }),
      He(Ht.div, {
        flex: '1',
        maxWidth: '100%',
        children: [
          l && V(IO, { id: g == null ? void 0 : g.title, children: l }),
          p && V(UO, { id: g == null ? void 0 : g.description, display: 'block', children: p }),
        ],
      }),
      f && V(WO, { size: 'sm', onClick: c, position: 'absolute', insetEnd: 1, top: 1 }),
    ],
  })
}
function kq(t = {}) {
  const { render: r, toastComponent: a = _q } = t
  return (l) => (typeof r == 'function' ? r({ ...l, ...t }) : V(a, { ...l, ...t }))
}
var [Dq, Fee] = zo({ name: 'ToastOptionsContext', strict: !1 }),
  Aq = (t) => {
    const r = R.useSyncExternalStore(Sd.subscribe, Sd.getState, Sd.getState),
      { motionVariants: a, component: o = BO, portalProps: l } = t,
      c = Object.keys(r).map((p) => {
        const h = r[p]
        return V(
          'ul',
          {
            'role': 'region',
            'aria-live': 'polite',
            'id': `chakra-toast-manager-${p}`,
            'style': QW(p),
            'children': V(pq, {
              initial: !1,
              children: h.map((m) => V(o, { motionVariants: a, ...m }, m.id)),
            }),
          },
          p
        )
      })
    return V(hv, { ...l, children: c })
  },
  Oq = (t) =>
    function ({ children: a, theme: o = t, toastOptions: l, ...f }) {
      return He(qW, {
        theme: o,
        ...f,
        children: [
          V(Dq, { value: l == null ? void 0 : l.defaultOptions, children: a }),
          V(Aq, { ...l }),
        ],
      })
    },
  Mq = Oq(dA),
  Pq = Object.defineProperty,
  Lq = (t, r, a) =>
    r in t ? Pq(t, r, { enumerable: !0, configurable: !0, writable: !0, value: a }) : (t[r] = a),
  $n = (t, r, a) => (Lq(t, typeof r != 'symbol' ? r + '' : r, a), a)
function Bk(t) {
  return t.sort((r, a) => {
    const o = r.compareDocumentPosition(a)
    if (o & Node.DOCUMENT_POSITION_FOLLOWING || o & Node.DOCUMENT_POSITION_CONTAINED_BY) return -1
    if (o & Node.DOCUMENT_POSITION_PRECEDING || o & Node.DOCUMENT_POSITION_CONTAINS) return 1
    if (
      o & Node.DOCUMENT_POSITION_DISCONNECTED ||
      o & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
    )
      throw Error('Cannot sort the given nodes.')
    return 0
  })
}
var zq = (t) => typeof t == 'object' && 'nodeType' in t && t.nodeType === Node.ELEMENT_NODE
function jk(t, r, a) {
  let o = t + 1
  return a && o >= r && (o = 0), o
}
function Uk(t, r, a) {
  let o = t - 1
  return a && o < 0 && (o = r), o
}
var ex = typeof window < 'u' ? R.useLayoutEffect : R.useEffect,
  rv = (t) => t,
  $q = class {
    constructor() {
      $n(this, 'descendants', new Map()),
        $n(this, 'register', (t) => {
          if (t != null)
            return zq(t)
              ? this.registerNode(t)
              : (r) => {
                  this.registerNode(r, t)
                }
        }),
        $n(this, 'unregister', (t) => {
          this.descendants.delete(t)
          const r = Bk(Array.from(this.descendants.keys()))
          this.assignIndex(r)
        }),
        $n(this, 'destroy', () => {
          this.descendants.clear()
        }),
        $n(this, 'assignIndex', (t) => {
          this.descendants.forEach((r) => {
            const a = t.indexOf(r.node)
            ;(r.index = a), (r.node.dataset.index = r.index.toString())
          })
        }),
        $n(this, 'count', () => this.descendants.size),
        $n(this, 'enabledCount', () => this.enabledValues().length),
        $n(this, 'values', () =>
          Array.from(this.descendants.values()).sort((r, a) => r.index - a.index)
        ),
        $n(this, 'enabledValues', () => this.values().filter((t) => !t.disabled)),
        $n(this, 'item', (t) => {
          if (this.count() !== 0) return this.values()[t]
        }),
        $n(this, 'enabledItem', (t) => {
          if (this.enabledCount() !== 0) return this.enabledValues()[t]
        }),
        $n(this, 'first', () => this.item(0)),
        $n(this, 'firstEnabled', () => this.enabledItem(0)),
        $n(this, 'last', () => this.item(this.descendants.size - 1)),
        $n(this, 'lastEnabled', () => {
          const t = this.enabledValues().length - 1
          return this.enabledItem(t)
        }),
        $n(this, 'indexOf', (t) => {
          var r, a
          return t && (a = (r = this.descendants.get(t)) == null ? void 0 : r.index) != null
            ? a
            : -1
        }),
        $n(this, 'enabledIndexOf', (t) =>
          t == null ? -1 : this.enabledValues().findIndex((r) => r.node.isSameNode(t))
        ),
        $n(this, 'next', (t, r = !0) => {
          const a = jk(t, this.count(), r)
          return this.item(a)
        }),
        $n(this, 'nextEnabled', (t, r = !0) => {
          const a = this.item(t)
          if (!a) return
          const o = this.enabledIndexOf(a.node),
            l = jk(o, this.enabledCount(), r)
          return this.enabledItem(l)
        }),
        $n(this, 'prev', (t, r = !0) => {
          const a = Uk(t, this.count() - 1, r)
          return this.item(a)
        }),
        $n(this, 'prevEnabled', (t, r = !0) => {
          const a = this.item(t)
          if (!a) return
          const o = this.enabledIndexOf(a.node),
            l = Uk(o, this.enabledCount() - 1, r)
          return this.enabledItem(l)
        }),
        $n(this, 'registerNode', (t, r) => {
          if (!t || this.descendants.has(t)) return
          const a = Array.from(this.descendants.keys()).concat(t),
            o = Bk(a)
          r != null && r.disabled && (r.disabled = !!r.disabled)
          const l = { node: t, index: -1, ...r }
          this.descendants.set(t, l), this.assignIndex(o)
        })
    }
  }
function Fq(t, r) {
  if (t != null) {
    if (typeof t == 'function') {
      t(r)
      return
    }
    try {
      t.current = r
    } catch {
      throw new Error(`Cannot assign value '${r}' to ref '${t}'`)
    }
  }
}
function Os(...t) {
  return (r) => {
    t.forEach((a) => {
      Fq(a, r)
    })
  }
}
function Nq(...t) {
  return R.useMemo(() => Os(...t), t)
}
function Bq() {
  const t = R.useRef(new $q())
  return ex(() => () => t.current.destroy()), t.current
}
var [jq, YO] = zo({
  name: 'DescendantsProvider',
  errorMessage: 'useDescendantsContext must be used within DescendantsProvider',
})
function Uq(t) {
  const r = YO(),
    [a, o] = R.useState(-1),
    l = R.useRef(null)
  ex(
    () => () => {
      l.current && r.unregister(l.current)
    },
    []
  ),
    ex(() => {
      if (!l.current) return
      const c = Number(l.current.dataset.index)
      a != c && !Number.isNaN(c) && o(c)
    })
  const f = rv(t ? r.register(t) : r.register)
  return { descendants: r, index: a, enabledIndex: r.enabledIndexOf(l.current), register: Os(f, l) }
}
function Vq() {
  return [rv(jq), () => rv(YO()), () => Bq(), (l) => Uq(l)]
}
function Iq(t) {
  return R.Children.toArray(t).filter((r) => R.isValidElement(r))
}
var [Hq, Wq] = zo({ strict: !1, name: 'ButtonGroupContext' }),
  Yq = {
    horizontal: {
      '> *:first-of-type:not(:last-of-type)': { borderEndRadius: 0 },
      '> *:not(:first-of-type):not(:last-of-type)': { borderRadius: 0 },
      '> *:not(:first-of-type):last-of-type': { borderStartRadius: 0 },
    },
    vertical: {
      '> *:first-of-type:not(:last-of-type)': { borderBottomRadius: 0 },
      '> *:not(:first-of-type):not(:last-of-type)': { borderRadius: 0 },
      '> *:not(:first-of-type):last-of-type': { borderTopRadius: 0 },
    },
  },
  Gq = {
    horizontal: (t) => ({ '& > *:not(style) ~ *:not(style)': { marginStart: t } }),
    vertical: (t) => ({ '& > *:not(style) ~ *:not(style)': { marginTop: t } }),
  },
  GO = _n(function (r, a) {
    const {
        size: o,
        colorScheme: l,
        variant: f,
        className: c,
        spacing: p = '0.5rem',
        isAttached: h,
        isDisabled: m,
        orientation: g = 'horizontal',
        ...b
      } = r,
      C = lr('chakra-button__group', c),
      w = R.useMemo(() => ({ size: o, colorScheme: l, variant: f, isDisabled: m }), [o, l, f, m])
    let k = { display: 'inline-flex', ...(h ? Yq[g] : Gq[g](p)) }
    const D = g === 'vertical'
    return V(Hq, {
      value: w,
      children: V(Ht.div, {
        'ref': a,
        'role': 'group',
        '__css': k,
        'className': C,
        'data-attached': h ? '' : void 0,
        'data-orientation': g,
        'flexDir': D ? 'column' : void 0,
        ...b,
      }),
    })
  })
GO.displayName = 'ButtonGroup'
function qq(t) {
  const [r, a] = R.useState(!t)
  return {
    ref: R.useCallback((f) => {
      f && a(f.tagName === 'BUTTON')
    }, []),
    type: r ? 'button' : void 0,
  }
}
function tx(t) {
  const { children: r, className: a, ...o } = t,
    l = R.isValidElement(r) ? R.cloneElement(r, { 'aria-hidden': !0, 'focusable': !1 }) : r,
    f = lr('chakra-button__icon', a)
  return V(Ht.span, {
    display: 'inline-flex',
    alignSelf: 'center',
    flexShrink: 0,
    ...o,
    className: f,
    children: l,
  })
}
tx.displayName = 'ButtonIcon'
function nx(t) {
  const {
      label: r,
      placement: a,
      spacing: o = '0.5rem',
      children: l = V(nC, { color: 'currentColor', width: '1em', height: '1em' }),
      className: f,
      __css: c,
      ...p
    } = t,
    h = lr('chakra-button__spinner', f),
    m = a === 'start' ? 'marginEnd' : 'marginStart',
    g = R.useMemo(
      () => ({
        display: 'flex',
        alignItems: 'center',
        position: r ? 'relative' : 'absolute',
        [m]: r ? o : 0,
        fontSize: '1em',
        lineHeight: 'normal',
        ...c,
      }),
      [c, r, m, o]
    )
  return V(Ht.div, { className: h, ...p, __css: g, children: l })
}
nx.displayName = 'ButtonSpinner'
var To = _n((t, r) => {
  const a = Wq(),
    o = $l('Button', { ...a, ...t }),
    {
      isDisabled: l = a == null ? void 0 : a.isDisabled,
      isLoading: f,
      isActive: c,
      children: p,
      leftIcon: h,
      rightIcon: m,
      loadingText: g,
      iconSpacing: b = '0.5rem',
      type: C,
      spinner: w,
      spinnerPlacement: k = 'start',
      className: D,
      as: E,
      ...M
    } = Ps(t),
    z = R.useMemo(() => {
      const Q = { ...(o == null ? void 0 : o._focus), zIndex: 1 }
      return {
        display: 'inline-flex',
        appearance: 'none',
        alignItems: 'center',
        justifyContent: 'center',
        userSelect: 'none',
        position: 'relative',
        whiteSpace: 'nowrap',
        verticalAlign: 'middle',
        outline: 'none',
        ...o,
        ...(!!a && { _focus: Q }),
      }
    }, [o, a]),
    { ref: P, type: B } = qq(E),
    j = { rightIcon: m, leftIcon: h, iconSpacing: b, children: p }
  return He(Ht.button, {
    'ref': Nq(r, P),
    'as': E,
    'type': C ?? B,
    'data-active': Um(c),
    'data-loading': Um(f),
    '__css': z,
    'className': lr('chakra-button', D),
    ...M,
    'disabled': l || f,
    'children': [
      f &&
        k === 'start' &&
        V(nx, {
          className: 'chakra-button__spinner--start',
          label: g,
          placement: 'start',
          spacing: b,
          children: w,
        }),
      f ? g || V(Ht.span, { opacity: 0, children: V(Vk, { ...j }) }) : V(Vk, { ...j }),
      f &&
        k === 'end' &&
        V(nx, {
          className: 'chakra-button__spinner--end',
          label: g,
          placement: 'end',
          spacing: b,
          children: w,
        }),
    ],
  })
})
To.displayName = 'Button'
function Vk(t) {
  const { leftIcon: r, rightIcon: a, children: o, iconSpacing: l } = t
  return He(sv, {
    children: [
      r && V(tx, { marginEnd: l, children: r }),
      o,
      a && V(tx, { marginStart: l, children: a }),
    ],
  })
}
var qO = _n((t, r) => {
  const { 'icon': a, 'children': o, 'isRound': l, 'aria-label': f, ...c } = t,
    p = a || o,
    h = R.isValidElement(p) ? R.cloneElement(p, { 'aria-hidden': !0, 'focusable': !1 }) : null
  return V(To, {
    'padding': '0',
    'borderRadius': l ? 'full' : void 0,
    'ref': r,
    'aria-label': f,
    ...c,
    'children': h,
  })
})
qO.displayName = 'IconButton'
function Kq(t, r, a, o) {
  const l = Ld(a)
  return (
    R.useEffect(() => {
      const f = typeof t == 'function' ? t() : t ?? document
      if (!(!a || !f))
        return (
          f.addEventListener(r, l, o),
          () => {
            f.removeEventListener(r, l, o)
          }
        )
    }, [r, t, o, l, a]),
    () => {
      const f = typeof t == 'function' ? t() : t ?? document
      f == null || f.removeEventListener(r, l, o)
    }
  )
}
function KO(t) {
  return t != null && typeof t == 'object' && 'nodeType' in t && t.nodeType === Node.ELEMENT_NODE
}
function XO(t) {
  var r
  if (!KO(t)) return !1
  const a = (r = t.ownerDocument.defaultView) != null ? r : window
  return t instanceof a.HTMLElement
}
function Xq(t) {
  var r, a
  return (a = (r = QO(t)) == null ? void 0 : r.defaultView) != null ? a : window
}
function QO(t) {
  return KO(t) ? t.ownerDocument : document
}
function Qq(t) {
  return QO(t).activeElement
}
var ZO = (t) => t.hasAttribute('tabindex'),
  Zq = (t) => ZO(t) && t.tabIndex === -1
function Jq(t) {
  return !!t.getAttribute('disabled') || !!t.getAttribute('aria-disabled')
}
function JO(t) {
  return t.parentElement && JO(t.parentElement) ? !0 : t.hidden
}
function eK(t) {
  const r = t.getAttribute('contenteditable')
  return r !== 'false' && r != null
}
function tK(t) {
  if (!XO(t) || JO(t) || Jq(t)) return !1
  const { localName: r } = t
  if (['input', 'select', 'textarea', 'button'].indexOf(r) >= 0) return !0
  const o = {
    a: () => t.hasAttribute('href'),
    audio: () => t.hasAttribute('controls'),
    video: () => t.hasAttribute('controls'),
  }
  return r in o ? o[r]() : eK(t) ? !0 : ZO(t)
}
function nK(t) {
  return t ? XO(t) && tK(t) && !Zq(t) : !1
}
var eM = _n(function (r, a) {
  const {
      templateAreas: o,
      gap: l,
      rowGap: f,
      columnGap: c,
      column: p,
      row: h,
      autoFlow: m,
      autoRows: g,
      templateRows: b,
      autoColumns: C,
      templateColumns: w,
      ...k
    } = r,
    D = {
      display: 'grid',
      gridTemplateAreas: o,
      gridGap: l,
      gridRowGap: f,
      gridColumnGap: c,
      gridAutoColumns: C,
      gridColumn: p,
      gridRow: h,
      gridAutoFlow: m,
      gridAutoRows: g,
      gridTemplateRows: b,
      gridTemplateColumns: w,
    }
  return V(Ht.div, { ref: a, __css: D, ...k })
})
eM.displayName = 'Grid'
var tM = Object.freeze(['base', 'sm', 'md', 'lg', 'xl', '2xl'])
function nM(t, r) {
  return Array.isArray(t)
    ? t.map((a) => (a === null ? null : r(a)))
    : Br(t)
    ? Object.keys(t).reduce((a, o) => ((a[o] = r(t[o])), a), {})
    : t != null
    ? r(t)
    : null
}
function rK(t, r = tM) {
  const a = {}
  return (
    t.forEach((o, l) => {
      const f = r[l]
      o != null && (a[f] = o)
    }),
    a
  )
}
var mt = _n(function (r, a) {
  const o = $l('Text', r),
    { className: l, align: f, decoration: c, casing: p, ...h } = Ps(r),
    m = OW({ textAlign: r.align, textDecoration: r.decoration, textTransform: r.casing })
  return V(Ht.p, { ref: a, className: lr('chakra-text', r.className), ...m, ...h, __css: o })
})
mt.displayName = 'Text'
var rM = (t) =>
  V(Ht.div, {
    className: 'chakra-stack__item',
    ...t,
    __css: { display: 'inline-block', flex: '0 0 auto', minWidth: 0, ...t.__css },
  })
rM.displayName = 'StackItem'
var rx = '& > *:not(style) ~ *:not(style)'
function aK(t) {
  const { spacing: r, direction: a } = t,
    o = {
      'column': { marginTop: r, marginEnd: 0, marginBottom: 0, marginStart: 0 },
      'row': { marginTop: 0, marginEnd: 0, marginBottom: 0, marginStart: r },
      'column-reverse': { marginTop: 0, marginEnd: 0, marginBottom: r, marginStart: 0 },
      'row-reverse': { marginTop: 0, marginEnd: r, marginBottom: 0, marginStart: 0 },
    }
  return { flexDirection: a, [rx]: nM(a, (l) => o[l]) }
}
function iK(t) {
  const { spacing: r, direction: a } = t,
    o = {
      'column': { my: r, mx: 0, borderLeftWidth: 0, borderBottomWidth: '1px' },
      'column-reverse': { my: r, mx: 0, borderLeftWidth: 0, borderBottomWidth: '1px' },
      'row': { mx: r, my: 0, borderLeftWidth: '1px', borderBottomWidth: 0 },
      'row-reverse': { mx: r, my: 0, borderLeftWidth: '1px', borderBottomWidth: 0 },
    }
  return { '&': nM(a, (l) => o[l]) }
}
var dc = _n((t, r) => {
  const {
      isInline: a,
      direction: o,
      align: l,
      justify: f,
      spacing: c = '0.5rem',
      wrap: p,
      children: h,
      divider: m,
      className: g,
      shouldWrapChildren: b,
      ...C
    } = t,
    w = a ? 'row' : o ?? 'column',
    k = R.useMemo(() => aK({ direction: w, spacing: c }), [w, c]),
    D = R.useMemo(() => iK({ spacing: c, direction: w }), [c, w]),
    E = !!m,
    M = !b && !E,
    z = R.useMemo(() => {
      const B = Iq(h)
      return M
        ? B
        : B.map((j, Q) => {
            const Y = typeof j.key < 'u' ? j.key : Q,
              ne = Q + 1 === B.length,
              le = b ? V(rM, { children: j }, Y) : j
            if (!E) return le
            const pe = R.cloneElement(m, { __css: D }),
              Ne = ne ? null : pe
            return He(R.Fragment, { children: [le, Ne] }, Y)
          })
    }, [m, D, E, M, b, h]),
    P = lr('chakra-stack', g)
  return V(Ht.div, {
    ref: r,
    display: 'flex',
    alignItems: l,
    justifyContent: f,
    flexDirection: k.flexDirection,
    flexWrap: p,
    className: P,
    __css: E ? {} : { [rx]: k[rx] },
    ...C,
    children: z,
  })
})
dc.displayName = 'Stack'
var ax = _n((t, r) => V(dc, { align: 'center', ...t, direction: 'row', ref: r }))
ax.displayName = 'HStack'
var Ud = _n(function (r, a) {
  const o = $l('Heading', r),
    { className: l, ...f } = Ps(r)
  return V(Ht.h2, { ref: a, className: lr('chakra-heading', r.className), ...f, __css: o })
})
Ud.displayName = 'Heading'
var oc = Ht('div')
oc.displayName = 'Box'
var aM = _n(function (r, a) {
  const { size: o, centerContent: l = !0, ...f } = r
  return V(oc, {
    ref: a,
    boxSize: o,
    __css: {
      ...(l ? { display: 'flex', alignItems: 'center', justifyContent: 'center' } : {}),
      flexShrink: 0,
      flexGrow: 0,
    },
    ...f,
  })
})
aM.displayName = 'Square'
var oK = _n(function (r, a) {
  const { size: o, ...l } = r
  return V(aM, { size: o, ref: a, borderRadius: '9999px', ...l })
})
oK.displayName = 'Circle'
var Dv = _n(function (r, a) {
  const { className: o, centerContent: l, ...f } = Ps(r),
    c = $l('Container', r)
  return V(Ht.div, {
    ref: a,
    className: lr('chakra-container', o),
    ...f,
    __css: { ...c, ...(l && { display: 'flex', flexDirection: 'column', alignItems: 'center' }) },
  })
})
Dv.displayName = 'Container'
var Vd = _n(function (r, a) {
  const { direction: o, align: l, justify: f, wrap: c, basis: p, grow: h, shrink: m, ...g } = r,
    b = {
      display: 'flex',
      flexDirection: o,
      alignItems: l,
      justifyContent: f,
      flexWrap: c,
      flexBasis: p,
      flexGrow: h,
      flexShrink: m,
    }
  return V(Ht.div, { ref: a, __css: b, ...g })
})
Vd.displayName = 'Flex'
function sK(t, r = {}) {
  const { ssr: a = !0, fallback: o } = r,
    { getWindow: l } = GW(),
    f = Array.isArray(t) ? t : [t]
  let c = Array.isArray(o) ? o : [o]
  c = c.filter((m) => m != null)
  const [p, h] = R.useState(() =>
    f.map((m, g) => ({ media: m, matches: a ? !!c[g] : l().matchMedia(m).matches }))
  )
  return (
    R.useEffect(() => {
      const m = l()
      h(f.map((C) => ({ media: C, matches: m.matchMedia(C).matches })))
      const g = f.map((C) => m.matchMedia(C)),
        b = (C) => {
          h((w) => w.slice().map((k) => (k.media === C.media ? { ...k, matches: C.matches } : k)))
        }
      return (
        g.forEach((C) => {
          typeof C.addListener == 'function' ? C.addListener(b) : C.addEventListener('change', b)
        }),
        () => {
          g.forEach((C) => {
            typeof C.removeListener == 'function'
              ? C.removeListener(b)
              : C.removeEventListener('change', b)
          })
        }
      )
    }, [l]),
    p.map((m) => m.matches)
  )
}
function lK(t, r, a = tM) {
  let o = Object.keys(t).indexOf(r)
  if (o !== -1) return t[r]
  let l = a.indexOf(r)
  for (; l >= 0; ) {
    const f = a[l]
    if (t.hasOwnProperty(f)) {
      o = l
      break
    }
    l -= 1
  }
  if (o !== -1) {
    const f = a[o]
    return t[f]
  }
}
function uK(t) {
  var r, a
  const o = Br(t) ? t : { fallback: t ?? 'base' },
    f = mv().__breakpoints.details.map(({ minMaxQuery: m, breakpoint: g }) => ({
      breakpoint: g,
      query: m.replace('@media screen and ', ''),
    })),
    c = f.map((m) => m.breakpoint === o.fallback),
    h = sK(
      f.map((m) => m.query),
      { fallback: c, ssr: o.ssr }
    ).findIndex((m) => m == !0)
  return (a = (r = f[h]) == null ? void 0 : r.breakpoint) != null ? a : o.fallback
}
function cK(t, r) {
  var a
  const o = Br(r) ? r : { fallback: r ?? 'base' },
    l = uK(o),
    f = mv()
  if (!l) return
  const c = Array.from(((a = f.__breakpoints) == null ? void 0 : a.keys) || []),
    p = Array.isArray(t) ? Object.fromEntries(Object.entries(rK(t, c)).map(([h, m]) => [h, m])) : t
  return lK(p, l, c)
}
function fK(t) {
  const { key: r } = t
  return r.length === 1 || (r.length > 1 && /[^a-zA-Z0-9]/.test(r))
}
function dK(t = {}) {
  const { timeout: r = 300, preventDefault: a = () => !0 } = t,
    [o, l] = R.useState([]),
    f = R.useRef(),
    c = () => {
      f.current && (clearTimeout(f.current), (f.current = null))
    },
    p = () => {
      c(),
        (f.current = setTimeout(() => {
          l([]), (f.current = null)
        }, r))
    }
  R.useEffect(() => c, [])
  function h(m) {
    return (g) => {
      if (g.key === 'Backspace') {
        const b = [...o]
        b.pop(), l(b)
        return
      }
      if (fK(g)) {
        const b = o.concat(g.key)
        a(g) && (g.preventDefault(), g.stopPropagation()), l(b), m(b.join('')), p()
      }
    }
  }
  return h
}
function pK(t, r, a, o) {
  if (r == null) return o
  if (!o) return t.find((c) => a(c).toLowerCase().startsWith(r.toLowerCase()))
  const l = t.filter((f) => a(f).toLowerCase().startsWith(r.toLowerCase()))
  if (l.length > 0) {
    let f
    return l.includes(o)
      ? ((f = l.indexOf(o) + 1), f === l.length && (f = 0), l[f])
      : ((f = t.indexOf(l[0])), t[f])
  }
  return o
}
function hK() {
  const t = R.useRef(new Map()),
    r = t.current,
    a = R.useCallback((l, f, c, p) => {
      t.current.set(c, { type: f, el: l, options: p }), l.addEventListener(f, c, p)
    }, []),
    o = R.useCallback((l, f, c, p) => {
      l.removeEventListener(f, c, p), t.current.delete(c)
    }, [])
  return (
    R.useEffect(
      () => () => {
        r.forEach((l, f) => {
          o(l.el, l.type, f, l.options)
        })
      },
      [o, r]
    ),
    { add: a, remove: o }
  )
}
function mS(t) {
  const r = t.target,
    { tagName: a, isContentEditable: o } = r
  return a !== 'INPUT' && a !== 'TEXTAREA' && o !== !0
}
function mK(t = {}) {
  const {
      ref: r,
      isDisabled: a,
      isFocusable: o,
      clickOnEnter: l = !0,
      clickOnSpace: f = !0,
      onMouseDown: c,
      onMouseUp: p,
      onClick: h,
      onKeyDown: m,
      onKeyUp: g,
      tabIndex: b,
      onMouseOver: C,
      onMouseLeave: w,
      ...k
    } = t,
    [D, E] = R.useState(!0),
    [M, z] = R.useState(!1),
    P = hK(),
    B = (ee) => {
      ee && ee.tagName !== 'BUTTON' && E(!1)
    },
    j = D ? b : b || 0,
    Q = a && !o,
    Y = R.useCallback(
      (ee) => {
        if (a) {
          ee.stopPropagation(), ee.preventDefault()
          return
        }
        ee.currentTarget.focus(), h == null || h(ee)
      },
      [a, h]
    ),
    ne = R.useCallback(
      (ee) => {
        M &&
          mS(ee) &&
          (ee.preventDefault(), ee.stopPropagation(), z(!1), P.remove(document, 'keyup', ne, !1))
      },
      [M, P]
    ),
    he = R.useCallback(
      (ee) => {
        if (
          (m == null || m(ee), a || ee.defaultPrevented || ee.metaKey || !mS(ee.nativeEvent) || D)
        )
          return
        const ut = l && ee.key === 'Enter'
        f && ee.key === ' ' && (ee.preventDefault(), z(!0)),
          ut && (ee.preventDefault(), ee.currentTarget.click()),
          P.add(document, 'keyup', ne, !1)
      },
      [a, D, m, l, f, P, ne]
    ),
    le = R.useCallback(
      (ee) => {
        if (
          (g == null || g(ee), a || ee.defaultPrevented || ee.metaKey || !mS(ee.nativeEvent) || D)
        )
          return
        f && ee.key === ' ' && (ee.preventDefault(), z(!1), ee.currentTarget.click())
      },
      [f, D, a, g]
    ),
    pe = R.useCallback(
      (ee) => {
        ee.button === 0 && (z(!1), P.remove(document, 'mouseup', pe, !1))
      },
      [P]
    ),
    Ne = R.useCallback(
      (ee) => {
        if (ee.button !== 0) return
        if (a) {
          ee.stopPropagation(), ee.preventDefault()
          return
        }
        D || z(!0),
          ee.currentTarget.focus({ preventScroll: !0 }),
          P.add(document, 'mouseup', pe, !1),
          c == null || c(ee)
      },
      [a, D, c, P, pe]
    ),
    me = R.useCallback(
      (ee) => {
        ee.button === 0 && (D || z(!1), p == null || p(ee))
      },
      [p, D]
    ),
    ge = R.useCallback(
      (ee) => {
        if (a) {
          ee.preventDefault()
          return
        }
        C == null || C(ee)
      },
      [a, C]
    ),
    Oe = R.useCallback(
      (ee) => {
        M && (ee.preventDefault(), z(!1)), w == null || w(ee)
      },
      [M, w]
    ),
    ze = Os(r, B)
  return D
    ? {
        ...k,
        'ref': ze,
        'type': 'button',
        'aria-disabled': Q ? void 0 : a,
        'disabled': Q,
        'onClick': Y,
        'onMouseDown': c,
        'onMouseUp': p,
        'onKeyUp': g,
        'onKeyDown': m,
        'onMouseOver': C,
        'onMouseLeave': w,
      }
    : {
        ...k,
        'ref': ze,
        'role': 'button',
        'data-active': Um(M),
        'aria-disabled': a ? 'true' : void 0,
        'tabIndex': Q ? void 0 : j,
        'onClick': Y,
        'onMouseDown': Ne,
        'onMouseUp': me,
        'onKeyUp': le,
        'onKeyDown': he,
        'onMouseOver': ge,
        'onMouseLeave': Oe,
      }
}
function vK(t) {
  const r = t.current
  if (!r) return !1
  const a = Qq(r)
  return !a || r.contains(a) ? !1 : !!nK(a)
}
function gK(t, r) {
  const { shouldFocus: a, visible: o, focusRef: l } = r,
    f = a && !o
  zd(() => {
    if (!f || vK(t)) return
    const c = (l == null ? void 0 : l.current) || t.current
    c &&
      requestAnimationFrame(() => {
        c.focus()
      })
  }, [f, t, l])
}
var Uu = (t, r) => ({ var: t, varRef: r ? `var(${t}, ${r})` : `var(${t})` }),
  Da = {
    arrowShadowColor: Uu('--popper-arrow-shadow-color'),
    arrowSize: Uu('--popper-arrow-size', '8px'),
    arrowSizeHalf: Uu('--popper-arrow-size-half'),
    arrowBg: Uu('--popper-arrow-bg'),
    transformOrigin: Uu('--popper-transform-origin'),
    arrowOffset: Uu('--popper-arrow-offset'),
  }
function yK(t) {
  if (t.includes('top')) return '1px 1px 1px 0 var(--popper-arrow-shadow-color)'
  if (t.includes('bottom')) return '-1px -1px 1px 0 var(--popper-arrow-shadow-color)'
  if (t.includes('right')) return '-1px 1px 1px 0 var(--popper-arrow-shadow-color)'
  if (t.includes('left')) return '1px -1px 1px 0 var(--popper-arrow-shadow-color)'
}
var bK = {
    'top': 'bottom center',
    'top-start': 'bottom left',
    'top-end': 'bottom right',
    'bottom': 'top center',
    'bottom-start': 'top left',
    'bottom-end': 'top right',
    'left': 'right center',
    'left-start': 'right top',
    'left-end': 'right bottom',
    'right': 'left center',
    'right-start': 'left top',
    'right-end': 'left bottom',
  },
  SK = (t) => bK[t],
  Ik = { scroll: !0, resize: !0 }
function xK(t) {
  let r
  return (
    typeof t == 'object'
      ? (r = { enabled: !0, options: { ...Ik, ...t } })
      : (r = { enabled: t, options: Ik }),
    r
  )
}
var CK = {
    name: 'matchWidth',
    enabled: !0,
    phase: 'beforeWrite',
    requires: ['computeStyles'],
    fn: ({ state: t }) => {
      t.styles.popper.width = `${t.rects.reference.width}px`
    },
    effect:
      ({ state: t }) =>
      () => {
        const r = t.elements.reference
        t.elements.popper.style.width = `${r.offsetWidth}px`
      },
  },
  wK = {
    name: 'transformOrigin',
    enabled: !0,
    phase: 'write',
    fn: ({ state: t }) => {
      Hk(t)
    },
    effect:
      ({ state: t }) =>
      () => {
        Hk(t)
      },
  },
  Hk = (t) => {
    t.elements.popper.style.setProperty(Da.transformOrigin.var, SK(t.placement))
  },
  EK = {
    name: 'positionArrow',
    enabled: !0,
    phase: 'afterWrite',
    fn: ({ state: t }) => {
      TK(t)
    },
  },
  TK = (t) => {
    var r
    if (!t.placement) return
    const a = RK(t.placement)
    if ((r = t.elements) != null && r.arrow && a) {
      Object.assign(t.elements.arrow.style, {
        [a.property]: a.value,
        width: Da.arrowSize.varRef,
        height: Da.arrowSize.varRef,
        zIndex: -1,
      })
      const o = {
        [Da.arrowSizeHalf.var]: `calc(${Da.arrowSize.varRef} / 2)`,
        [Da.arrowOffset.var]: `calc(${Da.arrowSizeHalf.varRef} * -1)`,
      }
      for (const l in o) t.elements.arrow.style.setProperty(l, o[l])
    }
  },
  RK = (t) => {
    if (t.startsWith('top')) return { property: 'bottom', value: Da.arrowOffset.varRef }
    if (t.startsWith('bottom')) return { property: 'top', value: Da.arrowOffset.varRef }
    if (t.startsWith('left')) return { property: 'right', value: Da.arrowOffset.varRef }
    if (t.startsWith('right')) return { property: 'left', value: Da.arrowOffset.varRef }
  },
  _K = {
    name: 'innerArrow',
    enabled: !0,
    phase: 'main',
    requires: ['arrow'],
    fn: ({ state: t }) => {
      Wk(t)
    },
    effect:
      ({ state: t }) =>
      () => {
        Wk(t)
      },
  },
  Wk = (t) => {
    if (!t.elements.arrow) return
    const r = t.elements.arrow.querySelector('[data-popper-arrow-inner]')
    if (!r) return
    const a = yK(t.placement)
    a && r.style.setProperty('--popper-arrow-default-shadow', a),
      Object.assign(r.style, {
        transform: 'rotate(45deg)',
        background: Da.arrowBg.varRef,
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        position: 'absolute',
        zIndex: 'inherit',
        boxShadow: 'var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))',
      })
  },
  kK = {
    'start-start': { ltr: 'left-start', rtl: 'right-start' },
    'start-end': { ltr: 'left-end', rtl: 'right-end' },
    'end-start': { ltr: 'right-start', rtl: 'left-start' },
    'end-end': { ltr: 'right-end', rtl: 'left-end' },
    'start': { ltr: 'left', rtl: 'right' },
    'end': { ltr: 'right', rtl: 'left' },
  },
  DK = {
    'auto-start': 'auto-end',
    'auto-end': 'auto-start',
    'top-start': 'top-end',
    'top-end': 'top-start',
    'bottom-start': 'bottom-end',
    'bottom-end': 'bottom-start',
  }
function AK(t, r = 'ltr') {
  var a, o
  const l = ((a = kK[t]) == null ? void 0 : a[r]) || t
  return r === 'ltr' ? l : (o = DK[t]) != null ? o : l
}
var fa = 'top',
  Ga = 'bottom',
  qa = 'right',
  da = 'left',
  Av = 'auto',
  np = [fa, Ga, qa, da],
  sc = 'start',
  Id = 'end',
  OK = 'clippingParents',
  iM = 'viewport',
  td = 'popper',
  MK = 'reference',
  Yk = np.reduce(function (t, r) {
    return t.concat([r + '-' + sc, r + '-' + Id])
  }, []),
  oM = [].concat(np, [Av]).reduce(function (t, r) {
    return t.concat([r, r + '-' + sc, r + '-' + Id])
  }, []),
  PK = 'beforeRead',
  LK = 'read',
  zK = 'afterRead',
  $K = 'beforeMain',
  FK = 'main',
  NK = 'afterMain',
  BK = 'beforeWrite',
  jK = 'write',
  UK = 'afterWrite',
  ix = [PK, LK, zK, $K, FK, NK, BK, jK, UK]
function qi(t) {
  return t ? (t.nodeName || '').toLowerCase() : null
}
function La(t) {
  if (t == null) return window
  if (t.toString() !== '[object Window]') {
    var r = t.ownerDocument
    return (r && r.defaultView) || window
  }
  return t
}
function zl(t) {
  var r = La(t).Element
  return t instanceof r || t instanceof Element
}
function Ma(t) {
  var r = La(t).HTMLElement
  return t instanceof r || t instanceof HTMLElement
}
function aC(t) {
  if (typeof ShadowRoot > 'u') return !1
  var r = La(t).ShadowRoot
  return t instanceof r || t instanceof ShadowRoot
}
function VK(t) {
  var r = t.state
  Object.keys(r.elements).forEach(function (a) {
    var o = r.styles[a] || {},
      l = r.attributes[a] || {},
      f = r.elements[a]
    !Ma(f) ||
      !qi(f) ||
      (Object.assign(f.style, o),
      Object.keys(l).forEach(function (c) {
        var p = l[c]
        p === !1 ? f.removeAttribute(c) : f.setAttribute(c, p === !0 ? '' : p)
      }))
  })
}
function IK(t) {
  var r = t.state,
    a = {
      popper: { position: r.options.strategy, left: '0', top: '0', margin: '0' },
      arrow: { position: 'absolute' },
      reference: {},
    }
  return (
    Object.assign(r.elements.popper.style, a.popper),
    (r.styles = a),
    r.elements.arrow && Object.assign(r.elements.arrow.style, a.arrow),
    function () {
      Object.keys(r.elements).forEach(function (o) {
        var l = r.elements[o],
          f = r.attributes[o] || {},
          c = Object.keys(r.styles.hasOwnProperty(o) ? r.styles[o] : a[o]),
          p = c.reduce(function (h, m) {
            return (h[m] = ''), h
          }, {})
        !Ma(l) ||
          !qi(l) ||
          (Object.assign(l.style, p),
          Object.keys(f).forEach(function (h) {
            l.removeAttribute(h)
          }))
      })
    }
  )
}
const HK = {
  name: 'applyStyles',
  enabled: !0,
  phase: 'write',
  fn: VK,
  effect: IK,
  requires: ['computeStyles'],
}
function hi(t) {
  return t.split('-')[0]
}
var Pl = Math.max,
  av = Math.min,
  lc = Math.round
function ox() {
  var t = navigator.userAgentData
  return t != null && t.brands && Array.isArray(t.brands)
    ? t.brands
        .map(function (r) {
          return r.brand + '/' + r.version
        })
        .join(' ')
    : navigator.userAgent
}
function sM() {
  return !/^((?!chrome|android).)*safari/i.test(ox())
}
function uc(t, r, a) {
  r === void 0 && (r = !1), a === void 0 && (a = !1)
  var o = t.getBoundingClientRect(),
    l = 1,
    f = 1
  r &&
    Ma(t) &&
    ((l = (t.offsetWidth > 0 && lc(o.width) / t.offsetWidth) || 1),
    (f = (t.offsetHeight > 0 && lc(o.height) / t.offsetHeight) || 1))
  var c = zl(t) ? La(t) : window,
    p = c.visualViewport,
    h = !sM() && a,
    m = (o.left + (h && p ? p.offsetLeft : 0)) / l,
    g = (o.top + (h && p ? p.offsetTop : 0)) / f,
    b = o.width / l,
    C = o.height / f
  return { width: b, height: C, top: g, right: m + b, bottom: g + C, left: m, x: m, y: g }
}
function iC(t) {
  var r = uc(t),
    a = t.offsetWidth,
    o = t.offsetHeight
  return (
    Math.abs(r.width - a) <= 1 && (a = r.width),
    Math.abs(r.height - o) <= 1 && (o = r.height),
    { x: t.offsetLeft, y: t.offsetTop, width: a, height: o }
  )
}
function lM(t, r) {
  var a = r.getRootNode && r.getRootNode()
  if (t.contains(r)) return !0
  if (a && aC(a)) {
    var o = r
    do {
      if (o && t.isSameNode(o)) return !0
      o = o.parentNode || o.host
    } while (o)
  }
  return !1
}
function gi(t) {
  return La(t).getComputedStyle(t)
}
function WK(t) {
  return ['table', 'td', 'th'].indexOf(qi(t)) >= 0
}
function zs(t) {
  return ((zl(t) ? t.ownerDocument : t.document) || window.document).documentElement
}
function Ov(t) {
  return qi(t) === 'html' ? t : t.assignedSlot || t.parentNode || (aC(t) ? t.host : null) || zs(t)
}
function Gk(t) {
  return !Ma(t) || gi(t).position === 'fixed' ? null : t.offsetParent
}
function YK(t) {
  var r = /firefox/i.test(ox()),
    a = /Trident/i.test(ox())
  if (a && Ma(t)) {
    var o = gi(t)
    if (o.position === 'fixed') return null
  }
  var l = Ov(t)
  for (aC(l) && (l = l.host); Ma(l) && ['html', 'body'].indexOf(qi(l)) < 0; ) {
    var f = gi(l)
    if (
      f.transform !== 'none' ||
      f.perspective !== 'none' ||
      f.contain === 'paint' ||
      ['transform', 'perspective'].indexOf(f.willChange) !== -1 ||
      (r && f.willChange === 'filter') ||
      (r && f.filter && f.filter !== 'none')
    )
      return l
    l = l.parentNode
  }
  return null
}
function rp(t) {
  for (var r = La(t), a = Gk(t); a && WK(a) && gi(a).position === 'static'; ) a = Gk(a)
  return a && (qi(a) === 'html' || (qi(a) === 'body' && gi(a).position === 'static'))
    ? r
    : a || YK(t) || r
}
function oC(t) {
  return ['top', 'bottom'].indexOf(t) >= 0 ? 'x' : 'y'
}
function xd(t, r, a) {
  return Pl(t, av(r, a))
}
function GK(t, r, a) {
  var o = xd(t, r, a)
  return o > a ? a : o
}
function uM() {
  return { top: 0, right: 0, bottom: 0, left: 0 }
}
function cM(t) {
  return Object.assign({}, uM(), t)
}
function fM(t, r) {
  return r.reduce(function (a, o) {
    return (a[o] = t), a
  }, {})
}
var qK = function (r, a) {
  return (
    (r = typeof r == 'function' ? r(Object.assign({}, a.rects, { placement: a.placement })) : r),
    cM(typeof r != 'number' ? r : fM(r, np))
  )
}
function KK(t) {
  var r,
    a = t.state,
    o = t.name,
    l = t.options,
    f = a.elements.arrow,
    c = a.modifiersData.popperOffsets,
    p = hi(a.placement),
    h = oC(p),
    m = [da, qa].indexOf(p) >= 0,
    g = m ? 'height' : 'width'
  if (!(!f || !c)) {
    var b = qK(l.padding, a),
      C = iC(f),
      w = h === 'y' ? fa : da,
      k = h === 'y' ? Ga : qa,
      D = a.rects.reference[g] + a.rects.reference[h] - c[h] - a.rects.popper[g],
      E = c[h] - a.rects.reference[h],
      M = rp(f),
      z = M ? (h === 'y' ? M.clientHeight || 0 : M.clientWidth || 0) : 0,
      P = D / 2 - E / 2,
      B = b[w],
      j = z - C[g] - b[k],
      Q = z / 2 - C[g] / 2 + P,
      Y = xd(B, Q, j),
      ne = h
    a.modifiersData[o] = ((r = {}), (r[ne] = Y), (r.centerOffset = Y - Q), r)
  }
}
function XK(t) {
  var r = t.state,
    a = t.options,
    o = a.element,
    l = o === void 0 ? '[data-popper-arrow]' : o
  if (l != null && !(typeof l == 'string' && ((l = r.elements.popper.querySelector(l)), !l))) {
    if (
      (Ma(l) ||
        console.error(
          [
            'Popper: "arrow" element must be an HTMLElement (not an SVGElement).',
            'To use an SVG arrow, wrap it in an HTMLElement that will be used as',
            'the arrow.',
          ].join(' ')
        ),
      !lM(r.elements.popper, l))
    ) {
      console.error(
        ['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(
          ' '
        )
      )
      return
    }
    r.elements.arrow = l
  }
}
const QK = {
  name: 'arrow',
  enabled: !0,
  phase: 'main',
  fn: KK,
  effect: XK,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow'],
}
function cc(t) {
  return t.split('-')[1]
}
var ZK = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }
function JK(t, r) {
  var a = t.x,
    o = t.y,
    l = r.devicePixelRatio || 1
  return { x: lc(a * l) / l || 0, y: lc(o * l) / l || 0 }
}
function qk(t) {
  var r,
    a = t.popper,
    o = t.popperRect,
    l = t.placement,
    f = t.variation,
    c = t.offsets,
    p = t.position,
    h = t.gpuAcceleration,
    m = t.adaptive,
    g = t.roundOffsets,
    b = t.isFixed,
    C = c.x,
    w = C === void 0 ? 0 : C,
    k = c.y,
    D = k === void 0 ? 0 : k,
    E = typeof g == 'function' ? g({ x: w, y: D }) : { x: w, y: D }
  ;(w = E.x), (D = E.y)
  var M = c.hasOwnProperty('x'),
    z = c.hasOwnProperty('y'),
    P = da,
    B = fa,
    j = window
  if (m) {
    var Q = rp(a),
      Y = 'clientHeight',
      ne = 'clientWidth'
    if (
      (Q === La(a) &&
        ((Q = zs(a)),
        gi(Q).position !== 'static' &&
          p === 'absolute' &&
          ((Y = 'scrollHeight'), (ne = 'scrollWidth'))),
      (Q = Q),
      l === fa || ((l === da || l === qa) && f === Id))
    ) {
      B = Ga
      var he = b && Q === j && j.visualViewport ? j.visualViewport.height : Q[Y]
      ;(D -= he - o.height), (D *= h ? 1 : -1)
    }
    if (l === da || ((l === fa || l === Ga) && f === Id)) {
      P = qa
      var le = b && Q === j && j.visualViewport ? j.visualViewport.width : Q[ne]
      ;(w -= le - o.width), (w *= h ? 1 : -1)
    }
  }
  var pe = Object.assign({ position: p }, m && ZK),
    Ne = g === !0 ? JK({ x: w, y: D }, La(a)) : { x: w, y: D }
  if (((w = Ne.x), (D = Ne.y), h)) {
    var me
    return Object.assign(
      {},
      pe,
      ((me = {}),
      (me[B] = z ? '0' : ''),
      (me[P] = M ? '0' : ''),
      (me.transform =
        (j.devicePixelRatio || 1) <= 1
          ? 'translate(' + w + 'px, ' + D + 'px)'
          : 'translate3d(' + w + 'px, ' + D + 'px, 0)'),
      me)
    )
  }
  return Object.assign(
    {},
    pe,
    ((r = {}), (r[B] = z ? D + 'px' : ''), (r[P] = M ? w + 'px' : ''), (r.transform = ''), r)
  )
}
function eX(t) {
  var r = t.state,
    a = t.options,
    o = a.gpuAcceleration,
    l = o === void 0 ? !0 : o,
    f = a.adaptive,
    c = f === void 0 ? !0 : f,
    p = a.roundOffsets,
    h = p === void 0 ? !0 : p
  {
    var m = gi(r.elements.popper).transitionProperty || ''
    c &&
      ['transform', 'top', 'right', 'bottom', 'left'].some(function (b) {
        return m.indexOf(b) >= 0
      }) &&
      console.warn(
        [
          'Popper: Detected CSS transitions on at least one of the following',
          'CSS properties: "transform", "top", "right", "bottom", "left".',
          `

`,
          'Disable the "computeStyles" modifier\'s `adaptive` option to allow',
          'for smooth transitions, or remove these properties from the CSS',
          'transition declaration on the popper element if only transitioning',
          'opacity or background-color for example.',
          `

`,
          'We recommend using the popper element as a wrapper around an inner',
          'element that can have any CSS property transitioned for animations.',
        ].join(' ')
      )
  }
  var g = {
    placement: hi(r.placement),
    variation: cc(r.placement),
    popper: r.elements.popper,
    popperRect: r.rects.popper,
    gpuAcceleration: l,
    isFixed: r.options.strategy === 'fixed',
  }
  r.modifiersData.popperOffsets != null &&
    (r.styles.popper = Object.assign(
      {},
      r.styles.popper,
      qk(
        Object.assign({}, g, {
          offsets: r.modifiersData.popperOffsets,
          position: r.options.strategy,
          adaptive: c,
          roundOffsets: h,
        })
      )
    )),
    r.modifiersData.arrow != null &&
      (r.styles.arrow = Object.assign(
        {},
        r.styles.arrow,
        qk(
          Object.assign({}, g, {
            offsets: r.modifiersData.arrow,
            position: 'absolute',
            adaptive: !1,
            roundOffsets: h,
          })
        )
      )),
    (r.attributes.popper = Object.assign({}, r.attributes.popper, {
      'data-popper-placement': r.placement,
    }))
}
const tX = { name: 'computeStyles', enabled: !0, phase: 'beforeWrite', fn: eX, data: {} }
var Cm = { passive: !0 }
function nX(t) {
  var r = t.state,
    a = t.instance,
    o = t.options,
    l = o.scroll,
    f = l === void 0 ? !0 : l,
    c = o.resize,
    p = c === void 0 ? !0 : c,
    h = La(r.elements.popper),
    m = [].concat(r.scrollParents.reference, r.scrollParents.popper)
  return (
    f &&
      m.forEach(function (g) {
        g.addEventListener('scroll', a.update, Cm)
      }),
    p && h.addEventListener('resize', a.update, Cm),
    function () {
      f &&
        m.forEach(function (g) {
          g.removeEventListener('scroll', a.update, Cm)
        }),
        p && h.removeEventListener('resize', a.update, Cm)
    }
  )
}
const rX = {
  name: 'eventListeners',
  enabled: !0,
  phase: 'write',
  fn: function () {},
  effect: nX,
  data: {},
}
var aX = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }
function zm(t) {
  return t.replace(/left|right|bottom|top/g, function (r) {
    return aX[r]
  })
}
var iX = { start: 'end', end: 'start' }
function Kk(t) {
  return t.replace(/start|end/g, function (r) {
    return iX[r]
  })
}
function sC(t) {
  var r = La(t),
    a = r.pageXOffset,
    o = r.pageYOffset
  return { scrollLeft: a, scrollTop: o }
}
function lC(t) {
  return uc(zs(t)).left + sC(t).scrollLeft
}
function oX(t, r) {
  var a = La(t),
    o = zs(t),
    l = a.visualViewport,
    f = o.clientWidth,
    c = o.clientHeight,
    p = 0,
    h = 0
  if (l) {
    ;(f = l.width), (c = l.height)
    var m = sM()
    ;(m || (!m && r === 'fixed')) && ((p = l.offsetLeft), (h = l.offsetTop))
  }
  return { width: f, height: c, x: p + lC(t), y: h }
}
function sX(t) {
  var r,
    a = zs(t),
    o = sC(t),
    l = (r = t.ownerDocument) == null ? void 0 : r.body,
    f = Pl(a.scrollWidth, a.clientWidth, l ? l.scrollWidth : 0, l ? l.clientWidth : 0),
    c = Pl(a.scrollHeight, a.clientHeight, l ? l.scrollHeight : 0, l ? l.clientHeight : 0),
    p = -o.scrollLeft + lC(t),
    h = -o.scrollTop
  return (
    gi(l || a).direction === 'rtl' && (p += Pl(a.clientWidth, l ? l.clientWidth : 0) - f),
    { width: f, height: c, x: p, y: h }
  )
}
function uC(t) {
  var r = gi(t),
    a = r.overflow,
    o = r.overflowX,
    l = r.overflowY
  return /auto|scroll|overlay|hidden/.test(a + l + o)
}
function dM(t) {
  return ['html', 'body', '#document'].indexOf(qi(t)) >= 0
    ? t.ownerDocument.body
    : Ma(t) && uC(t)
    ? t
    : dM(Ov(t))
}
function Cd(t, r) {
  var a
  r === void 0 && (r = [])
  var o = dM(t),
    l = o === ((a = t.ownerDocument) == null ? void 0 : a.body),
    f = La(o),
    c = l ? [f].concat(f.visualViewport || [], uC(o) ? o : []) : o,
    p = r.concat(c)
  return l ? p : p.concat(Cd(Ov(c)))
}
function sx(t) {
  return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height })
}
function lX(t, r) {
  var a = uc(t, !1, r === 'fixed')
  return (
    (a.top = a.top + t.clientTop),
    (a.left = a.left + t.clientLeft),
    (a.bottom = a.top + t.clientHeight),
    (a.right = a.left + t.clientWidth),
    (a.width = t.clientWidth),
    (a.height = t.clientHeight),
    (a.x = a.left),
    (a.y = a.top),
    a
  )
}
function Xk(t, r, a) {
  return r === iM ? sx(oX(t, a)) : zl(r) ? lX(r, a) : sx(sX(zs(t)))
}
function uX(t) {
  var r = Cd(Ov(t)),
    a = ['absolute', 'fixed'].indexOf(gi(t).position) >= 0,
    o = a && Ma(t) ? rp(t) : t
  return zl(o)
    ? r.filter(function (l) {
        return zl(l) && lM(l, o) && qi(l) !== 'body'
      })
    : []
}
function cX(t, r, a, o) {
  var l = r === 'clippingParents' ? uX(t) : [].concat(r),
    f = [].concat(l, [a]),
    c = f[0],
    p = f.reduce(function (h, m) {
      var g = Xk(t, m, o)
      return (
        (h.top = Pl(g.top, h.top)),
        (h.right = av(g.right, h.right)),
        (h.bottom = av(g.bottom, h.bottom)),
        (h.left = Pl(g.left, h.left)),
        h
      )
    }, Xk(t, c, o))
  return (
    (p.width = p.right - p.left), (p.height = p.bottom - p.top), (p.x = p.left), (p.y = p.top), p
  )
}
function pM(t) {
  var r = t.reference,
    a = t.element,
    o = t.placement,
    l = o ? hi(o) : null,
    f = o ? cc(o) : null,
    c = r.x + r.width / 2 - a.width / 2,
    p = r.y + r.height / 2 - a.height / 2,
    h
  switch (l) {
    case fa:
      h = { x: c, y: r.y - a.height }
      break
    case Ga:
      h = { x: c, y: r.y + r.height }
      break
    case qa:
      h = { x: r.x + r.width, y: p }
      break
    case da:
      h = { x: r.x - a.width, y: p }
      break
    default:
      h = { x: r.x, y: r.y }
  }
  var m = l ? oC(l) : null
  if (m != null) {
    var g = m === 'y' ? 'height' : 'width'
    switch (f) {
      case sc:
        h[m] = h[m] - (r[g] / 2 - a[g] / 2)
        break
      case Id:
        h[m] = h[m] + (r[g] / 2 - a[g] / 2)
        break
    }
  }
  return h
}
function Hd(t, r) {
  r === void 0 && (r = {})
  var a = r,
    o = a.placement,
    l = o === void 0 ? t.placement : o,
    f = a.strategy,
    c = f === void 0 ? t.strategy : f,
    p = a.boundary,
    h = p === void 0 ? OK : p,
    m = a.rootBoundary,
    g = m === void 0 ? iM : m,
    b = a.elementContext,
    C = b === void 0 ? td : b,
    w = a.altBoundary,
    k = w === void 0 ? !1 : w,
    D = a.padding,
    E = D === void 0 ? 0 : D,
    M = cM(typeof E != 'number' ? E : fM(E, np)),
    z = C === td ? MK : td,
    P = t.rects.popper,
    B = t.elements[k ? z : C],
    j = cX(zl(B) ? B : B.contextElement || zs(t.elements.popper), h, g, c),
    Q = uc(t.elements.reference),
    Y = pM({ reference: Q, element: P, strategy: 'absolute', placement: l }),
    ne = sx(Object.assign({}, P, Y)),
    he = C === td ? ne : Q,
    le = {
      top: j.top - he.top + M.top,
      bottom: he.bottom - j.bottom + M.bottom,
      left: j.left - he.left + M.left,
      right: he.right - j.right + M.right,
    },
    pe = t.modifiersData.offset
  if (C === td && pe) {
    var Ne = pe[l]
    Object.keys(le).forEach(function (me) {
      var ge = [qa, Ga].indexOf(me) >= 0 ? 1 : -1,
        Oe = [fa, Ga].indexOf(me) >= 0 ? 'y' : 'x'
      le[me] += Ne[Oe] * ge
    })
  }
  return le
}
function fX(t, r) {
  r === void 0 && (r = {})
  var a = r,
    o = a.placement,
    l = a.boundary,
    f = a.rootBoundary,
    c = a.padding,
    p = a.flipVariations,
    h = a.allowedAutoPlacements,
    m = h === void 0 ? oM : h,
    g = cc(o),
    b = g
      ? p
        ? Yk
        : Yk.filter(function (k) {
            return cc(k) === g
          })
      : np,
    C = b.filter(function (k) {
      return m.indexOf(k) >= 0
    })
  C.length === 0 &&
    ((C = b),
    console.error(
      [
        'Popper: The `allowedAutoPlacements` option did not allow any',
        'placements. Ensure the `placement` option matches the variation',
        'of the allowed placements.',
        'For example, "auto" cannot be used to allow "bottom-start".',
        'Use "auto-start" instead.',
      ].join(' ')
    ))
  var w = C.reduce(function (k, D) {
    return (k[D] = Hd(t, { placement: D, boundary: l, rootBoundary: f, padding: c })[hi(D)]), k
  }, {})
  return Object.keys(w).sort(function (k, D) {
    return w[k] - w[D]
  })
}
function dX(t) {
  if (hi(t) === Av) return []
  var r = zm(t)
  return [Kk(t), r, Kk(r)]
}
function pX(t) {
  var r = t.state,
    a = t.options,
    o = t.name
  if (!r.modifiersData[o]._skip) {
    for (
      var l = a.mainAxis,
        f = l === void 0 ? !0 : l,
        c = a.altAxis,
        p = c === void 0 ? !0 : c,
        h = a.fallbackPlacements,
        m = a.padding,
        g = a.boundary,
        b = a.rootBoundary,
        C = a.altBoundary,
        w = a.flipVariations,
        k = w === void 0 ? !0 : w,
        D = a.allowedAutoPlacements,
        E = r.options.placement,
        M = hi(E),
        z = M === E,
        P = h || (z || !k ? [zm(E)] : dX(E)),
        B = [E].concat(P).reduce(function (Ke, Mt) {
          return Ke.concat(
            hi(Mt) === Av
              ? fX(r, {
                  placement: Mt,
                  boundary: g,
                  rootBoundary: b,
                  padding: m,
                  flipVariations: k,
                  allowedAutoPlacements: D,
                })
              : Mt
          )
        }, []),
        j = r.rects.reference,
        Q = r.rects.popper,
        Y = new Map(),
        ne = !0,
        he = B[0],
        le = 0;
      le < B.length;
      le++
    ) {
      var pe = B[le],
        Ne = hi(pe),
        me = cc(pe) === sc,
        ge = [fa, Ga].indexOf(Ne) >= 0,
        Oe = ge ? 'width' : 'height',
        ze = Hd(r, { placement: pe, boundary: g, rootBoundary: b, altBoundary: C, padding: m }),
        ee = ge ? (me ? qa : da) : me ? Ga : fa
      j[Oe] > Q[Oe] && (ee = zm(ee))
      var ut = zm(ee),
        Bt = []
      if (
        (f && Bt.push(ze[Ne] <= 0),
        p && Bt.push(ze[ee] <= 0, ze[ut] <= 0),
        Bt.every(function (Ke) {
          return Ke
        }))
      ) {
        ;(he = pe), (ne = !1)
        break
      }
      Y.set(pe, Bt)
    }
    if (ne)
      for (
        var rt = k ? 3 : 1,
          qe = function (Mt) {
            var Rt = B.find(function (an) {
              var _t = Y.get(an)
              if (_t)
                return _t.slice(0, Mt).every(function (zt) {
                  return zt
                })
            })
            if (Rt) return (he = Rt), 'break'
          },
          vt = rt;
        vt > 0;
        vt--
      ) {
        var Pe = qe(vt)
        if (Pe === 'break') break
      }
    r.placement !== he && ((r.modifiersData[o]._skip = !0), (r.placement = he), (r.reset = !0))
  }
}
const hX = {
  name: 'flip',
  enabled: !0,
  phase: 'main',
  fn: pX,
  requiresIfExists: ['offset'],
  data: { _skip: !1 },
}
function Qk(t, r, a) {
  return (
    a === void 0 && (a = { x: 0, y: 0 }),
    {
      top: t.top - r.height - a.y,
      right: t.right - r.width + a.x,
      bottom: t.bottom - r.height + a.y,
      left: t.left - r.width - a.x,
    }
  )
}
function Zk(t) {
  return [fa, qa, Ga, da].some(function (r) {
    return t[r] >= 0
  })
}
function mX(t) {
  var r = t.state,
    a = t.name,
    o = r.rects.reference,
    l = r.rects.popper,
    f = r.modifiersData.preventOverflow,
    c = Hd(r, { elementContext: 'reference' }),
    p = Hd(r, { altBoundary: !0 }),
    h = Qk(c, o),
    m = Qk(p, l, f),
    g = Zk(h),
    b = Zk(m)
  ;(r.modifiersData[a] = {
    referenceClippingOffsets: h,
    popperEscapeOffsets: m,
    isReferenceHidden: g,
    hasPopperEscaped: b,
  }),
    (r.attributes.popper = Object.assign({}, r.attributes.popper, {
      'data-popper-reference-hidden': g,
      'data-popper-escaped': b,
    }))
}
const vX = {
  name: 'hide',
  enabled: !0,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: mX,
}
function gX(t, r, a) {
  var o = hi(t),
    l = [da, fa].indexOf(o) >= 0 ? -1 : 1,
    f = typeof a == 'function' ? a(Object.assign({}, r, { placement: t })) : a,
    c = f[0],
    p = f[1]
  return (
    (c = c || 0), (p = (p || 0) * l), [da, qa].indexOf(o) >= 0 ? { x: p, y: c } : { x: c, y: p }
  )
}
function yX(t) {
  var r = t.state,
    a = t.options,
    o = t.name,
    l = a.offset,
    f = l === void 0 ? [0, 0] : l,
    c = oM.reduce(function (g, b) {
      return (g[b] = gX(b, r.rects, f)), g
    }, {}),
    p = c[r.placement],
    h = p.x,
    m = p.y
  r.modifiersData.popperOffsets != null &&
    ((r.modifiersData.popperOffsets.x += h), (r.modifiersData.popperOffsets.y += m)),
    (r.modifiersData[o] = c)
}
const bX = { name: 'offset', enabled: !0, phase: 'main', requires: ['popperOffsets'], fn: yX }
function SX(t) {
  var r = t.state,
    a = t.name
  r.modifiersData[a] = pM({
    reference: r.rects.reference,
    element: r.rects.popper,
    strategy: 'absolute',
    placement: r.placement,
  })
}
const xX = { name: 'popperOffsets', enabled: !0, phase: 'read', fn: SX, data: {} }
function CX(t) {
  return t === 'x' ? 'y' : 'x'
}
function wX(t) {
  var r = t.state,
    a = t.options,
    o = t.name,
    l = a.mainAxis,
    f = l === void 0 ? !0 : l,
    c = a.altAxis,
    p = c === void 0 ? !1 : c,
    h = a.boundary,
    m = a.rootBoundary,
    g = a.altBoundary,
    b = a.padding,
    C = a.tether,
    w = C === void 0 ? !0 : C,
    k = a.tetherOffset,
    D = k === void 0 ? 0 : k,
    E = Hd(r, { boundary: h, rootBoundary: m, padding: b, altBoundary: g }),
    M = hi(r.placement),
    z = cc(r.placement),
    P = !z,
    B = oC(M),
    j = CX(B),
    Q = r.modifiersData.popperOffsets,
    Y = r.rects.reference,
    ne = r.rects.popper,
    he = typeof D == 'function' ? D(Object.assign({}, r.rects, { placement: r.placement })) : D,
    le =
      typeof he == 'number'
        ? { mainAxis: he, altAxis: he }
        : Object.assign({ mainAxis: 0, altAxis: 0 }, he),
    pe = r.modifiersData.offset ? r.modifiersData.offset[r.placement] : null,
    Ne = { x: 0, y: 0 }
  if (Q) {
    if (f) {
      var me,
        ge = B === 'y' ? fa : da,
        Oe = B === 'y' ? Ga : qa,
        ze = B === 'y' ? 'height' : 'width',
        ee = Q[B],
        ut = ee + E[ge],
        Bt = ee - E[Oe],
        rt = w ? -ne[ze] / 2 : 0,
        qe = z === sc ? Y[ze] : ne[ze],
        vt = z === sc ? -ne[ze] : -Y[ze],
        Pe = r.elements.arrow,
        Ke = w && Pe ? iC(Pe) : { width: 0, height: 0 },
        Mt = r.modifiersData['arrow#persistent']
          ? r.modifiersData['arrow#persistent'].padding
          : uM(),
        Rt = Mt[ge],
        an = Mt[Oe],
        _t = xd(0, Y[ze], Ke[ze]),
        zt = P ? Y[ze] / 2 - rt - _t - Rt - le.mainAxis : qe - _t - Rt - le.mainAxis,
        Qt = P ? -Y[ze] / 2 + rt + _t + an + le.mainAxis : vt + _t + an + le.mainAxis,
        Ct = r.elements.arrow && rp(r.elements.arrow),
        xe = Ct ? (B === 'y' ? Ct.clientTop || 0 : Ct.clientLeft || 0) : 0,
        wt = (me = pe == null ? void 0 : pe[B]) != null ? me : 0,
        Zt = ee + zt - wt - xe,
        Jt = ee + Qt - wt,
        on = xd(w ? av(ut, Zt) : ut, ee, w ? Pl(Bt, Jt) : Bt)
      ;(Q[B] = on), (Ne[B] = on - ee)
    }
    if (p) {
      var sn,
        Kn = B === 'x' ? fa : da,
        Xn = B === 'x' ? Ga : qa,
        en = Q[j],
        hn = j === 'y' ? 'height' : 'width',
        gn = en + E[Kn],
        jt = en - E[Xn],
        kn = [fa, da].indexOf(M) !== -1,
        wn = (sn = pe == null ? void 0 : pe[j]) != null ? sn : 0,
        jn = kn ? gn : en - Y[hn] - ne[hn] - wn + le.altAxis,
        tn = kn ? en + Y[hn] + ne[hn] - wn - le.altAxis : jt,
        On = w && kn ? GK(jn, en, tn) : xd(w ? jn : gn, en, w ? tn : jt)
      ;(Q[j] = On), (Ne[j] = On - en)
    }
    r.modifiersData[o] = Ne
  }
}
const EX = {
  name: 'preventOverflow',
  enabled: !0,
  phase: 'main',
  fn: wX,
  requiresIfExists: ['offset'],
}
function TX(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
}
function RX(t) {
  return t === La(t) || !Ma(t) ? sC(t) : TX(t)
}
function _X(t) {
  var r = t.getBoundingClientRect(),
    a = lc(r.width) / t.offsetWidth || 1,
    o = lc(r.height) / t.offsetHeight || 1
  return a !== 1 || o !== 1
}
function kX(t, r, a) {
  a === void 0 && (a = !1)
  var o = Ma(r),
    l = Ma(r) && _X(r),
    f = zs(r),
    c = uc(t, l, a),
    p = { scrollLeft: 0, scrollTop: 0 },
    h = { x: 0, y: 0 }
  return (
    (o || (!o && !a)) &&
      ((qi(r) !== 'body' || uC(f)) && (p = RX(r)),
      Ma(r) ? ((h = uc(r, !0)), (h.x += r.clientLeft), (h.y += r.clientTop)) : f && (h.x = lC(f))),
    {
      x: c.left + p.scrollLeft - h.x,
      y: c.top + p.scrollTop - h.y,
      width: c.width,
      height: c.height,
    }
  )
}
function DX(t) {
  var r = new Map(),
    a = new Set(),
    o = []
  t.forEach(function (f) {
    r.set(f.name, f)
  })
  function l(f) {
    a.add(f.name)
    var c = [].concat(f.requires || [], f.requiresIfExists || [])
    c.forEach(function (p) {
      if (!a.has(p)) {
        var h = r.get(p)
        h && l(h)
      }
    }),
      o.push(f)
  }
  return (
    t.forEach(function (f) {
      a.has(f.name) || l(f)
    }),
    o
  )
}
function AX(t) {
  var r = DX(t)
  return ix.reduce(function (a, o) {
    return a.concat(
      r.filter(function (l) {
        return l.phase === o
      })
    )
  }, [])
}
function OX(t) {
  var r
  return function () {
    return (
      r ||
        (r = new Promise(function (a) {
          Promise.resolve().then(function () {
            ;(r = void 0), a(t())
          })
        })),
      r
    )
  }
}
function bs(t) {
  for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
    a[o - 1] = arguments[o]
  return [].concat(a).reduce(function (l, f) {
    return l.replace(/%s/, f)
  }, t)
}
var wl = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s',
  MX = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available',
  Jk = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options']
function PX(t) {
  t.forEach(function (r) {
    ;[]
      .concat(Object.keys(r), Jk)
      .filter(function (a, o, l) {
        return l.indexOf(a) === o
      })
      .forEach(function (a) {
        switch (a) {
          case 'name':
            typeof r.name != 'string' &&
              console.error(
                bs(wl, String(r.name), '"name"', '"string"', '"' + String(r.name) + '"')
              )
            break
          case 'enabled':
            typeof r.enabled != 'boolean' &&
              console.error(bs(wl, r.name, '"enabled"', '"boolean"', '"' + String(r.enabled) + '"'))
            break
          case 'phase':
            ix.indexOf(r.phase) < 0 &&
              console.error(
                bs(wl, r.name, '"phase"', 'either ' + ix.join(', '), '"' + String(r.phase) + '"')
              )
            break
          case 'fn':
            typeof r.fn != 'function' &&
              console.error(bs(wl, r.name, '"fn"', '"function"', '"' + String(r.fn) + '"'))
            break
          case 'effect':
            r.effect != null &&
              typeof r.effect != 'function' &&
              console.error(bs(wl, r.name, '"effect"', '"function"', '"' + String(r.fn) + '"'))
            break
          case 'requires':
            r.requires != null &&
              !Array.isArray(r.requires) &&
              console.error(bs(wl, r.name, '"requires"', '"array"', '"' + String(r.requires) + '"'))
            break
          case 'requiresIfExists':
            Array.isArray(r.requiresIfExists) ||
              console.error(
                bs(
                  wl,
                  r.name,
                  '"requiresIfExists"',
                  '"array"',
                  '"' + String(r.requiresIfExists) + '"'
                )
              )
            break
          case 'options':
          case 'data':
            break
          default:
            console.error(
              'PopperJS: an invalid property has been provided to the "' +
                r.name +
                '" modifier, valid properties are ' +
                Jk.map(function (o) {
                  return '"' + o + '"'
                }).join(', ') +
                '; but "' +
                a +
                '" was provided.'
            )
        }
        r.requires &&
          r.requires.forEach(function (o) {
            t.find(function (l) {
              return l.name === o
            }) == null && console.error(bs(MX, String(r.name), o, o))
          })
      })
  })
}
function LX(t, r) {
  var a = new Set()
  return t.filter(function (o) {
    var l = r(o)
    if (!a.has(l)) return a.add(l), !0
  })
}
function zX(t) {
  var r = t.reduce(function (a, o) {
    var l = a[o.name]
    return (
      (a[o.name] = l
        ? Object.assign({}, l, o, {
            options: Object.assign({}, l.options, o.options),
            data: Object.assign({}, l.data, o.data),
          })
        : o),
      a
    )
  }, {})
  return Object.keys(r).map(function (a) {
    return r[a]
  })
}
var eD =
    'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.',
  $X =
    'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.',
  tD = { placement: 'bottom', modifiers: [], strategy: 'absolute' }
function nD() {
  for (var t = arguments.length, r = new Array(t), a = 0; a < t; a++) r[a] = arguments[a]
  return !r.some(function (o) {
    return !(o && typeof o.getBoundingClientRect == 'function')
  })
}
function FX(t) {
  t === void 0 && (t = {})
  var r = t,
    a = r.defaultModifiers,
    o = a === void 0 ? [] : a,
    l = r.defaultOptions,
    f = l === void 0 ? tD : l
  return function (p, h, m) {
    m === void 0 && (m = f)
    var g = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, tD, f),
        modifiersData: {},
        elements: { reference: p, popper: h },
        attributes: {},
        styles: {},
      },
      b = [],
      C = !1,
      w = {
        state: g,
        setOptions: function (M) {
          var z = typeof M == 'function' ? M(g.options) : M
          D(),
            (g.options = Object.assign({}, f, g.options, z)),
            (g.scrollParents = {
              reference: zl(p) ? Cd(p) : p.contextElement ? Cd(p.contextElement) : [],
              popper: Cd(h),
            })
          var P = AX(zX([].concat(o, g.options.modifiers)))
          g.orderedModifiers = P.filter(function (pe) {
            return pe.enabled
          })
          {
            var B = LX([].concat(P, g.options.modifiers), function (pe) {
              var Ne = pe.name
              return Ne
            })
            if ((PX(B), hi(g.options.placement) === Av)) {
              var j = g.orderedModifiers.find(function (pe) {
                var Ne = pe.name
                return Ne === 'flip'
              })
              j ||
                console.error(
                  [
                    'Popper: "auto" placements require the "flip" modifier be',
                    'present and enabled to work.',
                  ].join(' ')
                )
            }
            var Q = gi(h),
              Y = Q.marginTop,
              ne = Q.marginRight,
              he = Q.marginBottom,
              le = Q.marginLeft
            ;[Y, ne, he, le].some(function (pe) {
              return parseFloat(pe)
            }) &&
              console.warn(
                [
                  'Popper: CSS "margin" styles cannot be used to apply padding',
                  'between the popper and its reference element or boundary.',
                  'To replicate margin, use the `offset` modifier, as well as',
                  'the `padding` option in the `preventOverflow` and `flip`',
                  'modifiers.',
                ].join(' ')
              )
          }
          return k(), w.update()
        },
        forceUpdate: function () {
          if (!C) {
            var M = g.elements,
              z = M.reference,
              P = M.popper
            if (!nD(z, P)) {
              console.error(eD)
              return
            }
            ;(g.rects = { reference: kX(z, rp(P), g.options.strategy === 'fixed'), popper: iC(P) }),
              (g.reset = !1),
              (g.placement = g.options.placement),
              g.orderedModifiers.forEach(function (pe) {
                return (g.modifiersData[pe.name] = Object.assign({}, pe.data))
              })
            for (var B = 0, j = 0; j < g.orderedModifiers.length; j++) {
              if (((B += 1), B > 100)) {
                console.error($X)
                break
              }
              if (g.reset === !0) {
                ;(g.reset = !1), (j = -1)
                continue
              }
              var Q = g.orderedModifiers[j],
                Y = Q.fn,
                ne = Q.options,
                he = ne === void 0 ? {} : ne,
                le = Q.name
              typeof Y == 'function' &&
                (g = Y({ state: g, options: he, name: le, instance: w }) || g)
            }
          }
        },
        update: OX(function () {
          return new Promise(function (E) {
            w.forceUpdate(), E(g)
          })
        }),
        destroy: function () {
          D(), (C = !0)
        },
      }
    if (!nD(p, h)) return console.error(eD), w
    w.setOptions(m).then(function (E) {
      !C && m.onFirstUpdate && m.onFirstUpdate(E)
    })
    function k() {
      g.orderedModifiers.forEach(function (E) {
        var M = E.name,
          z = E.options,
          P = z === void 0 ? {} : z,
          B = E.effect
        if (typeof B == 'function') {
          var j = B({ state: g, name: M, instance: w, options: P }),
            Q = function () {}
          b.push(j || Q)
        }
      })
    }
    function D() {
      b.forEach(function (E) {
        return E()
      }),
        (b = [])
    }
    return w
  }
}
var NX = [rX, xX, tX, HK, bX, hX, EX, QK, vX],
  BX = FX({ defaultModifiers: NX })
function jX(t = {}) {
  const {
      enabled: r = !0,
      modifiers: a,
      placement: o = 'bottom',
      strategy: l = 'absolute',
      arrowPadding: f = 8,
      eventListeners: c = !0,
      offset: p,
      gutter: h = 8,
      flip: m = !0,
      boundary: g = 'clippingParents',
      preventOverflow: b = !0,
      matchWidth: C,
      direction: w = 'ltr',
    } = t,
    k = R.useRef(null),
    D = R.useRef(null),
    E = R.useRef(null),
    M = AK(o, w),
    z = R.useRef(() => {}),
    P = R.useCallback(() => {
      var le
      !r ||
        !k.current ||
        !D.current ||
        ((le = z.current) == null || le.call(z),
        (E.current = BX(k.current, D.current, {
          placement: M,
          modifiers: [
            _K,
            EK,
            wK,
            { ...CK, enabled: !!C },
            { name: 'eventListeners', ...xK(c) },
            { name: 'arrow', options: { padding: f } },
            { name: 'offset', options: { offset: p ?? [0, h] } },
            { name: 'flip', enabled: !!m, options: { padding: 8 } },
            { name: 'preventOverflow', enabled: !!b, options: { boundary: g } },
            ...(a ?? []),
          ],
          strategy: l,
        })),
        E.current.forceUpdate(),
        (z.current = E.current.destroy))
    }, [M, r, a, C, c, f, p, h, m, b, g, l])
  R.useEffect(
    () => () => {
      var le
      !k.current && !D.current && ((le = E.current) == null || le.destroy(), (E.current = null))
    },
    []
  )
  const B = R.useCallback(
      (le) => {
        ;(k.current = le), P()
      },
      [P]
    ),
    j = R.useCallback((le = {}, pe = null) => ({ ...le, ref: Os(B, pe) }), [B]),
    Q = R.useCallback(
      (le) => {
        ;(D.current = le), P()
      },
      [P]
    ),
    Y = R.useCallback(
      (le = {}, pe = null) => ({
        ...le,
        ref: Os(Q, pe),
        style: {
          ...le.style,
          position: l,
          minWidth: C ? void 0 : 'max-content',
          inset: '0 auto auto 0',
        },
      }),
      [l, Q, C]
    ),
    ne = R.useCallback((le = {}, pe = null) => {
      const { size: Ne, shadowColor: me, bg: ge, style: Oe, ...ze } = le
      return { ...ze, 'ref': pe, 'data-popper-arrow': '', 'style': UX(le) }
    }, []),
    he = R.useCallback(
      (le = {}, pe = null) => ({ ...le, 'ref': pe, 'data-popper-arrow-inner': '' }),
      []
    )
  return {
    update() {
      var le
      ;(le = E.current) == null || le.update()
    },
    forceUpdate() {
      var le
      ;(le = E.current) == null || le.forceUpdate()
    },
    transformOrigin: Da.transformOrigin.varRef,
    referenceRef: B,
    popperRef: Q,
    getPopperProps: Y,
    getArrowProps: ne,
    getArrowInnerProps: he,
    getReferenceProps: j,
  }
}
function UX(t) {
  const { size: r, shadowColor: a, bg: o, style: l } = t,
    f = { ...l, position: 'absolute' }
  return (
    r && (f['--popper-arrow-size'] = r),
    a && (f['--popper-arrow-shadow-color'] = a),
    o && (f['--popper-arrow-bg'] = o),
    f
  )
}
function VX(t = {}) {
  const { onClose: r, onOpen: a, isOpen: o, id: l } = t,
    f = Ld(a),
    c = Ld(r),
    [p, h] = R.useState(t.defaultIsOpen || !1),
    m = o !== void 0 ? o : p,
    g = o !== void 0,
    b = R.useId(),
    C = l ?? `disclosure-${b}`,
    w = R.useCallback(() => {
      g || h(!1), c == null || c()
    }, [g, c]),
    k = R.useCallback(() => {
      g || h(!0), f == null || f()
    }, [g, f]),
    D = R.useCallback(() => {
      m ? w() : k()
    }, [m, k, w])
  function E(z = {}) {
    return {
      ...z,
      'aria-expanded': m,
      'aria-controls': C,
      'onClick'(P) {
        var B
        ;(B = z.onClick) == null || B.call(z, P), D()
      },
    }
  }
  function M(z = {}) {
    return { ...z, hidden: !m, id: C }
  }
  return {
    isOpen: m,
    onOpen: k,
    onClose: w,
    onToggle: D,
    isControlled: g,
    getButtonProps: E,
    getDisclosureProps: M,
  }
}
function IX(t) {
  const { ref: r, handler: a, enabled: o = !0 } = t,
    l = Ld(a),
    c = R.useRef({ isPointerDown: !1, ignoreEmulatedMouseEvents: !1 }).current
  R.useEffect(() => {
    if (!o) return
    const p = (b) => {
        vS(b, r) && (c.isPointerDown = !0)
      },
      h = (b) => {
        if (c.ignoreEmulatedMouseEvents) {
          c.ignoreEmulatedMouseEvents = !1
          return
        }
        c.isPointerDown && a && vS(b, r) && ((c.isPointerDown = !1), l(b))
      },
      m = (b) => {
        ;(c.ignoreEmulatedMouseEvents = !0),
          a && c.isPointerDown && vS(b, r) && ((c.isPointerDown = !1), l(b))
      },
      g = hM(r.current)
    return (
      g.addEventListener('mousedown', p, !0),
      g.addEventListener('mouseup', h, !0),
      g.addEventListener('touchstart', p, !0),
      g.addEventListener('touchend', m, !0),
      () => {
        g.removeEventListener('mousedown', p, !0),
          g.removeEventListener('mouseup', h, !0),
          g.removeEventListener('touchstart', p, !0),
          g.removeEventListener('touchend', m, !0)
      }
    )
  }, [a, r, l, c, o])
}
function vS(t, r) {
  var a
  const o = t.target
  return t.button > 0 || (o && !hM(o).contains(o))
    ? !1
    : !((a = r.current) != null && a.contains(o))
}
function hM(t) {
  var r
  return (r = t == null ? void 0 : t.ownerDocument) != null ? r : document
}
function HX(t) {
  const { isOpen: r, ref: a } = t,
    [o, l] = R.useState(r),
    [f, c] = R.useState(!1)
  return (
    R.useEffect(() => {
      f || (l(r), c(!0))
    }, [r, f, o]),
    Kq(
      () => a.current,
      'animationend',
      () => {
        l(r)
      }
    ),
    {
      present: !(r ? !1 : !o),
      onComplete() {
        var h
        const m = Xq(a.current),
          g = new m.CustomEvent('animationend', { bubbles: !0 })
        ;(h = a.current) == null || h.dispatchEvent(g)
      },
    }
  )
}
function WX(t) {
  const { wasSelected: r, enabled: a, isSelected: o, mode: l = 'unmount' } = t
  return !!(!a || o || (l === 'keepMounted' && r))
}
var [YX, GX, qX, KX] = Vq(),
  [XX, ap] = zo({ strict: !1, name: 'MenuContext' })
function QX(t, ...r) {
  const a = R.useId(),
    o = t || a
  return R.useMemo(() => r.map((l) => `${l}-${o}`), [o, r])
}
function mM(t) {
  var r
  return (r = t == null ? void 0 : t.ownerDocument) != null ? r : document
}
function rD(t) {
  return mM(t).activeElement === t
}
function ZX(t = {}) {
  const {
      id: r,
      closeOnSelect: a = !0,
      closeOnBlur: o = !0,
      initialFocusRef: l,
      autoSelect: f = !0,
      isLazy: c,
      isOpen: p,
      defaultIsOpen: h,
      onClose: m,
      onOpen: g,
      placement: b = 'bottom-start',
      lazyBehavior: C = 'unmount',
      direction: w,
      computePositionOnMount: k = !1,
      ...D
    } = t,
    E = R.useRef(null),
    M = R.useRef(null),
    z = qX(),
    P = R.useCallback(() => {
      requestAnimationFrame(() => {
        var Pe
        ;(Pe = E.current) == null || Pe.focus({ preventScroll: !1 })
      })
    }, []),
    B = R.useCallback(() => {
      const Pe = setTimeout(() => {
        var Ke
        if (l) (Ke = l.current) == null || Ke.focus()
        else {
          const Mt = z.firstEnabled()
          Mt && me(Mt.index)
        }
      })
      ut.current.add(Pe)
    }, [z, l]),
    j = R.useCallback(() => {
      const Pe = setTimeout(() => {
        const Ke = z.lastEnabled()
        Ke && me(Ke.index)
      })
      ut.current.add(Pe)
    }, [z]),
    Q = R.useCallback(() => {
      g == null || g(), f ? B() : P()
    }, [f, B, P, g]),
    {
      isOpen: Y,
      onOpen: ne,
      onClose: he,
      onToggle: le,
    } = VX({ isOpen: p, defaultIsOpen: h, onClose: m, onOpen: Q })
  IX({
    enabled: Y && o,
    ref: E,
    handler: (Pe) => {
      var Ke
      ;((Ke = M.current) != null && Ke.contains(Pe.target)) || he()
    },
  })
  const pe = jX({ ...D, enabled: Y || k, placement: b, direction: w }),
    [Ne, me] = R.useState(-1)
  zd(() => {
    Y || me(-1)
  }, [Y]),
    gK(E, { focusRef: M, visible: Y, shouldFocus: !0 })
  const ge = HX({ isOpen: Y, ref: E }),
    [Oe, ze] = QX(r, 'menu-button', 'menu-list'),
    ee = R.useCallback(() => {
      ne(), P()
    }, [ne, P]),
    ut = R.useRef(new Set([]))
  iQ(() => {
    ut.current.forEach((Pe) => clearTimeout(Pe)), ut.current.clear()
  })
  const Bt = R.useCallback(() => {
      ne(), B()
    }, [B, ne]),
    rt = R.useCallback(() => {
      ne(), j()
    }, [ne, j]),
    qe = R.useCallback(() => {
      var Pe, Ke
      const Mt = mM(E.current),
        Rt = (Pe = E.current) == null ? void 0 : Pe.contains(Mt.activeElement)
      if (!(Y && !Rt)) return
      const _t = (Ke = z.item(Ne)) == null ? void 0 : Ke.node
      _t == null || _t.focus()
    }, [Y, Ne, z]),
    vt = R.useRef(null)
  return {
    openAndFocusMenu: ee,
    openAndFocusFirstItem: Bt,
    openAndFocusLastItem: rt,
    onTransitionEnd: qe,
    unstable__animationState: ge,
    descendants: z,
    popper: pe,
    buttonId: Oe,
    menuId: ze,
    forceUpdate: pe.forceUpdate,
    orientation: 'vertical',
    isOpen: Y,
    onToggle: le,
    onOpen: ne,
    onClose: he,
    menuRef: E,
    buttonRef: M,
    focusedIndex: Ne,
    closeOnSelect: a,
    closeOnBlur: o,
    autoSelect: f,
    setFocusedIndex: me,
    isLazy: c,
    lazyBehavior: C,
    initialFocusRef: l,
    rafId: vt,
  }
}
function JX(t = {}, r = null) {
  const a = ap(),
    { onToggle: o, popper: l, openAndFocusFirstItem: f, openAndFocusLastItem: c } = a,
    p = R.useCallback(
      (h) => {
        const m = h.key,
          b = { Enter: f, ArrowDown: f, ArrowUp: c }[m]
        b && (h.preventDefault(), h.stopPropagation(), b(h))
      },
      [f, c]
    )
  return {
    ...t,
    'ref': Os(a.buttonRef, r, l.referenceRef),
    'id': a.buttonId,
    'data-active': Um(a.isOpen),
    'aria-expanded': a.isOpen,
    'aria-haspopup': 'menu',
    'aria-controls': a.menuId,
    'onClick': RS(t.onClick, o),
    'onKeyDown': RS(t.onKeyDown, p),
  }
}
function lx(t) {
  var r
  return (
    rQ(t) &&
    !!((r = t == null ? void 0 : t.getAttribute('role')) != null && r.startsWith('menuitem'))
  )
}
function eQ(t = {}, r = null) {
  const a = ap()
  if (!a)
    throw new Error(
      'useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>'
    )
  const {
      focusedIndex: o,
      setFocusedIndex: l,
      menuRef: f,
      isOpen: c,
      onClose: p,
      menuId: h,
      isLazy: m,
      lazyBehavior: g,
      unstable__animationState: b,
    } = a,
    C = GX(),
    w = dK({ preventDefault: (M) => M.key !== ' ' && lx(M.target) }),
    k = R.useCallback(
      (M) => {
        const z = M.key,
          B = {
            Tab: (Q) => Q.preventDefault(),
            Escape: p,
            ArrowDown: () => {
              const Q = C.nextEnabled(o)
              Q && l(Q.index)
            },
            ArrowUp: () => {
              const Q = C.prevEnabled(o)
              Q && l(Q.index)
            },
          }[z]
        if (B) {
          M.preventDefault(), B(M)
          return
        }
        const j = w((Q) => {
          const Y = pK(
            C.values(),
            Q,
            (ne) => {
              var he, le
              return (le =
                (he = ne == null ? void 0 : ne.node) == null ? void 0 : he.textContent) != null
                ? le
                : ''
            },
            C.item(o)
          )
          if (Y) {
            const ne = C.indexOf(Y.node)
            l(ne)
          }
        })
        lx(M.target) && j(M)
      },
      [C, o, w, p, l]
    ),
    D = R.useRef(!1)
  c && (D.current = !0)
  const E = WX({ wasSelected: D.current, enabled: m, mode: g, isSelected: b.present })
  return {
    ...t,
    'ref': Os(f, r),
    'children': E ? t.children : null,
    'tabIndex': -1,
    'role': 'menu',
    'id': h,
    'style': { ...t.style, transformOrigin: 'var(--popper-transform-origin)' },
    'aria-orientation': 'vertical',
    'onKeyDown': RS(t.onKeyDown, k),
  }
}
function tQ(t = {}) {
  const { popper: r, isOpen: a } = ap()
  return r.getPopperProps({ ...t, style: { visibility: a ? 'visible' : 'hidden', ...t.style } })
}
function nQ(t = {}, r = null) {
  const {
      onMouseEnter: a,
      onMouseMove: o,
      onMouseLeave: l,
      onClick: f,
      onFocus: c,
      isDisabled: p,
      isFocusable: h,
      closeOnSelect: m,
      type: g,
      ...b
    } = t,
    C = ap(),
    {
      setFocusedIndex: w,
      focusedIndex: k,
      closeOnSelect: D,
      onClose: E,
      menuRef: M,
      isOpen: z,
      menuId: P,
      rafId: B,
    } = C,
    j = R.useRef(null),
    Q = `${P}-menuitem-${R.useId()}`,
    { index: Y, register: ne } = KX({ disabled: p && !h }),
    he = R.useCallback(
      (ee) => {
        a == null || a(ee), !p && w(Y)
      },
      [w, Y, p, a]
    ),
    le = R.useCallback(
      (ee) => {
        o == null || o(ee), j.current && !rD(j.current) && he(ee)
      },
      [he, o]
    ),
    pe = R.useCallback(
      (ee) => {
        l == null || l(ee), !p && w(-1)
      },
      [w, p, l]
    ),
    Ne = R.useCallback(
      (ee) => {
        f == null || f(ee), lx(ee.currentTarget) && (m ?? D) && E()
      },
      [E, f, D, m]
    ),
    me = R.useCallback(
      (ee) => {
        c == null || c(ee), w(Y)
      },
      [w, c, Y]
    ),
    ge = Y === k,
    Oe = p && !h
  zd(() => {
    z &&
      (ge && !Oe && j.current
        ? (B.current && cancelAnimationFrame(B.current),
          (B.current = requestAnimationFrame(() => {
            var ee
            ;(ee = j.current) == null || ee.focus(), (B.current = null)
          })))
        : M.current && !rD(M.current) && M.current.focus())
  }, [ge, Oe, M, z])
  const ze = mK({
    onClick: Ne,
    onFocus: me,
    onMouseEnter: he,
    onMouseMove: le,
    onMouseLeave: pe,
    ref: Os(ne, j, r),
    isDisabled: p,
    isFocusable: h,
  })
  return { ...b, ...ze, type: g ?? ze.type, id: Q, role: 'menuitem', tabIndex: ge ? 0 : -1 }
}
function rQ(t) {
  var r
  if (!aQ(t)) return !1
  const a = (r = t.ownerDocument.defaultView) != null ? r : window
  return t instanceof a.HTMLElement
}
function aQ(t) {
  return t != null && typeof t == 'object' && 'nodeType' in t && t.nodeType === Node.ELEMENT_NODE
}
function iQ(t, r = []) {
  return R.useEffect(() => () => t(), r)
}
var [oQ, Mv] = zo({
    name: 'MenuStylesContext',
    errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `,
  }),
  vM = (t) => {
    const { children: r } = t,
      a = bA('Menu', t),
      o = Ps(t),
      { direction: l } = mv(),
      { descendants: f, ...c } = ZX({ ...o, direction: l }),
      p = R.useMemo(() => c, [c]),
      { isOpen: h, onClose: m, forceUpdate: g } = p
    return V(YX, {
      value: f,
      children: V(XX, {
        value: p,
        children: V(oQ, { value: a, children: ko(r, { isOpen: h, onClose: m, forceUpdate: g }) }),
      }),
    })
  }
vM.displayName = 'Menu'
var gM = _n((t, r) => {
  const a = Mv()
  return V(Ht.span, { ref: r, ...t, __css: a.command, className: 'chakra-menu__command' })
})
gM.displayName = 'MenuCommand'
var sQ = _n((t, r) => {
    const { type: a, ...o } = t,
      l = Mv(),
      f = o.as || a ? a ?? void 0 : 'button',
      c = R.useMemo(
        () => ({
          textDecoration: 'none',
          color: 'inherit',
          userSelect: 'none',
          display: 'flex',
          width: '100%',
          alignItems: 'center',
          textAlign: 'start',
          flex: '0 0 auto',
          outline: 0,
          ...l.item,
        }),
        [l.item]
      )
    return V(Ht.button, { ref: r, type: f, ...o, __css: c })
  }),
  yM = (t) => {
    const { className: r, children: a, ...o } = t,
      l = R.Children.only(a),
      f = R.isValidElement(l)
        ? R.cloneElement(l, {
            'focusable': 'false',
            'aria-hidden': !0,
            'className': lr('chakra-menu__icon', l.props.className),
          })
        : null,
      c = lr('chakra-menu__icon-wrapper', r)
    return V(Ht.span, { className: c, ...o, __css: { flexShrink: 0 }, children: f })
  }
yM.displayName = 'MenuIcon'
var xs = _n((t, r) => {
  const {
      icon: a,
      iconSpacing: o = '0.75rem',
      command: l,
      commandSpacing: f = '0.75rem',
      children: c,
      ...p
    } = t,
    h = nQ(p, r),
    g = a || l ? V('span', { style: { pointerEvents: 'none', flex: 1 }, children: c }) : c
  return He(sQ, {
    ...h,
    className: lr('chakra-menu__menuitem', h.className),
    children: [
      a && V(yM, { fontSize: '0.8em', marginEnd: o, children: a }),
      g,
      l && V(gM, { marginStart: f, children: l }),
    ],
  })
})
xs.displayName = 'MenuItem'
var lQ = {
    enter: {
      visibility: 'visible',
      opacity: 1,
      scale: 1,
      transition: { duration: 0.2, ease: [0.4, 0, 0.2, 1] },
    },
    exit: {
      transitionEnd: { visibility: 'hidden' },
      opacity: 0,
      scale: 0.8,
      transition: { duration: 0.1, easings: 'easeOut' },
    },
  },
  uQ = Ht(FO.div),
  bM = _n(function (r, a) {
    var o, l
    const { rootProps: f, motionProps: c, ...p } = r,
      { isOpen: h, onTransitionEnd: m, unstable__animationState: g } = ap(),
      b = eQ(p, a),
      C = tQ(f),
      w = Mv()
    return V(Ht.div, {
      ...C,
      __css: { zIndex: (l = r.zIndex) != null ? l : (o = w.list) == null ? void 0 : o.zIndex },
      children: V(uQ, {
        variants: lQ,
        initial: !1,
        animate: h ? 'enter' : 'exit',
        __css: { outline: 0, ...w.list },
        ...c,
        className: lr('chakra-menu__menu-list', b.className),
        ...b,
        onUpdate: m,
        onAnimationComplete: zU(g.onComplete, b.onAnimationComplete),
      }),
    })
  })
bM.displayName = 'MenuList'
var cQ = _n((t, r) => {
    const a = Mv()
    return V(Ht.button, {
      ref: r,
      ...t,
      __css: {
        display: 'inline-flex',
        appearance: 'none',
        alignItems: 'center',
        outline: 0,
        ...a.button,
      },
    })
  }),
  SM = _n((t, r) => {
    const { children: a, as: o, ...l } = t,
      f = JX(l, r)
    return V(o || cQ, {
      ...f,
      className: lr('chakra-menu__menu-button', t.className),
      children: V(Ht.span, {
        __css: { pointerEvents: 'none', flex: '1 1 auto', minW: 0 },
        children: t.children,
      }),
    })
  })
SM.displayName = 'MenuButton'
var ux = {},
  gS = Dd
{
  var wm = gS.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  ;(ux.createRoot = function (t, r) {
    wm.usingClientEntryPoint = !0
    try {
      return gS.createRoot(t, r)
    } finally {
      wm.usingClientEntryPoint = !1
    }
  }),
    (ux.hydrateRoot = function (t, r, a) {
      wm.usingClientEntryPoint = !0
      try {
        return gS.hydrateRoot(t, r, a)
      } finally {
        wm.usingClientEntryPoint = !1
      }
    })
}
/**
 * @remix-run/router v1.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Ot() {
  return (
    (Ot = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var r = 1; r < arguments.length; r++) {
            var a = arguments[r]
            for (var o in a) Object.prototype.hasOwnProperty.call(a, o) && (t[o] = a[o])
          }
          return t
        }),
    Ot.apply(this, arguments)
  )
}
var Gn
;(function (t) {
  ;(t.Pop = 'POP'), (t.Push = 'PUSH'), (t.Replace = 'REPLACE')
})(Gn || (Gn = {}))
const aD = 'popstate'
function fQ(t) {
  t === void 0 && (t = {})
  function r(o, l) {
    let { pathname: f, search: c, hash: p } = o.location
    return Wd(
      '',
      { pathname: f, search: c, hash: p },
      (l.state && l.state.usr) || null,
      (l.state && l.state.key) || 'default'
    )
  }
  function a(o, l) {
    return typeof l == 'string' ? l : Ki(l)
  }
  return pQ(r, a, null, t)
}
function st(t, r) {
  if (t === !1 || t === null || typeof t > 'u') throw new Error(r)
}
function ma(t, r) {
  if (!t) {
    typeof console < 'u' && console.warn(r)
    try {
      throw new Error(r)
    } catch {}
  }
}
function dQ() {
  return Math.random().toString(36).substr(2, 8)
}
function iD(t, r) {
  return { usr: t.state, key: t.key, idx: r }
}
function Wd(t, r, a, o) {
  return (
    a === void 0 && (a = null),
    Ot(
      { pathname: typeof t == 'string' ? t : t.pathname, search: '', hash: '' },
      typeof r == 'string' ? $o(r) : r,
      { state: a, key: (r && r.key) || o || dQ() }
    )
  )
}
function Ki(t) {
  let { pathname: r = '/', search: a = '', hash: o = '' } = t
  return (
    a && a !== '?' && (r += a.charAt(0) === '?' ? a : '?' + a),
    o && o !== '#' && (r += o.charAt(0) === '#' ? o : '#' + o),
    r
  )
}
function $o(t) {
  let r = {}
  if (t) {
    let a = t.indexOf('#')
    a >= 0 && ((r.hash = t.substr(a)), (t = t.substr(0, a)))
    let o = t.indexOf('?')
    o >= 0 && ((r.search = t.substr(o)), (t = t.substr(0, o))), t && (r.pathname = t)
  }
  return r
}
function pQ(t, r, a, o) {
  o === void 0 && (o = {})
  let { window: l = document.defaultView, v5Compat: f = !1 } = o,
    c = l.history,
    p = Gn.Pop,
    h = null,
    m = g()
  m == null && ((m = 0), c.replaceState(Ot({}, c.state, { idx: m }), ''))
  function g() {
    return (c.state || { idx: null }).idx
  }
  function b() {
    p = Gn.Pop
    let E = g(),
      M = E == null ? null : E - m
    ;(m = E), h && h({ action: p, location: D.location, delta: M })
  }
  function C(E, M) {
    p = Gn.Push
    let z = Wd(D.location, E, M)
    a && a(z, E), (m = g() + 1)
    let P = iD(z, m),
      B = D.createHref(z)
    try {
      c.pushState(P, '', B)
    } catch {
      l.location.assign(B)
    }
    f && h && h({ action: p, location: D.location, delta: 1 })
  }
  function w(E, M) {
    p = Gn.Replace
    let z = Wd(D.location, E, M)
    a && a(z, E), (m = g())
    let P = iD(z, m),
      B = D.createHref(z)
    c.replaceState(P, '', B), f && h && h({ action: p, location: D.location, delta: 0 })
  }
  function k(E) {
    let M = l.location.origin !== 'null' ? l.location.origin : l.location.href,
      z = typeof E == 'string' ? E : Ki(E)
    return (
      st(M, 'No window.location.(origin|href) available to create URL for href: ' + z),
      new URL(z, M)
    )
  }
  let D = {
    get action() {
      return p
    },
    get location() {
      return t(l, c)
    },
    listen(E) {
      if (h) throw new Error('A history only accepts one active listener')
      return (
        l.addEventListener(aD, b),
        (h = E),
        () => {
          l.removeEventListener(aD, b), (h = null)
        }
      )
    },
    createHref(E) {
      return r(l, E)
    },
    createURL: k,
    encodeLocation(E) {
      let M = k(E)
      return { pathname: M.pathname, search: M.search, hash: M.hash }
    },
    push: C,
    replace: w,
    go(E) {
      return c.go(E)
    },
  }
  return D
}
var sr
;(function (t) {
  ;(t.data = 'data'), (t.deferred = 'deferred'), (t.redirect = 'redirect'), (t.error = 'error')
})(sr || (sr = {}))
const hQ = new Set(['lazy', 'caseSensitive', 'path', 'id', 'index', 'children'])
function mQ(t) {
  return t.index === !0
}
function xM(t, r, a, o) {
  return (
    a === void 0 && (a = []),
    o === void 0 && (o = {}),
    t.map((l, f) => {
      let c = [...a, f],
        p = typeof l.id == 'string' ? l.id : c.join('-')
      if (
        (st(l.index !== !0 || !l.children, 'Cannot specify children on an index route'),
        st(
          !o[p],
          'Found a route id collision on id "' +
            p +
            `".  Route id's must be globally unique within Data Router usages`
        ),
        mQ(l))
      ) {
        let h = Ot({}, l, { hasErrorBoundary: r(l), id: p })
        return (o[p] = h), h
      } else {
        let h = Ot({}, l, { id: p, hasErrorBoundary: r(l), children: void 0 })
        return (o[p] = h), l.children && (h.children = xM(l.children, r, c, o)), h
      }
    })
  )
}
function Gu(t, r, a) {
  a === void 0 && (a = '/')
  let o = typeof r == 'string' ? $o(r) : r,
    l = ip(o.pathname || '/', a)
  if (l == null) return null
  let f = CM(t)
  vQ(f)
  let c = null
  for (let p = 0; c == null && p < f.length; ++p) c = TQ(f[p], kQ(l))
  return c
}
function CM(t, r, a, o) {
  r === void 0 && (r = []), a === void 0 && (a = []), o === void 0 && (o = '')
  let l = (f, c, p) => {
    let h = {
      relativePath: p === void 0 ? f.path || '' : p,
      caseSensitive: f.caseSensitive === !0,
      childrenIndex: c,
      route: f,
    }
    h.relativePath.startsWith('/') &&
      (st(
        h.relativePath.startsWith(o),
        'Absolute route path "' +
          h.relativePath +
          '" nested under path ' +
          ('"' + o + '" is not valid. An absolute child route path ') +
          'must start with the combined path of all its parent routes.'
      ),
      (h.relativePath = h.relativePath.slice(o.length)))
    let m = Gi([o, h.relativePath]),
      g = a.concat(h)
    f.children &&
      f.children.length > 0 &&
      (st(
        f.index !== !0,
        'Index routes must not have child routes. Please remove ' +
          ('all child routes from route path "' + m + '".')
      ),
      CM(f.children, r, g, m)),
      !(f.path == null && !f.index) && r.push({ path: m, score: wQ(m, f.index), routesMeta: g })
  }
  return (
    t.forEach((f, c) => {
      var p
      if (f.path === '' || !((p = f.path) != null && p.includes('?'))) l(f, c)
      else for (let h of wM(f.path)) l(f, c, h)
    }),
    r
  )
}
function wM(t) {
  let r = t.split('/')
  if (r.length === 0) return []
  let [a, ...o] = r,
    l = a.endsWith('?'),
    f = a.replace(/\?$/, '')
  if (o.length === 0) return l ? [f, ''] : [f]
  let c = wM(o.join('/')),
    p = []
  return (
    p.push(...c.map((h) => (h === '' ? f : [f, h].join('/')))),
    l && p.push(...c),
    p.map((h) => (t.startsWith('/') && h === '' ? '/' : h))
  )
}
function vQ(t) {
  t.sort((r, a) =>
    r.score !== a.score
      ? a.score - r.score
      : EQ(
          r.routesMeta.map((o) => o.childrenIndex),
          a.routesMeta.map((o) => o.childrenIndex)
        )
  )
}
const gQ = /^:\w+$/,
  yQ = 3,
  bQ = 2,
  SQ = 1,
  xQ = 10,
  CQ = -2,
  oD = (t) => t === '*'
function wQ(t, r) {
  let a = t.split('/'),
    o = a.length
  return (
    a.some(oD) && (o += CQ),
    r && (o += bQ),
    a.filter((l) => !oD(l)).reduce((l, f) => l + (gQ.test(f) ? yQ : f === '' ? SQ : xQ), o)
  )
}
function EQ(t, r) {
  return t.length === r.length && t.slice(0, -1).every((o, l) => o === r[l])
    ? t[t.length - 1] - r[r.length - 1]
    : 0
}
function TQ(t, r) {
  let { routesMeta: a } = t,
    o = {},
    l = '/',
    f = []
  for (let c = 0; c < a.length; ++c) {
    let p = a[c],
      h = c === a.length - 1,
      m = l === '/' ? r : r.slice(l.length) || '/',
      g = RQ({ path: p.relativePath, caseSensitive: p.caseSensitive, end: h }, m)
    if (!g) return null
    Object.assign(o, g.params)
    let b = p.route
    f.push({
      params: o,
      pathname: Gi([l, g.pathname]),
      pathnameBase: MQ(Gi([l, g.pathnameBase])),
      route: b,
    }),
      g.pathnameBase !== '/' && (l = Gi([l, g.pathnameBase]))
  }
  return f
}
function RQ(t, r) {
  typeof t == 'string' && (t = { path: t, caseSensitive: !1, end: !0 })
  let [a, o] = _Q(t.path, t.caseSensitive, t.end),
    l = r.match(a)
  if (!l) return null
  let f = l[0],
    c = f.replace(/(.)\/+$/, '$1'),
    p = l.slice(1)
  return {
    params: o.reduce((m, g, b) => {
      if (g === '*') {
        let C = p[b] || ''
        c = f.slice(0, f.length - C.length).replace(/(.)\/+$/, '$1')
      }
      return (m[g] = DQ(p[b] || '', g)), m
    }, {}),
    pathname: f,
    pathnameBase: c,
    pattern: t,
  }
}
function _Q(t, r, a) {
  r === void 0 && (r = !1),
    a === void 0 && (a = !0),
    ma(
      t === '*' || !t.endsWith('*') || t.endsWith('/*'),
      'Route path "' +
        t +
        '" will be treated as if it were ' +
        ('"' + t.replace(/\*$/, '/*') + '" because the `*` character must ') +
        'always follow a `/` in the pattern. To get rid of this warning, ' +
        ('please change the route path to "' + t.replace(/\*$/, '/*') + '".')
    )
  let o = [],
    l =
      '^' +
      t
        .replace(/\/*\*?$/, '')
        .replace(/^\/*/, '/')
        .replace(/[\\.*+^$?{}|()[\]]/g, '\\$&')
        .replace(/\/:(\w+)/g, (c, p) => (o.push(p), '/([^\\/]+)'))
  return (
    t.endsWith('*')
      ? (o.push('*'), (l += t === '*' || t === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$'))
      : a
      ? (l += '\\/*$')
      : t !== '' && t !== '/' && (l += '(?:(?=\\/|$))'),
    [new RegExp(l, r ? void 0 : 'i'), o]
  )
}
function kQ(t) {
  try {
    return decodeURI(t)
  } catch (r) {
    return (
      ma(
        !1,
        'The URL path "' +
          t +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ('encoding (' + r + ').')
      ),
      t
    )
  }
}
function DQ(t, r) {
  try {
    return decodeURIComponent(t)
  } catch (a) {
    return (
      ma(
        !1,
        'The value for the URL param "' +
          r +
          '" will not be decoded because' +
          (' the string "' + t + '" is a malformed URL segment. This is probably') +
          (' due to a bad percent encoding (' + a + ').')
      ),
      t
    )
  }
}
function ip(t, r) {
  if (r === '/') return t
  if (!t.toLowerCase().startsWith(r.toLowerCase())) return null
  let a = r.endsWith('/') ? r.length - 1 : r.length,
    o = t.charAt(a)
  return o && o !== '/' ? null : t.slice(a) || '/'
}
function AQ(t, r) {
  r === void 0 && (r = '/')
  let { pathname: a, search: o = '', hash: l = '' } = typeof t == 'string' ? $o(t) : t
  return { pathname: a ? (a.startsWith('/') ? a : OQ(a, r)) : r, search: PQ(o), hash: LQ(l) }
}
function OQ(t, r) {
  let a = r.replace(/\/+$/, '').split('/')
  return (
    t.split('/').forEach((l) => {
      l === '..' ? a.length > 1 && a.pop() : l !== '.' && a.push(l)
    }),
    a.length > 1 ? a.join('/') : '/'
  )
}
function yS(t, r, a, o) {
  return (
    "Cannot include a '" +
    t +
    "' character in a manually specified " +
    ('`to.' + r + '` field [' + JSON.stringify(o) + '].  Please separate it out to the ') +
    ('`to.' + a + '` field. Alternatively you may provide the full path as ') +
    'a string in <Link to="..."> and the router will parse it for you.'
  )
}
function Pv(t) {
  return t.filter((r, a) => a === 0 || (r.route.path && r.route.path.length > 0))
}
function cC(t, r, a, o) {
  o === void 0 && (o = !1)
  let l
  typeof t == 'string'
    ? (l = $o(t))
    : ((l = Ot({}, t)),
      st(!l.pathname || !l.pathname.includes('?'), yS('?', 'pathname', 'search', l)),
      st(!l.pathname || !l.pathname.includes('#'), yS('#', 'pathname', 'hash', l)),
      st(!l.search || !l.search.includes('#'), yS('#', 'search', 'hash', l)))
  let f = t === '' || l.pathname === '',
    c = f ? '/' : l.pathname,
    p
  if (o || c == null) p = a
  else {
    let b = r.length - 1
    if (c.startsWith('..')) {
      let C = c.split('/')
      for (; C[0] === '..'; ) C.shift(), (b -= 1)
      l.pathname = C.join('/')
    }
    p = b >= 0 ? r[b] : '/'
  }
  let h = AQ(l, p),
    m = c && c !== '/' && c.endsWith('/'),
    g = (f || c === '.') && a.endsWith('/')
  return !h.pathname.endsWith('/') && (m || g) && (h.pathname += '/'), h
}
const Gi = (t) => t.join('/').replace(/\/\/+/g, '/'),
  MQ = (t) => t.replace(/\/+$/, '').replace(/^\/*/, '/'),
  PQ = (t) => (!t || t === '?' ? '' : t.startsWith('?') ? t : '?' + t),
  LQ = (t) => (!t || t === '#' ? '' : t.startsWith('#') ? t : '#' + t)
class fC {
  constructor(r, a, o, l) {
    l === void 0 && (l = !1),
      (this.status = r),
      (this.statusText = a || ''),
      (this.internal = l),
      o instanceof Error ? ((this.data = o.toString()), (this.error = o)) : (this.data = o)
  }
}
function EM(t) {
  return (
    t != null &&
    typeof t.status == 'number' &&
    typeof t.statusText == 'string' &&
    typeof t.internal == 'boolean' &&
    'data' in t
  )
}
const TM = ['post', 'put', 'patch', 'delete'],
  zQ = new Set(TM),
  $Q = ['get', ...TM],
  FQ = new Set($Q),
  NQ = new Set([301, 302, 303, 307, 308]),
  BQ = new Set([307, 308]),
  bS = {
    state: 'idle',
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
  },
  jQ = {
    state: 'idle',
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
  },
  sD = { state: 'unblocked', proceed: void 0, reset: void 0, location: void 0 },
  RM = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  _M =
    typeof window < 'u' &&
    typeof window.document < 'u' &&
    typeof window.document.createElement < 'u',
  UQ = !_M,
  VQ = (t) => !!t.hasErrorBoundary
function IQ(t) {
  st(t.routes.length > 0, 'You must provide a non-empty routes array to createRouter')
  let r = t.detectErrorBoundary || VQ,
    a = {},
    o = xM(t.routes, r, void 0, a),
    l,
    f = Ot({ v7_normalizeFormMethod: !1 }, t.future),
    c = null,
    p = new Set(),
    h = null,
    m = null,
    g = null,
    b = t.hydrationData != null,
    C = Gu(o, t.history.location, t.basename),
    w = null
  if (C == null) {
    let J = Bi(404, { pathname: t.history.location.pathname }),
      { matches: te, route: I } = hD(o)
    ;(C = te), (w = { [I.id]: J })
  }
  let k =
      !C.some((J) => J.route.lazy) && (!C.some((J) => J.route.loader) || t.hydrationData != null),
    D,
    E = {
      historyAction: t.history.action,
      location: t.history.location,
      matches: C,
      initialized: k,
      navigation: bS,
      restoreScrollPosition: t.hydrationData != null ? !1 : null,
      preventScrollReset: !1,
      revalidation: 'idle',
      loaderData: (t.hydrationData && t.hydrationData.loaderData) || {},
      actionData: (t.hydrationData && t.hydrationData.actionData) || null,
      errors: (t.hydrationData && t.hydrationData.errors) || w,
      fetchers: new Map(),
      blockers: new Map(),
    },
    M = Gn.Pop,
    z = !1,
    P,
    B = !1,
    j = !1,
    Q = [],
    Y = [],
    ne = new Map(),
    he = 0,
    le = -1,
    pe = new Map(),
    Ne = new Set(),
    me = new Map(),
    ge = new Map(),
    Oe = new Map(),
    ze = !1
  function ee() {
    return (
      (c = t.history.listen((J) => {
        let { action: te, location: I, delta: ie } = J
        if (ze) {
          ze = !1
          return
        }
        ma(
          Oe.size === 0 || ie != null,
          'You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.'
        )
        let ce = jt({ currentLocation: E.location, nextLocation: I, historyAction: te })
        if (ce && ie != null) {
          ;(ze = !0),
            t.history.go(ie * -1),
            gn(ce, {
              state: 'blocked',
              location: I,
              proceed() {
                gn(ce, { state: 'proceeding', proceed: void 0, reset: void 0, location: I }),
                  t.history.go(ie)
              },
              reset() {
                hn(ce), rt({ blockers: new Map(D.state.blockers) })
              },
            })
          return
        }
        return Ke(te, I)
      })),
      E.initialized || Ke(Gn.Pop, E.location),
      D
    )
  }
  function ut() {
    c && c(),
      p.clear(),
      P && P.abort(),
      E.fetchers.forEach((J, te) => Jt(te)),
      E.blockers.forEach((J, te) => hn(te))
  }
  function Bt(J) {
    return p.add(J), () => p.delete(J)
  }
  function rt(J) {
    ;(E = Ot({}, E, J)), p.forEach((te) => te(E))
  }
  function qe(J, te) {
    var I, ie
    let ce =
        E.actionData != null &&
        E.navigation.formMethod != null &&
        Ro(E.navigation.formMethod) &&
        E.navigation.state === 'loading' &&
        ((I = J.state) == null ? void 0 : I._isRedirect) !== !0,
      be
    te.actionData
      ? Object.keys(te.actionData).length > 0
        ? (be = te.actionData)
        : (be = null)
      : ce
      ? (be = E.actionData)
      : (be = null)
    let Se = te.loaderData
      ? pD(E.loaderData, te.loaderData, te.matches || [], te.errors)
      : E.loaderData
    for (let [Ce] of Oe) hn(Ce)
    let _e =
      z === !0 ||
      (E.navigation.formMethod != null &&
        Ro(E.navigation.formMethod) &&
        ((ie = J.state) == null ? void 0 : ie._isRedirect) !== !0)
    l && ((o = l), (l = void 0)),
      rt(
        Ot({}, te, {
          actionData: be,
          loaderData: Se,
          historyAction: M,
          location: J,
          initialized: !0,
          navigation: bS,
          revalidation: 'idle',
          restoreScrollPosition: tn(J, te.matches || E.matches),
          preventScrollReset: _e,
          blockers: new Map(E.blockers),
        })
      ),
      B ||
        M === Gn.Pop ||
        (M === Gn.Push
          ? t.history.push(J, J.state)
          : M === Gn.Replace && t.history.replace(J, J.state)),
      (M = Gn.Pop),
      (z = !1),
      (B = !1),
      (j = !1),
      (Q = []),
      (Y = [])
  }
  async function vt(J, te) {
    if (typeof J == 'number') {
      t.history.go(J)
      return
    }
    let { path: I, submission: ie, error: ce } = lD(J, f, te),
      be = E.location,
      Se = Wd(E.location, I, te && te.state)
    Se = Ot({}, Se, t.history.encodeLocation(Se))
    let _e = te && te.replace != null ? te.replace : void 0,
      Ce = Gn.Push
    _e === !0
      ? (Ce = Gn.Replace)
      : _e === !1 ||
        (ie != null &&
          Ro(ie.formMethod) &&
          ie.formAction === E.location.pathname + E.location.search &&
          (Ce = Gn.Replace))
    let it = te && 'preventScrollReset' in te ? te.preventScrollReset === !0 : void 0,
      $e = jt({ currentLocation: be, nextLocation: Se, historyAction: Ce })
    if ($e) {
      gn($e, {
        state: 'blocked',
        location: Se,
        proceed() {
          gn($e, { state: 'proceeding', proceed: void 0, reset: void 0, location: Se }), vt(J, te)
        },
        reset() {
          hn($e), rt({ blockers: new Map(E.blockers) })
        },
      })
      return
    }
    return await Ke(Ce, Se, {
      submission: ie,
      pendingError: ce,
      preventScrollReset: it,
      replace: te && te.replace,
    })
  }
  function Pe() {
    if ((wt(), rt({ revalidation: 'loading' }), E.navigation.state !== 'submitting')) {
      if (E.navigation.state === 'idle') {
        Ke(E.historyAction, E.location, { startUninterruptedRevalidation: !0 })
        return
      }
      Ke(M || E.historyAction, E.navigation.location, { overrideNavigation: E.navigation })
    }
  }
  async function Ke(J, te, I) {
    P && P.abort(),
      (P = null),
      (M = J),
      (B = (I && I.startUninterruptedRevalidation) === !0),
      jn(E.location, E.matches),
      (z = (I && I.preventScrollReset) === !0)
    let ie = l || o,
      ce = I && I.overrideNavigation,
      be = Gu(ie, te, t.basename)
    if (!be) {
      let et = Bi(404, { pathname: te.pathname }),
        { matches: Xe, route: En } = hD(ie)
      kn(), qe(te, { matches: Xe, loaderData: {}, errors: { [En.id]: et } })
      return
    }
    if (qQ(E.location, te) && !(I && I.submission && Ro(I.submission.formMethod))) {
      qe(te, { matches: be })
      return
    }
    P = new AbortController()
    let Se = rd(t.history, te, P.signal, I && I.submission),
      _e,
      Ce
    if (I && I.pendingError) Ce = { [qu(be).route.id]: I.pendingError }
    else if (I && I.submission && Ro(I.submission.formMethod)) {
      let et = await Mt(Se, te, I.submission, be, { replace: I.replace })
      if (et.shortCircuited) return
      ;(_e = et.pendingActionData),
        (Ce = et.pendingActionError),
        (ce = Ot({ state: 'loading', location: te }, I.submission)),
        (Se = new Request(Se.url, { signal: Se.signal }))
    }
    let {
      shortCircuited: it,
      loaderData: $e,
      errors: ln,
    } = await Rt(
      Se,
      te,
      be,
      ce,
      I && I.submission,
      I && I.fetcherSubmission,
      I && I.replace,
      _e,
      Ce
    )
    it ||
      ((P = null),
      qe(te, Ot({ matches: be }, _e ? { actionData: _e } : {}, { loaderData: $e, errors: ln })))
  }
  async function Mt(J, te, I, ie, ce) {
    wt()
    let be = Ot({ state: 'submitting', location: te }, I)
    rt({ navigation: be })
    let Se,
      _e = cx(ie, te)
    if (!_e.route.action && !_e.route.lazy)
      Se = {
        type: sr.error,
        error: Bi(405, { method: J.method, pathname: te.pathname, routeId: _e.route.id }),
      }
    else if (((Se = await nd('action', J, _e, ie, a, r, D.basename)), J.signal.aborted))
      return { shortCircuited: !0 }
    if (ec(Se)) {
      let Ce
      return (
        ce && ce.replace != null
          ? (Ce = ce.replace)
          : (Ce = Se.location === E.location.pathname + E.location.search),
        await Ct(E, Se, { submission: I, replace: Ce }),
        { shortCircuited: !0 }
      )
    }
    if (wd(Se)) {
      let Ce = qu(ie, _e.route.id)
      return (
        (ce && ce.replace) !== !0 && (M = Gn.Push),
        { pendingActionData: {}, pendingActionError: { [Ce.route.id]: Se.error } }
      )
    }
    if (Dl(Se)) throw Bi(400, { type: 'defer-action' })
    return { pendingActionData: { [_e.route.id]: Se.data } }
  }
  async function Rt(J, te, I, ie, ce, be, Se, _e, Ce) {
    let it = ie
    it ||
      (it = Ot(
        {
          state: 'loading',
          location: te,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
        },
        ce
      ))
    let $e =
        ce || be
          ? ce || be
          : it.formMethod && it.formAction && it.formData && it.formEncType
          ? {
              formMethod: it.formMethod,
              formAction: it.formAction,
              formData: it.formData,
              formEncType: it.formEncType,
            }
          : void 0,
      ln = l || o,
      [et, Xe] = uD(t.history, E, I, $e, te, j, Q, Y, me, ln, t.basename, _e, Ce)
    if (
      (kn(
        (Et) =>
          !(I && I.some((Mn) => Mn.route.id === Et)) || (et && et.some((Mn) => Mn.route.id === Et))
      ),
      et.length === 0 && Xe.length === 0)
    )
      return (
        qe(
          te,
          Ot({ matches: I, loaderData: {}, errors: Ce || null }, _e ? { actionData: _e } : {})
        ),
        { shortCircuited: !0 }
      )
    if (!B) {
      Xe.forEach((Mn) => {
        let Qn = E.fetchers.get(Mn.key),
          cr = {
            'state': 'loading',
            'data': Qn && Qn.data,
            'formMethod': void 0,
            'formAction': void 0,
            'formEncType': void 0,
            'formData': void 0,
            ' _hasFetcherDoneAnything ': !0,
          }
        E.fetchers.set(Mn.key, cr)
      })
      let Et = _e || E.actionData
      rt(
        Ot(
          { navigation: it },
          Et ? (Object.keys(Et).length === 0 ? { actionData: null } : { actionData: Et }) : {},
          Xe.length > 0 ? { fetchers: new Map(E.fetchers) } : {}
        )
      )
    }
    ;(le = ++he), Xe.forEach((Et) => ne.set(Et.key, P))
    let { results: En, loaderResults: yn, fetcherResults: va } = await xe(E.matches, I, et, Xe, J)
    if (J.signal.aborted) return { shortCircuited: !0 }
    Xe.forEach((Et) => ne.delete(Et.key))
    let Zr = mD(En)
    if (Zr) return await Ct(E, Zr, { replace: Se }), { shortCircuited: !0 }
    let { loaderData: Jr, errors: ga } = dD(E, I, et, yn, Ce, Xe, va, ge)
    ge.forEach((Et, Mn) => {
      Et.subscribe((Qn) => {
        ;(Qn || Et.done) && ge.delete(Mn)
      })
    }),
      Kn()
    let ya = Xn(le)
    return Ot(
      { loaderData: Jr, errors: ga },
      ya || Xe.length > 0 ? { fetchers: new Map(E.fetchers) } : {}
    )
  }
  function an(J) {
    return E.fetchers.get(J) || jQ
  }
  function _t(J, te, I, ie) {
    if (UQ)
      throw new Error(
        "router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback."
      )
    ne.has(J) && on(J)
    let be = Gu(l || o, I, t.basename)
    if (!be) {
      Zt(J, te, Bi(404, { pathname: I }))
      return
    }
    let { path: Se, submission: _e } = lD(I, f, ie, !0),
      Ce = cx(be, Se)
    if (((z = (ie && ie.preventScrollReset) === !0), _e && Ro(_e.formMethod))) {
      zt(J, te, Se, Ce, be, _e)
      return
    }
    me.set(J, { routeId: te, path: Se }), Qt(J, te, Se, Ce, be, _e)
  }
  async function zt(J, te, I, ie, ce, be) {
    if ((wt(), me.delete(J), !ie.route.action && !ie.route.lazy)) {
      let Tn = Bi(405, { method: be.formMethod, pathname: I, routeId: te })
      Zt(J, te, Tn)
      return
    }
    let Se = E.fetchers.get(J),
      _e = Ot({ state: 'submitting' }, be, {
        'data': Se && Se.data,
        ' _hasFetcherDoneAnything ': !0,
      })
    E.fetchers.set(J, _e), rt({ fetchers: new Map(E.fetchers) })
    let Ce = new AbortController(),
      it = rd(t.history, I, Ce.signal, be)
    ne.set(J, Ce)
    let $e = await nd('action', it, ie, ce, a, r, D.basename)
    if (it.signal.aborted) {
      ne.get(J) === Ce && ne.delete(J)
      return
    }
    if (ec($e)) {
      ne.delete(J), Ne.add(J)
      let Tn = Ot({ state: 'loading' }, be, { 'data': void 0, ' _hasFetcherDoneAnything ': !0 })
      return (
        E.fetchers.set(J, Tn),
        rt({ fetchers: new Map(E.fetchers) }),
        Ct(E, $e, { submission: be, isFetchActionRedirect: !0 })
      )
    }
    if (wd($e)) {
      Zt(J, te, $e.error)
      return
    }
    if (Dl($e)) throw Bi(400, { type: 'defer-action' })
    let ln = E.navigation.location || E.location,
      et = rd(t.history, ln, Ce.signal),
      Xe = l || o,
      En = E.navigation.state !== 'idle' ? Gu(Xe, E.navigation.location, t.basename) : E.matches
    st(En, "Didn't find any matches after fetcher action")
    let yn = ++he
    pe.set(J, yn)
    let va = Ot({ state: 'loading', data: $e.data }, be, { ' _hasFetcherDoneAnything ': !0 })
    E.fetchers.set(J, va)
    let [Zr, Jr] = uD(
      t.history,
      E,
      En,
      be,
      ln,
      j,
      Q,
      Y,
      me,
      Xe,
      t.basename,
      { [ie.route.id]: $e.data },
      void 0
    )
    Jr.filter((Tn) => Tn.key !== J).forEach((Tn) => {
      let L = Tn.key,
        se = E.fetchers.get(L),
        ve = {
          'state': 'loading',
          'data': se && se.data,
          'formMethod': void 0,
          'formAction': void 0,
          'formEncType': void 0,
          'formData': void 0,
          ' _hasFetcherDoneAnything ': !0,
        }
      E.fetchers.set(L, ve), ne.set(L, Ce)
    }),
      rt({ fetchers: new Map(E.fetchers) })
    let { results: ga, loaderResults: ya, fetcherResults: Et } = await xe(E.matches, En, Zr, Jr, et)
    if (Ce.signal.aborted) return
    pe.delete(J), ne.delete(J), Jr.forEach((Tn) => ne.delete(Tn.key))
    let Mn = mD(ga)
    if (Mn) return Ct(E, Mn)
    let { loaderData: Qn, errors: cr } = dD(E, E.matches, Zr, ya, void 0, Jr, Et, ge),
      jr = {
        'state': 'idle',
        'data': $e.data,
        'formMethod': void 0,
        'formAction': void 0,
        'formEncType': void 0,
        'formData': void 0,
        ' _hasFetcherDoneAnything ': !0,
      }
    E.fetchers.set(J, jr)
    let ea = Xn(yn)
    E.navigation.state === 'loading' && yn > le
      ? (st(M, 'Expected pending action'),
        P && P.abort(),
        qe(E.navigation.location, {
          matches: En,
          loaderData: Qn,
          errors: cr,
          fetchers: new Map(E.fetchers),
        }))
      : (rt(
          Ot(
            { errors: cr, loaderData: pD(E.loaderData, Qn, En, cr) },
            ea ? { fetchers: new Map(E.fetchers) } : {}
          )
        ),
        (j = !1))
  }
  async function Qt(J, te, I, ie, ce, be) {
    let Se = E.fetchers.get(J),
      _e = Ot(
        {
          state: 'loading',
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
        },
        be,
        { 'data': Se && Se.data, ' _hasFetcherDoneAnything ': !0 }
      )
    E.fetchers.set(J, _e), rt({ fetchers: new Map(E.fetchers) })
    let Ce = new AbortController(),
      it = rd(t.history, I, Ce.signal)
    ne.set(J, Ce)
    let $e = await nd('loader', it, ie, ce, a, r, D.basename)
    if (
      (Dl($e) && ($e = (await OM($e, it.signal, !0)) || $e),
      ne.get(J) === Ce && ne.delete(J),
      it.signal.aborted)
    )
      return
    if (ec($e)) {
      await Ct(E, $e)
      return
    }
    if (wd($e)) {
      let et = qu(E.matches, te)
      E.fetchers.delete(J),
        rt({ fetchers: new Map(E.fetchers), errors: { [et.route.id]: $e.error } })
      return
    }
    st(!Dl($e), 'Unhandled fetcher deferred data')
    let ln = {
      'state': 'idle',
      'data': $e.data,
      'formMethod': void 0,
      'formAction': void 0,
      'formEncType': void 0,
      'formData': void 0,
      ' _hasFetcherDoneAnything ': !0,
    }
    E.fetchers.set(J, ln), rt({ fetchers: new Map(E.fetchers) })
  }
  async function Ct(J, te, I) {
    var ie
    let { submission: ce, replace: be, isFetchActionRedirect: Se } = I === void 0 ? {} : I
    te.revalidate && (j = !0)
    let _e = Wd(
      J.location,
      te.location,
      Ot({ _isRedirect: !0 }, Se ? { _isFetchActionRedirect: !0 } : {})
    )
    if (
      (st(_e, 'Expected a location on the redirect navigation'),
      RM.test(te.location) && _M && typeof ((ie = window) == null ? void 0 : ie.location) < 'u')
    ) {
      let Xe = t.history.createURL(te.location),
        En = ip(Xe.pathname, t.basename || '/') == null
      if (window.location.origin !== Xe.origin || En) {
        be ? window.location.replace(te.location) : window.location.assign(te.location)
        return
      }
    }
    P = null
    let Ce = be === !0 ? Gn.Replace : Gn.Push,
      { formMethod: it, formAction: $e, formEncType: ln, formData: et } = J.navigation
    !ce &&
      it &&
      $e &&
      et &&
      ln &&
      (ce = { formMethod: it, formAction: $e, formEncType: ln, formData: et }),
      BQ.has(te.status) && ce && Ro(ce.formMethod)
        ? await Ke(Ce, _e, {
            submission: Ot({}, ce, { formAction: te.location }),
            preventScrollReset: z,
          })
        : Se
        ? await Ke(Ce, _e, {
            overrideNavigation: {
              state: 'loading',
              location: _e,
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
            },
            fetcherSubmission: ce,
            preventScrollReset: z,
          })
        : await Ke(Ce, _e, {
            overrideNavigation: {
              state: 'loading',
              location: _e,
              formMethod: ce ? ce.formMethod : void 0,
              formAction: ce ? ce.formAction : void 0,
              formEncType: ce ? ce.formEncType : void 0,
              formData: ce ? ce.formData : void 0,
            },
            preventScrollReset: z,
          })
  }
  async function xe(J, te, I, ie, ce) {
    let be = await Promise.all([
        ...I.map((Ce) => nd('loader', ce, Ce, te, a, r, D.basename)),
        ...ie.map((Ce) =>
          Ce.matches && Ce.match
            ? nd(
                'loader',
                rd(t.history, Ce.path, ce.signal),
                Ce.match,
                Ce.matches,
                a,
                r,
                D.basename
              )
            : { type: sr.error, error: Bi(404, { pathname: Ce.path }) }
        ),
      ]),
      Se = be.slice(0, I.length),
      _e = be.slice(I.length)
    return (
      await Promise.all([
        vD(J, I, Se, ce.signal, !1, E.loaderData),
        vD(
          J,
          ie.map((Ce) => Ce.match),
          _e,
          ce.signal,
          !0
        ),
      ]),
      { results: be, loaderResults: Se, fetcherResults: _e }
    )
  }
  function wt() {
    ;(j = !0),
      Q.push(...kn()),
      me.forEach((J, te) => {
        ne.has(te) && (Y.push(te), on(te))
      })
  }
  function Zt(J, te, I) {
    let ie = qu(E.matches, te)
    Jt(J), rt({ errors: { [ie.route.id]: I }, fetchers: new Map(E.fetchers) })
  }
  function Jt(J) {
    ne.has(J) && on(J), me.delete(J), pe.delete(J), Ne.delete(J), E.fetchers.delete(J)
  }
  function on(J) {
    let te = ne.get(J)
    st(te, 'Expected fetch controller: ' + J), te.abort(), ne.delete(J)
  }
  function sn(J) {
    for (let te of J) {
      let ie = {
        'state': 'idle',
        'data': an(te).data,
        'formMethod': void 0,
        'formAction': void 0,
        'formEncType': void 0,
        'formData': void 0,
        ' _hasFetcherDoneAnything ': !0,
      }
      E.fetchers.set(te, ie)
    }
  }
  function Kn() {
    let J = []
    for (let te of Ne) {
      let I = E.fetchers.get(te)
      st(I, 'Expected fetcher: ' + te), I.state === 'loading' && (Ne.delete(te), J.push(te))
    }
    sn(J)
  }
  function Xn(J) {
    let te = []
    for (let [I, ie] of pe)
      if (ie < J) {
        let ce = E.fetchers.get(I)
        st(ce, 'Expected fetcher: ' + I),
          ce.state === 'loading' && (on(I), pe.delete(I), te.push(I))
      }
    return sn(te), te.length > 0
  }
  function en(J, te) {
    let I = E.blockers.get(J) || sD
    return Oe.get(J) !== te && Oe.set(J, te), I
  }
  function hn(J) {
    E.blockers.delete(J), Oe.delete(J)
  }
  function gn(J, te) {
    let I = E.blockers.get(J) || sD
    st(
      (I.state === 'unblocked' && te.state === 'blocked') ||
        (I.state === 'blocked' && te.state === 'blocked') ||
        (I.state === 'blocked' && te.state === 'proceeding') ||
        (I.state === 'blocked' && te.state === 'unblocked') ||
        (I.state === 'proceeding' && te.state === 'unblocked'),
      'Invalid blocker state transition: ' + I.state + ' -> ' + te.state
    ),
      E.blockers.set(J, te),
      rt({ blockers: new Map(E.blockers) })
  }
  function jt(J) {
    let { currentLocation: te, nextLocation: I, historyAction: ie } = J
    if (Oe.size === 0) return
    Oe.size > 1 && ma(!1, 'A router only supports one blocker at a time')
    let ce = Array.from(Oe.entries()),
      [be, Se] = ce[ce.length - 1],
      _e = E.blockers.get(be)
    if (
      !(_e && _e.state === 'proceeding') &&
      Se({ currentLocation: te, nextLocation: I, historyAction: ie })
    )
      return be
  }
  function kn(J) {
    let te = []
    return (
      ge.forEach((I, ie) => {
        ;(!J || J(ie)) && (I.cancel(), te.push(ie), ge.delete(ie))
      }),
      te
    )
  }
  function wn(J, te, I) {
    if (((h = J), (g = te), (m = I || ((ie) => ie.key)), !b && E.navigation === bS)) {
      b = !0
      let ie = tn(E.location, E.matches)
      ie != null && rt({ restoreScrollPosition: ie })
    }
    return () => {
      ;(h = null), (g = null), (m = null)
    }
  }
  function jn(J, te) {
    if (h && m && g) {
      let I = te.map((ce) => gD(ce, E.loaderData)),
        ie = m(J, I) || J.key
      h[ie] = g()
    }
  }
  function tn(J, te) {
    if (h && m && g) {
      let I = te.map((be) => gD(be, E.loaderData)),
        ie = m(J, I) || J.key,
        ce = h[ie]
      if (typeof ce == 'number') return ce
    }
    return null
  }
  function On(J) {
    l = J
  }
  return (
    (D = {
      get basename() {
        return t.basename
      },
      get state() {
        return E
      },
      get routes() {
        return o
      },
      initialize: ee,
      subscribe: Bt,
      enableScrollRestoration: wn,
      navigate: vt,
      fetch: _t,
      revalidate: Pe,
      createHref: (J) => t.history.createHref(J),
      encodeLocation: (J) => t.history.encodeLocation(J),
      getFetcher: an,
      deleteFetcher: Jt,
      dispose: ut,
      getBlocker: en,
      deleteBlocker: hn,
      _internalFetchControllers: ne,
      _internalActiveDeferreds: ge,
      _internalSetRoutes: On,
    }),
    D
  )
}
function HQ(t) {
  return t != null && 'formData' in t
}
function lD(t, r, a, o) {
  o === void 0 && (o = !1)
  let l = typeof t == 'string' ? t : Ki(t)
  if (!a || !HQ(a)) return { path: l }
  if (a.formMethod && !QQ(a.formMethod))
    return { path: l, error: Bi(405, { method: a.formMethod }) }
  let f
  if (a.formData) {
    let h = a.formMethod || 'get'
    if (
      ((f = {
        formMethod: r.v7_normalizeFormMethod ? h.toUpperCase() : h.toLowerCase(),
        formAction: AM(l),
        formEncType: (a && a.formEncType) || 'application/x-www-form-urlencoded',
        formData: a.formData,
      }),
      Ro(f.formMethod))
    )
      return { path: l, submission: f }
  }
  let c = $o(l),
    p = DM(a.formData)
  return (
    o && c.search && MM(c.search) && p.append('index', ''),
    (c.search = '?' + p),
    { path: Ki(c), submission: f }
  )
}
function WQ(t, r) {
  let a = t
  if (r) {
    let o = t.findIndex((l) => l.route.id === r)
    o >= 0 && (a = t.slice(0, o))
  }
  return a
}
function uD(t, r, a, o, l, f, c, p, h, m, g, b, C) {
  let w = C ? Object.values(C)[0] : b ? Object.values(b)[0] : void 0,
    k = t.createURL(r.location),
    D = t.createURL(l),
    E = f || k.toString() === D.toString() || k.search !== D.search,
    M = C ? Object.keys(C)[0] : void 0,
    P = WQ(a, M).filter((j, Q) => {
      if (j.route.lazy) return !0
      if (j.route.loader == null) return !1
      if (YQ(r.loaderData, r.matches[Q], j) || c.some((he) => he === j.route.id)) return !0
      let Y = r.matches[Q],
        ne = j
      return cD(
        j,
        Ot({ currentUrl: k, currentParams: Y.params, nextUrl: D, nextParams: ne.params }, o, {
          actionResult: w,
          defaultShouldRevalidate: E || kM(Y, ne),
        })
      )
    }),
    B = []
  return (
    h.forEach((j, Q) => {
      if (!a.some((le) => le.route.id === j.routeId)) return
      let Y = Gu(m, j.path, g)
      if (!Y) {
        B.push(Ot({ key: Q }, j, { matches: null, match: null }))
        return
      }
      let ne = cx(Y, j.path)
      if (p.includes(Q)) {
        B.push(Ot({ key: Q, matches: Y, match: ne }, j))
        return
      }
      cD(
        ne,
        Ot(
          {
            currentUrl: k,
            currentParams: r.matches[r.matches.length - 1].params,
            nextUrl: D,
            nextParams: a[a.length - 1].params,
          },
          o,
          { actionResult: w, defaultShouldRevalidate: E }
        )
      ) && B.push(Ot({ key: Q, matches: Y, match: ne }, j))
    }),
    [P, B]
  )
}
function YQ(t, r, a) {
  let o = !r || a.route.id !== r.route.id,
    l = t[a.route.id] === void 0
  return o || l
}
function kM(t, r) {
  let a = t.route.path
  return (
    t.pathname !== r.pathname || (a != null && a.endsWith('*') && t.params['*'] !== r.params['*'])
  )
}
function cD(t, r) {
  if (t.route.shouldRevalidate) {
    let a = t.route.shouldRevalidate(r)
    if (typeof a == 'boolean') return a
  }
  return r.defaultShouldRevalidate
}
async function fD(t, r, a) {
  if (!t.lazy) return
  let o = await t.lazy()
  if (!t.lazy) return
  let l = a[t.id]
  st(l, 'No route found in manifest')
  let f = {}
  for (let c in o) {
    let h = l[c] !== void 0 && c !== 'hasErrorBoundary'
    ma(
      !h,
      'Route "' +
        l.id +
        '" has a static property "' +
        c +
        '" defined but its lazy function is also returning a value for this property. ' +
        ('The lazy route property "' + c + '" will be ignored.')
    ),
      !h && !hQ.has(c) && (f[c] = o[c])
  }
  Object.assign(l, f), Object.assign(l, { hasErrorBoundary: r(Ot({}, l)), lazy: void 0 })
}
async function nd(t, r, a, o, l, f, c, p, h, m) {
  c === void 0 && (c = '/'), p === void 0 && (p = !1), h === void 0 && (h = !1)
  let g,
    b,
    C,
    w = (E) => {
      let M,
        z = new Promise((P, B) => (M = B))
      return (
        (C = () => M()),
        r.signal.addEventListener('abort', C),
        Promise.race([E({ request: r, params: a.params, context: m }), z])
      )
    }
  try {
    let E = a.route[t]
    if (a.route.lazy)
      if (E) b = (await Promise.all([w(E), fD(a.route, f, l)]))[0]
      else if ((await fD(a.route, f, l), (E = a.route[t]), E)) b = await w(E)
      else {
        if (t === 'action')
          throw Bi(405, {
            method: r.method,
            pathname: new URL(r.url).pathname,
            routeId: a.route.id,
          })
        return { type: sr.data, data: void 0 }
      }
    else
      st(E, 'Could not find the ' + t + ' to run on the "' + a.route.id + '" route'),
        (b = await w(E))
    st(
      b !== void 0,
      'You defined ' +
        (t === 'action' ? 'an action' : 'a loader') +
        ' for route ' +
        ('"' + a.route.id + '" but didn\'t return anything from your `' + t + '` ') +
        'function. Please return a value or `null`.'
    )
  } catch (E) {
    ;(g = sr.error), (b = E)
  } finally {
    C && r.signal.removeEventListener('abort', C)
  }
  if (XQ(b)) {
    let E = b.status
    if (NQ.has(E)) {
      let P = b.headers.get('Location')
      if (
        (st(P, 'Redirects returned/thrown from loaders/actions must have a Location header'),
        RM.test(P))
      ) {
        if (!p) {
          let B = new URL(r.url),
            j = P.startsWith('//') ? new URL(B.protocol + P) : new URL(P),
            Q = ip(j.pathname, c) != null
          j.origin === B.origin && Q && (P = j.pathname + j.search + j.hash)
        }
      } else {
        let B = o.slice(0, o.indexOf(a) + 1),
          j = Pv(B).map((Y) => Y.pathnameBase),
          Q = cC(P, j, new URL(r.url).pathname)
        if ((st(Ki(Q), 'Unable to resolve redirect location: ' + P), c)) {
          let Y = Q.pathname
          Q.pathname = Y === '/' ? c : Gi([c, Y])
        }
        P = Ki(Q)
      }
      if (p) throw (b.headers.set('Location', P), b)
      return {
        type: sr.redirect,
        status: E,
        location: P,
        revalidate: b.headers.get('X-Remix-Revalidate') !== null,
      }
    }
    if (h) throw { type: g || sr.data, response: b }
    let M,
      z = b.headers.get('Content-Type')
    return (
      z && /\bapplication\/json\b/.test(z) ? (M = await b.json()) : (M = await b.text()),
      g === sr.error
        ? { type: g, error: new fC(E, b.statusText, M), headers: b.headers }
        : { type: sr.data, data: M, statusCode: b.status, headers: b.headers }
    )
  }
  if (g === sr.error) return { type: g, error: b }
  if (KQ(b)) {
    var k, D
    return {
      type: sr.deferred,
      deferredData: b,
      statusCode: (k = b.init) == null ? void 0 : k.status,
      headers: ((D = b.init) == null ? void 0 : D.headers) && new Headers(b.init.headers),
    }
  }
  return { type: sr.data, data: b }
}
function rd(t, r, a, o) {
  let l = t.createURL(AM(r)).toString(),
    f = { signal: a }
  if (o && Ro(o.formMethod)) {
    let { formMethod: c, formEncType: p, formData: h } = o
    ;(f.method = c.toUpperCase()), (f.body = p === 'application/x-www-form-urlencoded' ? DM(h) : h)
  }
  return new Request(l, f)
}
function DM(t) {
  let r = new URLSearchParams()
  for (let [a, o] of t.entries()) r.append(a, o instanceof File ? o.name : o)
  return r
}
function GQ(t, r, a, o, l) {
  let f = {},
    c = null,
    p,
    h = !1,
    m = {}
  return (
    a.forEach((g, b) => {
      let C = r[b].route.id
      if ((st(!ec(g), 'Cannot handle redirect results in processLoaderData'), wd(g))) {
        let w = qu(t, C),
          k = g.error
        o && ((k = Object.values(o)[0]), (o = void 0)),
          (c = c || {}),
          c[w.route.id] == null && (c[w.route.id] = k),
          (f[C] = void 0),
          h || ((h = !0), (p = EM(g.error) ? g.error.status : 500)),
          g.headers && (m[C] = g.headers)
      } else
        Dl(g) ? (l.set(C, g.deferredData), (f[C] = g.deferredData.data)) : (f[C] = g.data),
          g.statusCode != null && g.statusCode !== 200 && !h && (p = g.statusCode),
          g.headers && (m[C] = g.headers)
    }),
    o && ((c = o), (f[Object.keys(o)[0]] = void 0)),
    { loaderData: f, errors: c, statusCode: p || 200, loaderHeaders: m }
  )
}
function dD(t, r, a, o, l, f, c, p) {
  let { loaderData: h, errors: m } = GQ(r, a, o, l, p)
  for (let g = 0; g < f.length; g++) {
    let { key: b, match: C } = f[g]
    st(c !== void 0 && c[g] !== void 0, 'Did not find corresponding fetcher result')
    let w = c[g]
    if (wd(w)) {
      let k = qu(t.matches, C == null ? void 0 : C.route.id)
      ;(m && m[k.route.id]) || (m = Ot({}, m, { [k.route.id]: w.error })), t.fetchers.delete(b)
    } else if (ec(w)) st(!1, 'Unhandled fetcher revalidation redirect')
    else if (Dl(w)) st(!1, 'Unhandled fetcher deferred data')
    else {
      let k = {
        'state': 'idle',
        'data': w.data,
        'formMethod': void 0,
        'formAction': void 0,
        'formEncType': void 0,
        'formData': void 0,
        ' _hasFetcherDoneAnything ': !0,
      }
      t.fetchers.set(b, k)
    }
  }
  return { loaderData: h, errors: m }
}
function pD(t, r, a, o) {
  let l = Ot({}, r)
  for (let f of a) {
    let c = f.route.id
    if (
      (r.hasOwnProperty(c)
        ? r[c] !== void 0 && (l[c] = r[c])
        : t[c] !== void 0 && f.route.loader && (l[c] = t[c]),
      o && o.hasOwnProperty(c))
    )
      break
  }
  return l
}
function qu(t, r) {
  return (
    (r ? t.slice(0, t.findIndex((o) => o.route.id === r) + 1) : [...t])
      .reverse()
      .find((o) => o.route.hasErrorBoundary === !0) || t[0]
  )
}
function hD(t) {
  let r = t.find((a) => a.index || !a.path || a.path === '/') || { id: '__shim-error-route__' }
  return { matches: [{ params: {}, pathname: '', pathnameBase: '', route: r }], route: r }
}
function Bi(t, r) {
  let { pathname: a, routeId: o, method: l, type: f } = r === void 0 ? {} : r,
    c = 'Unknown Server Error',
    p = 'Unknown @remix-run/router error'
  return (
    t === 400
      ? ((c = 'Bad Request'),
        l && a && o
          ? (p =
              'You made a ' +
              l +
              ' request to "' +
              a +
              '" but ' +
              ('did not provide a `loader` for route "' + o + '", ') +
              'so there is no way to handle the request.')
          : f === 'defer-action' && (p = 'defer() is not supported in actions'))
      : t === 403
      ? ((c = 'Forbidden'), (p = 'Route "' + o + '" does not match URL "' + a + '"'))
      : t === 404
      ? ((c = 'Not Found'), (p = 'No route matches URL "' + a + '"'))
      : t === 405 &&
        ((c = 'Method Not Allowed'),
        l && a && o
          ? (p =
              'You made a ' +
              l.toUpperCase() +
              ' request to "' +
              a +
              '" but ' +
              ('did not provide an `action` for route "' + o + '", ') +
              'so there is no way to handle the request.')
          : l && (p = 'Invalid request method "' + l.toUpperCase() + '"')),
    new fC(t || 500, c, new Error(p), !0)
  )
}
function mD(t) {
  for (let r = t.length - 1; r >= 0; r--) {
    let a = t[r]
    if (ec(a)) return a
  }
}
function AM(t) {
  let r = typeof t == 'string' ? $o(t) : t
  return Ki(Ot({}, r, { hash: '' }))
}
function qQ(t, r) {
  return t.pathname === r.pathname && t.search === r.search && t.hash !== r.hash
}
function Dl(t) {
  return t.type === sr.deferred
}
function wd(t) {
  return t.type === sr.error
}
function ec(t) {
  return (t && t.type) === sr.redirect
}
function KQ(t) {
  let r = t
  return (
    r &&
    typeof r == 'object' &&
    typeof r.data == 'object' &&
    typeof r.subscribe == 'function' &&
    typeof r.cancel == 'function' &&
    typeof r.resolveData == 'function'
  )
}
function XQ(t) {
  return (
    t != null &&
    typeof t.status == 'number' &&
    typeof t.statusText == 'string' &&
    typeof t.headers == 'object' &&
    typeof t.body < 'u'
  )
}
function QQ(t) {
  return FQ.has(t.toLowerCase())
}
function Ro(t) {
  return zQ.has(t.toLowerCase())
}
async function vD(t, r, a, o, l, f) {
  for (let c = 0; c < a.length; c++) {
    let p = a[c],
      h = r[c]
    if (!h) continue
    let m = t.find((b) => b.route.id === h.route.id),
      g = m != null && !kM(m, h) && (f && f[h.route.id]) !== void 0
    Dl(p) &&
      (l || g) &&
      (await OM(p, o, l).then((b) => {
        b && (a[c] = b || a[c])
      }))
  }
}
async function OM(t, r, a) {
  if ((a === void 0 && (a = !1), !(await t.deferredData.resolveData(r)))) {
    if (a)
      try {
        return { type: sr.data, data: t.deferredData.unwrappedData }
      } catch (l) {
        return { type: sr.error, error: l }
      }
    return { type: sr.data, data: t.deferredData.data }
  }
}
function MM(t) {
  return new URLSearchParams(t).getAll('index').some((r) => r === '')
}
function gD(t, r) {
  let { route: a, pathname: o, params: l } = t
  return { id: a.id, pathname: o, params: l, data: r[a.id], handle: a.handle }
}
function cx(t, r) {
  let a = typeof r == 'string' ? $o(r).search : r.search
  if (t[t.length - 1].route.index && MM(a || '')) return t[t.length - 1]
  let o = Pv(t)
  return o[o.length - 1]
}
/**
 * React Router v6.10.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function ZQ(t, r) {
  return (t === r && (t !== 0 || 1 / t === 1 / r)) || (t !== t && r !== r)
}
const PM = typeof Object.is == 'function' ? Object.is : ZQ,
  { useState: JQ, useEffect: eZ, useLayoutEffect: tZ, useDebugValue: nZ } = tc
let yD = !1,
  bD = !1
function rZ(t, r, a) {
  yD ||
    ('startTransition' in tc &&
      ((yD = !0),
      console.error(
        'You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.'
      )))
  const o = r()
  if (!bD) {
    const c = r()
    PM(o, c) ||
      (console.error('The result of getSnapshot should be cached to avoid an infinite loop'),
      (bD = !0))
  }
  const [{ inst: l }, f] = JQ({ inst: { value: o, getSnapshot: r } })
  return (
    tZ(() => {
      ;(l.value = o), (l.getSnapshot = r), SS(l) && f({ inst: l })
    }, [t, o, r]),
    eZ(
      () => (
        SS(l) && f({ inst: l }),
        t(() => {
          SS(l) && f({ inst: l })
        })
      ),
      [t]
    ),
    nZ(o),
    o
  )
}
function SS(t) {
  const r = t.getSnapshot,
    a = t.value
  try {
    const o = r()
    return !PM(a, o)
  } catch {
    return !0
  }
}
function aZ(t, r, a) {
  return r()
}
const iZ =
    typeof window < 'u' &&
    typeof window.document < 'u' &&
    typeof window.document.createElement < 'u',
  oZ = !iZ,
  sZ = oZ ? aZ : rZ,
  lZ = 'useSyncExternalStore' in tc ? ((t) => t.useSyncExternalStore)(tc) : sZ,
  op = R.createContext(null)
op.displayName = 'DataRouter'
const pc = R.createContext(null)
pc.displayName = 'DataRouterState'
const uZ = R.createContext(null)
uZ.displayName = 'Await'
const Fo = R.createContext(null)
Fo.displayName = 'Navigation'
const sp = R.createContext(null)
sp.displayName = 'Location'
const No = R.createContext({ outlet: null, matches: [] })
No.displayName = 'Route'
const dC = R.createContext(null)
dC.displayName = 'RouteError'
function fx() {
  return (
    (fx = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var r = 1; r < arguments.length; r++) {
            var a = arguments[r]
            for (var o in a) Object.prototype.hasOwnProperty.call(a, o) && (t[o] = a[o])
          }
          return t
        }),
    fx.apply(this, arguments)
  )
}
function cZ(t, r) {
  let { relative: a } = r === void 0 ? {} : r
  hc() || st(!1, 'useHref() may be used only in the context of a <Router> component.')
  let { basename: o, navigator: l } = R.useContext(Fo),
    { hash: f, pathname: c, search: p } = Lv(t, { relative: a }),
    h = c
  return (
    o !== '/' && (h = c === '/' ? o : Gi([o, c])), l.createHref({ pathname: h, search: p, hash: f })
  )
}
function hc() {
  return R.useContext(sp) != null
}
function mc() {
  return (
    hc() || st(!1, 'useLocation() may be used only in the context of a <Router> component.'),
    R.useContext(sp).location
  )
}
function LM() {
  hc() || st(!1, 'useNavigate() may be used only in the context of a <Router> component.')
  let { basename: t, navigator: r } = R.useContext(Fo),
    { matches: a } = R.useContext(No),
    { pathname: o } = mc(),
    l = JSON.stringify(Pv(a).map((p) => p.pathnameBase)),
    f = R.useRef(!1)
  return (
    R.useEffect(() => {
      f.current = !0
    }),
    R.useCallback(
      function (p, h) {
        if (
          (h === void 0 && (h = {}),
          ma(
            f.current,
            'You should call navigate() in a React.useEffect(), not when your component is first rendered.'
          ),
          !f.current)
        )
          return
        if (typeof p == 'number') {
          r.go(p)
          return
        }
        let m = cC(p, JSON.parse(l), o, h.relative === 'path')
        t !== '/' && (m.pathname = m.pathname === '/' ? t : Gi([t, m.pathname])),
          (h.replace ? r.replace : r.push)(m, h.state, h)
      },
      [t, r, l, o]
    )
  )
}
const fZ = R.createContext(null)
function dZ(t) {
  let r = R.useContext(No).outlet
  return r && R.createElement(fZ.Provider, { value: t }, r)
}
function Lv(t, r) {
  let { relative: a } = r === void 0 ? {} : r,
    { matches: o } = R.useContext(No),
    { pathname: l } = mc(),
    f = JSON.stringify(Pv(o).map((c) => c.pathnameBase))
  return R.useMemo(() => cC(t, JSON.parse(f), l, a === 'path'), [t, f, l, a])
}
function pZ(t, r) {
  hc() || st(!1, 'useRoutes() may be used only in the context of a <Router> component.')
  let { navigator: a } = R.useContext(Fo),
    o = R.useContext(pc),
    { matches: l } = R.useContext(No),
    f = l[l.length - 1],
    c = f ? f.params : {},
    p = f ? f.pathname : '/',
    h = f ? f.pathnameBase : '/',
    m = f && f.route
  {
    let M = (m && m.path) || ''
    CZ(
      p,
      !m || M.endsWith('*'),
      'You rendered descendant <Routes> (or called `useRoutes()`) at ' +
        ('"' + p + '" (under <Route path="' + M + '">) but the ') +
        `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` +
        ('Please change the parent <Route path="' + M + '"> to <Route ') +
        ('path="' + (M === '/' ? '*' : M + '/*') + '">.')
    )
  }
  let g = mc(),
    b
  if (r) {
    var C
    let M = typeof r == 'string' ? $o(r) : r
    h === '/' ||
      ((C = M.pathname) != null && C.startsWith(h)) ||
      st(
        !1,
        'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was ' +
          ('matched by all parent routes. The current pathname base is "' + h + '" ') +
          ('but pathname "' + M.pathname + '" was given in the `location` prop.')
      ),
      (b = M)
  } else b = g
  let w = b.pathname || '/',
    k = h === '/' ? w : w.slice(h.length) || '/',
    D = Gu(t, { pathname: k })
  ma(m || D != null, 'No routes matched location "' + b.pathname + b.search + b.hash + '" '),
    ma(
      D == null ||
        D[D.length - 1].route.element !== void 0 ||
        D[D.length - 1].route.Component !== void 0,
      'Matched leaf route at location "' +
        b.pathname +
        b.search +
        b.hash +
        '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'
    )
  let E = gZ(
    D &&
      D.map((M) =>
        Object.assign({}, M, {
          params: Object.assign({}, c, M.params),
          pathname: Gi([h, a.encodeLocation ? a.encodeLocation(M.pathname).pathname : M.pathname]),
          pathnameBase:
            M.pathnameBase === '/'
              ? h
              : Gi([
                  h,
                  a.encodeLocation ? a.encodeLocation(M.pathnameBase).pathname : M.pathnameBase,
                ]),
        })
      ),
    l,
    o || void 0
  )
  return r && E
    ? R.createElement(
        sp.Provider,
        {
          value: {
            location: fx({ pathname: '/', search: '', hash: '', state: null, key: 'default' }, b),
            navigationType: Gn.Pop,
          },
        },
        E
      )
    : E
}
function hZ() {
  let t = xZ(),
    r = EM(t) ? t.status + ' ' + t.statusText : t instanceof Error ? t.message : JSON.stringify(t),
    a = t instanceof Error ? t.stack : null,
    o = 'rgba(200,200,200, 0.5)',
    l = { padding: '0.5rem', backgroundColor: o },
    f = { padding: '2px 4px', backgroundColor: o },
    c = null
  return (
    (c = R.createElement(
      R.Fragment,
      null,
      R.createElement('p', null, '💿 Hey developer 👋'),
      R.createElement(
        'p',
        null,
        'You can provide a way better UX than this when your app throws errors by providing your own ',
        R.createElement('code', { style: f }, 'ErrorBoundary'),
        ' prop on ',
        R.createElement('code', { style: f }, '<Route>')
      )
    )),
    R.createElement(
      R.Fragment,
      null,
      R.createElement('h2', null, 'Unexpected Application Error!'),
      R.createElement('h3', { style: { fontStyle: 'italic' } }, r),
      a ? R.createElement('pre', { style: l }, a) : null,
      c
    )
  )
}
class mZ extends R.Component {
  constructor(r) {
    super(r), (this.state = { location: r.location, error: r.error })
  }
  static getDerivedStateFromError(r) {
    return { error: r }
  }
  static getDerivedStateFromProps(r, a) {
    return a.location !== r.location
      ? { error: r.error, location: r.location }
      : { error: r.error || a.error, location: a.location }
  }
  componentDidCatch(r, a) {
    console.error('React Router caught the following error during render', r, a)
  }
  render() {
    return this.state.error
      ? R.createElement(
          No.Provider,
          { value: this.props.routeContext },
          R.createElement(dC.Provider, { value: this.state.error, children: this.props.component })
        )
      : this.props.children
  }
}
function vZ(t) {
  let { routeContext: r, match: a, children: o } = t,
    l = R.useContext(op)
  return (
    l &&
      l.static &&
      l.staticContext &&
      (a.route.errorElement || a.route.ErrorBoundary) &&
      (l.staticContext._deepestRenderedBoundaryId = a.route.id),
    R.createElement(No.Provider, { value: r }, o)
  )
}
function gZ(t, r, a) {
  if ((r === void 0 && (r = []), t == null))
    if (a != null && a.errors) t = a.matches
    else return null
  let o = t,
    l = a == null ? void 0 : a.errors
  if (l != null) {
    let f = o.findIndex((c) => c.route.id && (l == null ? void 0 : l[c.route.id]))
    f >= 0 || st(!1, 'Could not find a matching route for the current errors: ' + l),
      (o = o.slice(0, Math.min(o.length, f + 1)))
  }
  return o.reduceRight((f, c, p) => {
    let h = c.route.id ? (l == null ? void 0 : l[c.route.id]) : null,
      m = null
    a &&
      (c.route.ErrorBoundary
        ? (m = R.createElement(c.route.ErrorBoundary, null))
        : c.route.errorElement
        ? (m = c.route.errorElement)
        : (m = R.createElement(hZ, null)))
    let g = r.concat(o.slice(0, p + 1)),
      b = () => {
        let C = f
        return (
          h
            ? (C = m)
            : c.route.Component
            ? (C = R.createElement(c.route.Component, null))
            : c.route.element && (C = c.route.element),
          R.createElement(vZ, { match: c, routeContext: { outlet: f, matches: g }, children: C })
        )
      }
    return a && (c.route.ErrorBoundary || c.route.errorElement || p === 0)
      ? R.createElement(mZ, {
          location: a.location,
          component: m,
          error: h,
          children: b(),
          routeContext: { outlet: null, matches: g },
        })
      : b()
  }, null)
}
var SD
;(function (t) {
  ;(t.UseBlocker = 'useBlocker'), (t.UseRevalidator = 'useRevalidator')
})(SD || (SD = {}))
var iv
;(function (t) {
  ;(t.UseBlocker = 'useBlocker'),
    (t.UseLoaderData = 'useLoaderData'),
    (t.UseActionData = 'useActionData'),
    (t.UseRouteError = 'useRouteError'),
    (t.UseNavigation = 'useNavigation'),
    (t.UseRouteLoaderData = 'useRouteLoaderData'),
    (t.UseMatches = 'useMatches'),
    (t.UseRevalidator = 'useRevalidator')
})(iv || (iv = {}))
function zM(t) {
  return (
    t + ' must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.'
  )
}
function yZ(t) {
  let r = R.useContext(pc)
  return r || st(!1, zM(t)), r
}
function bZ(t) {
  let r = R.useContext(No)
  return r || st(!1, zM(t)), r
}
function SZ(t) {
  let r = bZ(t),
    a = r.matches[r.matches.length - 1]
  return (
    a.route.id || st(!1, t + ' can only be used on routes that contain a unique "id"'), a.route.id
  )
}
function xZ() {
  var t
  let r = R.useContext(dC),
    a = yZ(iv.UseRouteError),
    o = SZ(iv.UseRouteError)
  return r || ((t = a.errors) == null ? void 0 : t[o])
}
const xD = {}
function CZ(t, r, a) {
  !r && !xD[t] && ((xD[t] = !0), ma(!1, a))
}
function wZ(t) {
  let { fallbackElement: r, router: a } = t,
    o = R.useCallback(() => a.state, [a]),
    l = lZ(a.subscribe, o, o),
    f = R.useMemo(
      () => ({
        createHref: a.createHref,
        encodeLocation: a.encodeLocation,
        go: (h) => a.navigate(h),
        push: (h, m, g) =>
          a.navigate(h, {
            state: m,
            preventScrollReset: g == null ? void 0 : g.preventScrollReset,
          }),
        replace: (h, m, g) =>
          a.navigate(h, {
            replace: !0,
            state: m,
            preventScrollReset: g == null ? void 0 : g.preventScrollReset,
          }),
      }),
      [a]
    ),
    c = a.basename || '/',
    p = R.useMemo(() => ({ router: a, navigator: f, static: !1, basename: c }), [a, f, c])
  return R.createElement(
    R.Fragment,
    null,
    R.createElement(
      op.Provider,
      { value: p },
      R.createElement(
        pc.Provider,
        { value: l },
        R.createElement(
          _Z,
          {
            basename: a.basename,
            location: a.state.location,
            navigationType: a.state.historyAction,
            navigator: f,
          },
          a.state.initialized ? R.createElement(kZ, null) : r
        )
      )
    ),
    null
  )
}
function EZ(t) {
  let { to: r, replace: a, state: o, relative: l } = t
  hc() || st(!1, '<Navigate> may be used only in the context of a <Router> component.'),
    ma(
      !R.useContext(Fo).static,
      '<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.'
    )
  let f = R.useContext(pc),
    c = LM()
  return (
    R.useEffect(() => {
      ;(f && f.navigation.state !== 'idle') || c(r, { replace: a, state: o, relative: l })
    }),
    null
  )
}
function TZ(t) {
  return dZ(t.context)
}
function RZ(t) {
  st(
    !1,
    'A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.'
  )
}
function _Z(t) {
  let {
    basename: r = '/',
    children: a = null,
    location: o,
    navigationType: l = Gn.Pop,
    navigator: f,
    static: c = !1,
  } = t
  hc() &&
    st(
      !1,
      'You cannot render a <Router> inside another <Router>. You should never have more than one in your app.'
    )
  let p = r.replace(/^\/*/, '/'),
    h = R.useMemo(() => ({ basename: p, navigator: f, static: c }), [p, f, c])
  typeof o == 'string' && (o = $o(o))
  let { pathname: m = '/', search: g = '', hash: b = '', state: C = null, key: w = 'default' } = o,
    k = R.useMemo(() => {
      let D = ip(m, p)
      return D == null
        ? null
        : { location: { pathname: D, search: g, hash: b, state: C, key: w }, navigationType: l }
    }, [p, m, g, b, C, w, l])
  return (
    ma(
      k != null,
      '<Router basename="' +
        p +
        '"> is not able to match the URL ' +
        ('"' + m + g + b + '" because it does not start with the ') +
        "basename, so the <Router> won't render anything."
    ),
    k == null
      ? null
      : R.createElement(
          Fo.Provider,
          { value: h },
          R.createElement(sp.Provider, { children: a, value: k })
        )
  )
}
function kZ(t) {
  let { children: r, location: a } = t,
    o = R.useContext(op),
    l = o && !r ? o.router.routes : dx(r)
  return pZ(l, a)
}
var CD
;(function (t) {
  ;(t[(t.pending = 0)] = 'pending'), (t[(t.success = 1)] = 'success'), (t[(t.error = 2)] = 'error')
})(CD || (CD = {}))
new Promise(() => {})
function dx(t, r) {
  r === void 0 && (r = [])
  let a = []
  return (
    R.Children.forEach(t, (o, l) => {
      if (!R.isValidElement(o)) return
      let f = [...r, l]
      if (o.type === R.Fragment) {
        a.push.apply(a, dx(o.props.children, f))
        return
      }
      o.type !== RZ &&
        st(
          !1,
          '[' +
            (typeof o.type == 'string' ? o.type : o.type.name) +
            '] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>'
        ),
        !o.props.index || !o.props.children || st(!1, 'An index route cannot have child routes.')
      let c = {
        id: o.props.id || f.join('-'),
        caseSensitive: o.props.caseSensitive,
        element: o.props.element,
        Component: o.props.Component,
        index: o.props.index,
        path: o.props.path,
        loader: o.props.loader,
        action: o.props.action,
        errorElement: o.props.errorElement,
        ErrorBoundary: o.props.ErrorBoundary,
        hasErrorBoundary: o.props.ErrorBoundary != null || o.props.errorElement != null,
        shouldRevalidate: o.props.shouldRevalidate,
        handle: o.props.handle,
        lazy: o.props.lazy,
      }
      o.props.children && (c.children = dx(o.props.children, f)), a.push(c)
    }),
    a
  )
}
function DZ(t) {
  return (
    t.Component &&
      t.element &&
      ma(
        !1,
        'You should not include both `Component` and `element` on your route - `element` will be ignored.'
      ),
    t.ErrorBoundary &&
      t.errorElement &&
      ma(
        !1,
        'You should not include both `ErrorBoundary` and `errorElement` on your route - `errorElement` will be ignored.'
      ),
    !!t.ErrorBoundary || !!t.errorElement
  )
}
/**
 * React Router DOM v6.10.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Ms() {
  return (
    (Ms = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var r = 1; r < arguments.length; r++) {
            var a = arguments[r]
            for (var o in a) Object.prototype.hasOwnProperty.call(a, o) && (t[o] = a[o])
          }
          return t
        }),
    Ms.apply(this, arguments)
  )
}
function pC(t, r) {
  if (t == null) return {}
  var a = {},
    o = Object.keys(t),
    l,
    f
  for (f = 0; f < o.length; f++) (l = o[f]), !(r.indexOf(l) >= 0) && (a[l] = t[l])
  return a
}
const $m = 'get',
  xS = 'application/x-www-form-urlencoded'
function zv(t) {
  return t != null && typeof t.tagName == 'string'
}
function AZ(t) {
  return zv(t) && t.tagName.toLowerCase() === 'button'
}
function OZ(t) {
  return zv(t) && t.tagName.toLowerCase() === 'form'
}
function MZ(t) {
  return zv(t) && t.tagName.toLowerCase() === 'input'
}
function PZ(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)
}
function LZ(t, r) {
  return t.button === 0 && (!r || r === '_self') && !PZ(t)
}
function zZ(t, r, a) {
  let o, l, f, c
  if (OZ(t)) {
    let g = a.submissionTrigger
    ;(o = a.method || t.getAttribute('method') || $m),
      (l = a.action || t.getAttribute('action') || r),
      (f = a.encType || t.getAttribute('enctype') || xS),
      (c = new FormData(t)),
      g && g.name && c.append(g.name, g.value)
  } else if (AZ(t) || (MZ(t) && (t.type === 'submit' || t.type === 'image'))) {
    let g = t.form
    if (g == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>')
    ;(o = a.method || t.getAttribute('formmethod') || g.getAttribute('method') || $m),
      (l = a.action || t.getAttribute('formaction') || g.getAttribute('action') || r),
      (f = a.encType || t.getAttribute('formenctype') || g.getAttribute('enctype') || xS),
      (c = new FormData(g)),
      t.name && c.append(t.name, t.value)
  } else {
    if (zv(t))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      )
    if (((o = a.method || $m), (l = a.action || r), (f = a.encType || xS), t instanceof FormData))
      c = t
    else if (((c = new FormData()), t instanceof URLSearchParams))
      for (let [g, b] of t) c.append(g, b)
    else if (t != null) for (let g of Object.keys(t)) c.append(g, t[g])
  }
  let { protocol: p, host: h } = window.location
  return { url: new URL(l, p + '//' + h), method: o.toLowerCase(), encType: f, formData: c }
}
const $Z = [
    'onClick',
    'relative',
    'reloadDocument',
    'replace',
    'state',
    'target',
    'to',
    'preventScrollReset',
  ],
  FZ = ['aria-current', 'caseSensitive', 'className', 'end', 'style', 'to', 'children'],
  NZ = [
    'reloadDocument',
    'replace',
    'method',
    'action',
    'onSubmit',
    'fetcherKey',
    'routeId',
    'relative',
    'preventScrollReset',
  ]
function BZ(t, r) {
  return IQ({
    basename: r == null ? void 0 : r.basename,
    future: r == null ? void 0 : r.future,
    history: fQ({ window: r == null ? void 0 : r.window }),
    hydrationData: (r == null ? void 0 : r.hydrationData) || jZ(),
    routes: t,
    detectErrorBoundary: DZ,
  }).initialize()
}
function jZ() {
  var t
  let r = (t = window) == null ? void 0 : t.__staticRouterHydrationData
  return r && r.errors && (r = Ms({}, r, { errors: UZ(r.errors) })), r
}
function UZ(t) {
  if (!t) return null
  let r = Object.entries(t),
    a = {}
  for (let [o, l] of r)
    if (l && l.__type === 'RouteErrorResponse')
      a[o] = new fC(l.status, l.statusText, l.data, l.internal === !0)
    else if (l && l.__type === 'Error') {
      let f = new Error(l.message)
      ;(f.stack = ''), (a[o] = f)
    } else a[o] = l
  return a
}
const VZ =
    typeof window < 'u' &&
    typeof window.document < 'u' &&
    typeof window.document.createElement < 'u',
  IZ = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  qr = R.forwardRef(function (r, a) {
    let {
        onClick: o,
        relative: l,
        reloadDocument: f,
        replace: c,
        state: p,
        target: h,
        to: m,
        preventScrollReset: g,
      } = r,
      b = pC(r, $Z),
      { basename: C } = R.useContext(Fo),
      w,
      k = !1
    if (typeof m == 'string' && IZ.test(m) && ((w = m), VZ)) {
      let z = new URL(window.location.href),
        P = m.startsWith('//') ? new URL(z.protocol + m) : new URL(m),
        B = ip(P.pathname, C)
      P.origin === z.origin && B != null ? (m = B + P.search + P.hash) : (k = !0)
    }
    let D = cZ(m, { relative: l }),
      E = qZ(m, { replace: c, state: p, target: h, preventScrollReset: g, relative: l })
    function M(z) {
      o && o(z), z.defaultPrevented || E(z)
    }
    return R.createElement(
      'a',
      Ms({}, b, { href: w || D, onClick: k || f ? o : M, ref: a, target: h })
    )
  })
qr.displayName = 'Link'
const HZ = R.forwardRef(function (r, a) {
  let {
      'aria-current': o = 'page',
      'caseSensitive': l = !1,
      'className': f = '',
      'end': c = !1,
      'style': p,
      'to': h,
      'children': m,
    } = r,
    g = pC(r, FZ),
    b = Lv(h, { relative: g.relative }),
    C = mc(),
    w = R.useContext(pc),
    { navigator: k } = R.useContext(Fo),
    D = k.encodeLocation ? k.encodeLocation(b).pathname : b.pathname,
    E = C.pathname,
    M = w && w.navigation && w.navigation.location ? w.navigation.location.pathname : null
  l || ((E = E.toLowerCase()), (M = M ? M.toLowerCase() : null), (D = D.toLowerCase()))
  let z = E === D || (!c && E.startsWith(D) && E.charAt(D.length) === '/'),
    P = M != null && (M === D || (!c && M.startsWith(D) && M.charAt(D.length) === '/')),
    B = z ? o : void 0,
    j
  typeof f == 'function'
    ? (j = f({ isActive: z, isPending: P }))
    : (j = [f, z ? 'active' : null, P ? 'pending' : null].filter(Boolean).join(' '))
  let Q = typeof p == 'function' ? p({ isActive: z, isPending: P }) : p
  return R.createElement(
    qr,
    Ms({}, g, { 'aria-current': B, 'className': j, 'ref': a, 'style': Q, 'to': h }),
    typeof m == 'function' ? m({ isActive: z, isPending: P }) : m
  )
})
HZ.displayName = 'NavLink'
const WZ = R.forwardRef((t, r) => R.createElement($M, Ms({}, t, { ref: r })))
WZ.displayName = 'Form'
const $M = R.forwardRef((t, r) => {
  let {
      reloadDocument: a,
      replace: o,
      method: l = $m,
      action: f,
      onSubmit: c,
      fetcherKey: p,
      routeId: h,
      relative: m,
      preventScrollReset: g,
    } = t,
    b = pC(t, NZ),
    C = KZ(p, h),
    w = l.toLowerCase() === 'get' ? 'get' : 'post',
    k = FM(f, { relative: m }),
    D = (E) => {
      if ((c && c(E), E.defaultPrevented)) return
      E.preventDefault()
      let M = E.nativeEvent.submitter,
        z = (M == null ? void 0 : M.getAttribute('formmethod')) || l
      C(M || E.currentTarget, { method: z, replace: o, relative: m, preventScrollReset: g })
    }
  return R.createElement('form', Ms({ ref: r, method: w, action: k, onSubmit: a ? c : D }, b))
})
$M.displayName = 'FormImpl'
var px
;(function (t) {
  ;(t.UseScrollRestoration = 'useScrollRestoration'),
    (t.UseSubmitImpl = 'useSubmitImpl'),
    (t.UseFetcher = 'useFetcher')
})(px || (px = {}))
var wD
;(function (t) {
  ;(t.UseFetchers = 'useFetchers'), (t.UseScrollRestoration = 'useScrollRestoration')
})(wD || (wD = {}))
function YZ(t) {
  return (
    t + ' must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.'
  )
}
function GZ(t) {
  let r = R.useContext(op)
  return r || st(!1, YZ(t)), r
}
function qZ(t, r) {
  let {
      target: a,
      replace: o,
      state: l,
      preventScrollReset: f,
      relative: c,
    } = r === void 0 ? {} : r,
    p = LM(),
    h = mc(),
    m = Lv(t, { relative: c })
  return R.useCallback(
    (g) => {
      if (LZ(g, a)) {
        g.preventDefault()
        let b = o !== void 0 ? o : Ki(h) === Ki(m)
        p(t, { replace: b, state: l, preventScrollReset: f, relative: c })
      }
    },
    [h, p, m, o, l, a, t, f, c]
  )
}
function KZ(t, r) {
  let { router: a } = GZ(px.UseSubmitImpl),
    o = FM()
  return R.useCallback(
    function (l, f) {
      if ((f === void 0 && (f = {}), typeof document > 'u'))
        throw new Error(
          'You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.'
        )
      let { method: c, encType: p, formData: h, url: m } = zZ(l, o, f),
        g = m.pathname + m.search,
        b = {
          replace: f.replace,
          preventScrollReset: f.preventScrollReset,
          formData: h,
          formMethod: c,
          formEncType: p,
        }
      t
        ? (r == null && st(!1, 'No routeId available for useFetcher()'), a.fetch(t, r, g, b))
        : a.navigate(g, b)
    },
    [o, a, t, r]
  )
}
function FM(t, r) {
  let { relative: a } = r === void 0 ? {} : r,
    { basename: o } = R.useContext(Fo),
    l = R.useContext(No)
  l || st(!1, 'useFormAction must be used inside a RouteContext')
  let [f] = l.matches.slice(-1),
    c = Ms({}, Lv(t || '.', { relative: a })),
    p = mc()
  if (t == null && ((c.search = p.search), (c.hash = p.hash), f.route.index)) {
    let h = new URLSearchParams(c.search)
    h.delete('index'), (c.search = h.toString() ? '?' + h.toString() : '')
  }
  return (
    (!t || t === '.') &&
      f.route.index &&
      (c.search = c.search ? c.search.replace(/^\?/, '?index&') : '?index'),
    o !== '/' && (c.pathname = c.pathname === '/' ? o : Gi([o, c.pathname])),
    Ki(c)
  )
}
function XZ(t, r, a, o, l) {
  for (r = r.split ? r.split('.') : r, o = 0; o < r.length; o++) t = t ? t[r[o]] : l
  return t === l ? a : t
}
var ov = (t, r, a) => {
    const o = XZ(t, `colors.${r}`, r)
    try {
      return kx(o), o
    } catch {
      return a ?? '#000000'
    }
  },
  Nr = (t, r) => (a) => {
    const o = ov(a, t)
    return eA(o, 1 - r)
  },
  Iu = (t, r) => (a) => {
    const o = ov(a, t)
    return kx(a3(o, r / 100))
  }
function ft(t, r) {
  return (a) => (a.colorMode === 'dark' ? r : t)
}
const QZ = { textTransform: 'normal', fontWeight: 'medium', borderRadius: '2xl' },
  ZZ = {
    lg: { fontSize: 'sm', px: '3', py: '1' },
    md: { fontSize: 'sm', lineHeight: '1.25rem', px: '2.5', py: '0.5' },
    sm: { fontSize: 'xs', lineHeight: '1.5', px: '2', py: '0.5' },
  },
  JZ = {
    subtle: (t) => ({
      bg: ft(Iu(`${t.colorScheme}.50`, 2)(t.theme), Nr(`${t.colorScheme}.200`, 0.16)(t.theme))(t),
    }),
  },
  eJ = { size: 'md', variant: 'subtle' },
  tJ = { baseStyle: QZ, defaultProps: eJ, variants: JZ, sizes: ZZ },
  nJ = {
    ':focus:not(:focus-visible)': { boxShadow: 'none' },
    'fontWeight': 'semibold',
    'borderRadius': 'lg',
  },
  rJ = { lg: { fontSize: 'md' }, xl: { h: '3.75rem', minW: '3.75rem', fontSize: 'lg', px: 7 } },
  aJ = {
    'primary': (t) =>
      t.theme.components.Button.variants.solid({ ...t, variant: 'solid', colorScheme: 'brand' }),
    'primary-on-accent': () => ({
      bg: 'brand.50',
      color: 'brand.600',
      _hover: { bg: 'brand.100' },
      _active: { bg: 'brand.100' },
    }),
    'secondary': (t) =>
      t.theme.components.Button.variants.outline({ ...t, variant: 'outline', colorScheme: 'gray' }),
    'secondary-on-accent': {
      color: 'white',
      borderColor: 'brand.50',
      borderWidth: '1px',
      _hover: { bg: 'whiteAlpha.200' },
      _active: { bg: 'whiteAlpha.200' },
    },
    'outline': (t) => ({
      color: 'emphasized',
      bg: ft('white', 'gray.800')(t),
      _hover: { bg: ft(Iu('gray.50', 1)(t.theme), Nr('gray.700', 0.4)(t.theme))(t) },
      _checked: { bg: ft('gray.100', 'gray.700')(t) },
      _active: { bg: ft('gray.100', 'gray.700')(t) },
    }),
    'ghost': (t) => ({
      color: 'emphasized',
      _hover: { bg: ft(Iu('gray.50', 1)(t.theme), Iu('gray.700', 4)(t.theme))(t) },
      _active: { bg: ft(Iu('gray.50', 1)(t.theme), Iu('gray.700', 4)(t.theme))(t) },
      _activeLink: { bg: ft('gray.100', 'gray.700')(t) },
    }),
    'ghost-on-accent': (t) => ({
      color: 'brand.50',
      _hover: { bg: Nr('brand.500', 0.67)(t.theme) },
      _activeLink: { color: 'white', bg: 'bg-accent-subtle' },
    }),
    'link': (t) =>
      t.colorScheme === 'gray'
        ? {
            color: 'muted',
            _hover: { textDecoration: 'none', color: 'default' },
            _active: { color: 'default' },
          }
        : {
            color: ft(`${t.colorScheme}.600`, `${t.colorScheme}.200`)(t),
            _hover: {
              color: ft(`${t.colorScheme}.700`, `${t.colorScheme}.300`)(t),
              textDecoration: 'none',
            },
            _active: { color: ft(`${t.colorScheme}.700`, `${t.colorScheme}.300`)(t) },
          },
    'link-on-accent': () => ({
      padding: 0,
      height: 'auto',
      lineHeight: 'normal',
      verticalAlign: 'baseline',
      color: 'brand.50',
      _hover: { color: 'white' },
      _active: { color: 'white' },
    }),
  },
  iJ = { baseStyle: nJ, variants: aJ, sizes: rJ },
  oJ = (t) => ({
    label: { color: 'muted', fontWeight: 'medium' },
    control: { bg: ft('white', 'gray.800')(t), borderRadius: 'base' },
  }),
  sJ = { md: { label: { fontSize: 'sm' } } },
  lJ = { colorScheme: 'brand' },
  uJ = { baseStyle: oJ, sizes: sJ, defaultProps: lJ },
  cJ = { _focus: { boxShadow: 'none' }, _focusVisible: { boxShadow: 'outline' } },
  fJ = { baseStyle: cJ },
  dJ = { maxW: '7xl', px: { base: '4', md: '8' } },
  pJ = { baseStyle: dJ },
  hJ = ['field', 'menu', 'option'],
  mJ = {
    field: {
      width: '100%',
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      transition: 'all 50ms ease',
    },
    option: {
      display: 'flex',
      alignItems: 'center',
      cursor: 'pointer',
      _disabled: { opacity: 0.4, cursor: 'not-allowed' },
    },
    menu: { minW: '3xs' },
  },
  vJ = {
    outline: (t) => ({
      menu: {
        bg: ft('white', 'gray.800')(t),
        boxShadow: 'sm',
        color: 'inherit',
        minW: '3xs',
        py: '2',
        borderRadius: 'md',
        borderWidth: '1px',
      },
      option: { _selected: { bg: ft('gray.100', 'gray.700')(t) } },
      field: {
        border: '1px solid',
        borderColor: 'inherit',
        bg: ft('white', 'gray.800')(t),
        _hover: { borderColor: ft('gray.300', 'whiteAlpha.400')(t) },
        _disabled: { opacity: 0.4, cursor: 'not-allowed', borderColor: 'inherit' },
        _readOnly: { boxShadow: 'none !important', userSelect: 'all' },
        _invalid: {
          borderColor: ov(t.theme, ft('red.500', 'red.300')(t)),
          boxShadow: `0 0 0 1px ${ov(t.theme, ft('red.500', 'red.300')(t))}`,
        },
        _focus: {
          borderColor: ft('brand.500', 'brand.200')(t),
          boxShadow: ft(
            `0px 0px 0px 1px ${Nr('brand.500', 1)(t.theme)}`,
            `0px 0px 0px 1px ${Nr('brand.200', 1)(t.theme)}`
          )(t),
        },
        _expanded: {
          borderColor: ft('brand.500', 'brand.200')(t),
          boxShadow: ft(
            `0px 0px 0px 1px ${Nr('brand.500', 1)(t.theme)}`,
            `0px 0px 0px 1px ${Nr('brand.200', 1)(t.theme)}`
          )(t),
        },
      },
    }),
  },
  gJ = {
    sm: {
      field: { px: 3, h: 8, fontSize: 'sm', borderRadius: 'sm' },
      menu: { fontSize: 'sm', borderRadius: 'sm' },
      option: { px: 3, h: 8, fontSize: 'sm' },
    },
    md: {
      field: { px: 4, h: 10, fontSize: 'md', borderRadius: 'md' },
      menu: { fontSize: 'md', borderRadius: 'md' },
      option: { px: 4, h: 10, fontSize: 'md' },
    },
    lg: {
      field: { px: 4, h: 12, fontSize: 'lg', borderRadius: 'md' },
      menu: { fontSize: 'lg', borderRadius: 'md' },
      option: { px: 4, h: 12, fontSize: 'lg' },
    },
  },
  yJ = {
    parts: hJ,
    baseStyle: mJ,
    variants: vJ,
    sizes: gJ,
    defaultProps: { size: 'md', variant: 'outline', colorScheme: 'brand' },
  },
  bJ = { baseStyle: { opacity: 1 } },
  SJ = { color: 'emphasized', mb: '1.5', fontSize: 'sm' },
  xJ = {
    sm: { _peerPlaceholderShown: { fontSize: 'sm', top: '1.5', left: '4' } },
    md: { _peerPlaceholderShown: { fontSize: 'md', top: '2', left: '4' } },
    lg: { _peerPlaceholderShown: { fontSize: 'lg', top: '2.5', left: '4' } },
  },
  CJ = {
    inline: () => ({ margin: 0, minW: '2xs' }),
    floating: () => ({
      position: 'absolute',
      transition: 'all 0.12s ease-in',
      pointerEvents: 'none',
      top: '-27px',
      left: '0',
      _peerPlaceholderShown: { fontWeight: 'normal', color: 'subtle' },
      _peerFocus: { fontSize: 'sm', fontWeight: 'medium', top: '-27px', left: '0', color: 'muted' },
    }),
  },
  wJ = { size: 'md' },
  EJ = { baseStyle: SJ, sizes: xJ, variants: CJ, defaultProps: wJ },
  TJ = { fontWeight: 'semibold' },
  RJ = {
    '2xl': { fontSize: '7xl', lineHeight: '5.625rem', letterSpacing: 'tight' },
    'xl': { fontSize: '6xl', lineHeight: '4.5rem', letterSpacing: 'tight' },
    'lg': { fontSize: '5xl', lineHeight: '3.75rem', letterSpacing: 'tight' },
    'md': { fontSize: '4xl', lineHeight: '2.75rem', letterSpacing: 'tight' },
    'sm': { fontSize: '3xl', lineHeight: '2.375rem' },
    'xs': { fontSize: '2xl', lineHeight: '2rem' },
  },
  _J = { baseStyle: TJ, sizes: RJ },
  kJ = {
    'outline': (t) => ({
      field: {
        borderRadius: 'lg',
        bg: ft('white', 'gray.800')(t),
        _hover: { borderColor: ft('gray.300', 'gray.600')(t) },
        _focus: {
          borderColor: ft('brand.500', 'brand.200')(t),
          boxShadow: ft(
            `0px 0px 0px 1px ${Nr('brand.500', 1)(t.theme)}`,
            `0px 0px 0px 1px ${Nr('brand.200', 1)(t.theme)}`
          )(t),
        },
      },
      addon: { borderRadius: 'lg', bg: ft('gray.50', 'gray.700')(t) },
    }),
    'outline-on-accent': (t) => ({
      field: {
        bg: 'white',
        borderRadius: 'lg',
        color: 'gray.900',
        borderWidth: '1px',
        borderColor: 'brand.50',
        _placeholder: { color: 'gray.500' },
        _hover: { borderColor: 'brand.100' },
        _focus: {
          borderColor: 'brand.200',
          boxShadow: `0px 0px 0px 1px ${Nr('brand.200', 1)(t.theme)}`,
        },
      },
    }),
    'filled': (t) =>
      t.colorScheme === 'gray'
        ? {
            field: {
              bg: ft('white', 'gray.800')(t),
              _hover: {
                borderColor: ft('gray.200', 'gray.700')(t),
                bg: ft('white', 'gray.700')(t),
              },
              _focus: { borderColor: 'accent', bg: ft('white', 'gray.800')(t) },
            },
          }
        : {
            field: {
              bg: 'bg-accent-subtle',
              color: 'on-accent',
              _placeholder: { color: 'on-accent' },
              _hover: { borderColor: 'brand.400', bg: 'bg-accent-subtle' },
              _focus: { bg: 'bg-accent-subtle', borderColor: 'brand.300' },
            },
          },
  },
  DJ = { lg: { field: { fontSize: 'md', borderRadius: 'lg' } } },
  AJ = { variants: kJ, sizes: DJ, defaultProps: { colorScheme: 'gray' } },
  OJ = {
    menu: () => ({ borderRadius: 'lg', _hover: { textDecoration: 'none', bg: 'bg-subtle' } }),
  },
  MJ = { variants: OJ },
  PJ = {
    content: {
      borderWidth: '1px',
      boxShadow: 'lg',
      borderRadius: 'lg',
      background: 'bg-surface',
      overflow: 'hidden',
    },
  },
  LJ = { baseStyle: PJ },
  zJ = { track: { borderRadius: 'base' } },
  $J = {
    'solid': { track: { bg: 'bg-muted' } },
    'on-accent': { track: { bg: 'transparent' }, filledTrack: { bg: 'brand.50' } },
  },
  FJ = { colorScheme: 'brand', variant: 'solid' },
  NJ = { variants: $J, baseStyle: zJ, defaultProps: FJ },
  BJ = (t) => ({
    borderWidth: '1px',
    borderRadius: 'lg',
    p: '4',
    bg: 'bg-surface',
    transitionProperty: 'common',
    transitionDuration: 'normal',
    _hover: { borderColor: ft('gray.300', 'gray.600')(t) },
    _checked: {
      borderColor: ft('brand.500', 'brand.200')(t),
      boxShadow: ft(
        `0px 0px 0px 1px ${Nr('brand.500', 1)(t.theme)}`,
        `0px 0px 0px 1px ${Nr('brand.200', 1)(t.theme)}`
      )(t),
    },
  }),
  jJ = { baseStyle: BJ },
  UJ = {
    table: { bg: 'bg-surface', whiteSpace: 'nowrap' },
    th: {
      fontWeight: 'medium',
      textTransform: 'normal',
      letterSpacing: 'normal',
      borderTopWidth: '1px',
      whiteSpace: 'nowrap',
    },
  },
  VJ = {
    simple: (t) => ({ th: { color: 'muted', bg: ft('gray.50', Nr('gray.700', 0.4)(t.theme))(t) } }),
    striped: (t) => ({
      th: { color: 'muted', borderBottomWidth: '0px' },
      thead: { 'th,td': { borderWidth: '0px' } },
      tbody: {
        tr: {
          'th,td': { borderWidth: '0px' },
          '&:last-of-type': { 'th, td': { borderBottomWidth: '1px' } },
          '&:nth-of-type(odd)': {
            'th, td': { borderBottomWidth: '0px' },
            'td': { bg: ft('gray.50', Nr('gray.700', 0.4)(t.theme))(t) },
          },
        },
      },
    }),
  },
  IJ = { md: { th: { lineHeight: '1.25rem' }, td: { fontSize: 'sm' } } },
  HJ = { sizes: IJ, baseStyle: UJ, variants: VJ },
  WJ = {
    tab: {
      fontWeight: 'medium',
      color: 'muted',
      _focus: { boxShadow: 'none' },
      _focusVisible: { boxShadow: 'base' },
    },
  },
  YJ = (t) => {
    const { orientation: r, size: a } = t,
      o = r === 'vertical',
      l = r === 'vertical' ? 'borderStart' : 'borderBottom',
      f = o ? 'marginStart' : 'marginBottom',
      c = {
        'pt': '0',
        'pb': '4.5',
        'px': '1',
        'justifyContent': 'start',
        ':not(:last-child)': { me: '4' },
      },
      p = {
        'justifyContent': 'start',
        'px': a === 'lg' ? '3.5' : '3',
        ':not(:last-child)': { mb: '2' },
      }
    return {
      tablist: { [l]: '1px solid', borderColor: 'inherit' },
      tab: {
        color: 'muted',
        [l]: '2px solid transparent',
        [f]: '-1px',
        _selected: { color: 'accent', [l]: '2px solid' },
        _active: { bg: 'transparent' },
        ...(o ? p : c),
      },
    }
  },
  GJ = { tab: { _selected: { color: 'accent' } } },
  qJ = { 'with-line': YJ, 'enclosed': GJ },
  KJ = {
    md: { tab: { fontSize: 'sm', lineHeight: '1.25rem', py: '2' } },
    lg: { tab: { fontSize: 'md', py: '2.5' } },
  },
  XJ = { baseStyle: WJ, variants: qJ, sizes: KJ },
  QJ = {
    outline: (t) => ({
      borderRadius: 'lg',
      bg: ft('white', 'gray.800')(t),
      _hover: { borderColor: ft('gray.300', 'gray.600')(t) },
      _focus: {
        borderColor: ft('brand.500', 'brand.200')(t),
        boxShadow: ft(
          `0px 0px 0px 1px ${Nr('brand.500', 1)(t.theme)}`,
          `0px 0px 0px 1px ${Nr('brand.200', 1)(t.theme)}`
        )(t),
      },
    }),
  },
  ZJ = { variants: QJ },
  JJ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Badge: tJ,
        Button: iJ,
        Checkbox: uJ,
        CloseButton: fJ,
        Container: pJ,
        CustomSelect: yJ,
        Divider: bJ,
        FormLabel: EJ,
        Heading: _J,
        Input: AJ,
        Link: MJ,
        Popover: LJ,
        Progress: NJ,
        RadioCard: jJ,
        Table: HJ,
        Tabs: XJ,
        Textarea: ZJ,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  eee = {
    heading: 'Roboto, InterVariable, -apple-system, system-ui, sans-serif',
    body: 'Roboto, InterVariable, -apple-system, system-ui, sans-serif',
  },
  tee = {
    'xs': '0px 1px 2px rgba(16, 24, 40, 0.05)',
    'sm': '0px 0px 1px rgba(48, 49, 51, 0.05), 0px 2px 4px rgba(48, 49, 51, 0.1)',
    'md': '0px 0px 1px rgba(48, 49, 51, 0.05), 0px 4px 8px rgba(48, 49, 51, 0.1)',
    'lg': '0px 0px 1px rgba(48, 49, 51, 0.05), 0px 8px 16px rgba(48, 49, 51, 0.1)',
    'xl': '0px 0px 1px rgba(48, 49, 51, 0.05), 0px 16px 24px rgba(48, 49, 51, 0.1)',
    'xs-dark': '0px 1px 3px rgba(11, 12, 17, 0.9)',
    'sm-dark': '0px 2px 4px rgba(11, 12, 17, 0.9)',
    'md-dark': '0px 4px 8px rgba(11, 12, 17, 0.9)',
    'lg-dark': '0px 8px 16px rgba(11, 12, 17, 0.9)',
    'xl-dark': '0px 16px 24px rgba(11, 12, 17, 0.9)',
  },
  nee = { 4.5: '1.125rem' },
  ree = {
    global: (t) => ({
      'body': { color: 'default', bg: 'bg-canvas' },
      '*::placeholder': { opacity: 1, color: 'muted' },
      '*, *::before, &::after': { borderColor: ft('gray.200', 'gray.700')(t) },
      'html,body': { height: '100%' },
      '#__next, #root': { display: 'flex', flexDirection: 'column', minH: '100%' },
    }),
  },
  aee = {
    '7xl': { fontSize: '7xl', lineHeight: '5.75rem', letterSpacing: '-0.02em' },
    '6xl': { fontSize: '6xl', lineHeight: '4.5rem', letterSpacing: '-0.02em' },
    '5xl': { fontSize: '5xl', lineHeight: '3.75rem', letterSpacing: '-0.02em' },
    '4xl': { fontSize: '4xl', lineHeight: '2.75rem', letterSpacing: '-0.02em' },
    '3xl': { fontSize: '3xl', lineHeight: '2.375rem' },
    '2xl': { fontSize: '2xl', lineHeight: '2rem' },
    'xl': { fontSize: 'xl', lineHeight: '1.875rem' },
    'lg': { fontSize: 'lg', lineHeight: '1.75rem' },
    'md': { fontSize: 'md', lineHeight: '1.5rem' },
    'sm': { fontSize: 'sm', lineHeight: '1.25rem' },
    'xs': { fontSize: 'xs', lineHeight: '1.125rem' },
  },
  iee = {
    colors: {
      'bg-canvas': { default: 'gray.50', _dark: 'gray.900' },
      'bg-surface': { default: 'white', _dark: 'gray.800' },
      'bg-subtle': { default: 'gray.50', _dark: 'gray.700' },
      'bg-muted': { default: 'gray.100', _dark: 'gray.600' },
      'default': { default: 'gray.900', _dark: 'white' },
      'inverted': { default: 'white', _dark: 'gray.900' },
      'emphasized': { default: 'gray.700', _dark: 'gray.100' },
      'muted': { default: 'gray.600', _dark: 'gray.300' },
      'subtle': { default: 'gray.500', _dark: 'gray.400' },
      'border': { default: 'gray.200', _dark: 'gray.700' },
      'accent': { default: 'brand.500', _dark: 'brand.200' },
      'success': { default: 'green.600', _dark: 'green.200' },
      'error': { default: 'red.600', _dark: 'red.200' },
      'bg-accent': 'brand.600',
      'bg-accent-subtle': 'brand.500',
      'bg-accent-muted': 'brand.400',
      'on-accent': 'white',
      'on-accent-muted': 'brand.50',
      'on-accent-subtle': 'brand.100',
    },
    shadows: {
      xs: {
        default: '0px 0px 1px rgba(45, 55, 72, 0.05), 0px 1px 2px rgba(45, 55, 72,  0.1)',
        _dark: '0px 0px 1px rgba(13, 14, 20, 1), 0px 1px 2px rgba(13, 14, 20, 0.9)',
      },
      sm: {
        default: '0px 0px 1px rgba(45, 55, 72, 0.05), 0px 2px 4px rgba(45, 55, 72,  0.1)',
        _dark: '0px 0px 1px rgba(13, 14, 20, 1), 0px 2px 4px rgba(13, 14, 20, 0.9)',
      },
      md: {
        default: '0px 0px 1px rgba(45, 55, 72, 0.05), 0px 4px 8px rgba(45, 55, 72,  0.1)',
        _dark: '0px 0px 1px rgba(13, 14, 20, 1), 0px 4px 8px rgba(13, 14, 20, 0.9)',
      },
      lg: {
        default: '0px 0px 1px rgba(45, 55, 72, 0.05), 0px 8px 16px rgba(45, 55, 72,  0.1)',
        _dark: '0px 0px 1px rgba(13, 14, 20, 1), 0px 8px 16px rgba(13, 14, 20, 0.9)',
      },
      xl: {
        default: '0px 0px 1px rgba(45, 55, 72, 0.05), 0px 16px 24px rgba(45, 55, 72,  0.1)',
        _dark: '0px 0px 1px rgba(13, 14, 20, 1), 0px 16px 24px rgba(13, 14, 20, 0.9)',
      },
    },
  },
  oee = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        fonts: eee,
        semanticTokens: iee,
        shadows: tee,
        space: nee,
        styles: ree,
        textStyles: aee,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  NM = gW({ ...oee, components: { ...JJ } })
const see = '/assets/bathtub-a8eba9cf.jpeg',
  lee = '/assets/bedroom-69e2b3e1.jpeg',
  uee = '/assets/house-3fd03061.jpeg',
  cee = ({ images: t, ...r }) =>
    V(eM, {
      templateColumns: { base: '1fr', lg: `repeat(${t.length}, 1fr)` },
      gap: 5,
      ...r,
      children: t.map((a) =>
        V(Vd, {
          borderRadius: '0.5rem',
          backgroundImage: `url(${a})`,
          backgroundSize: 'cover',
          height: { base: '100vw', lg: '300px' },
          justifyContent: 'center',
          alignItems: 'center',
          color: 'white',
          ...r,
        })
      ),
    }),
  fee = '/assets/sedona-header-e1943e27.jpg',
  lp = ({ children: t, ...r }) =>
    V(Vd, {
      borderRadius: '0.5rem',
      backgroundImage: `url(${fee})`,
      backgroundSize: 'cover',
      height: '300px',
      justifyContent: 'center',
      alignItems: 'center',
      color: 'white',
      ...r,
      children: V(Ud, { size: { base: 'lg', md: '2xl' }, textShadow: 'dark-lg', children: t }),
    }),
  dee = () =>
    He(dc, {
      spacing: 5,
      children: [
        V(lp, { children: 'Welcome' }),
        V(mt, {
          children:
            'Welcome to Sedona Guest Services! We provide high-quality and reliable management services for homeowners and property investors who wish to maximize their rental income while minimizing their workload.',
        }),
        V(mt, {
          children:
            'Whether you own a vacation home, a second property, or a series of rental units, we can help you manage every aspect of your rental business, from marketing and booking to cleaning and maintenance. Our team of experienced professionals is committed to delivering outstanding results and providing exceptional customer service.',
        }),
        V(mt, { children: 'Our services include:' }),
        He(mt, {
          children: [
            V('strong', { children: 'Marketing and Booking:' }),
            ' We will promote your property on top short-term rental platforms such as Airbnb, Booking.com, and Expedia. Our team will manage all communication with guests, handle booking requests, and coordinate check-ins and check-outs.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Guest Services:' }),
            ' Our team will ensure that your guests have a smooth and enjoyable experience during their stay. We will handle all inquiries, provide 24/7 support, and respond to any issues that may arise.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Cleaning and Maintenance:' }),
            " We know that keeping your property clean and well-maintained is crucial to your success. That's why we offer regular cleaning and maintenance services to ensure that your property is always in top condition.",
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Revenue Management:' }),
            ' Our team will constantly monitor the rental market and adjust prices based on demand, seasonality, and other factors to ensure that you maximize your rental income.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Legal Compliance:' }),
            ' We will make sure that your property complies with all local regulations and requirements, including tax filings and permits.',
          ],
        }),
        V(mt, {
          children:
            'At our company, we pride ourselves on our professionalism, attention to detail, and commitment to excellence. We know that your property is your investment, and we will treat it with the utmost care and respect.',
        }),
        V(mt, {
          children:
            "If you're ready to take your short-term rental business to the next level, contact us today to learn more about our services and how we can help you achieve your goals.",
        }),
        V(cee, { images: [lee, see, uee] }),
      ],
    }),
  pee = () =>
    He(dc, {
      spacing: 5,
      children: [
        V(lp, { children: 'Cleaning' }),
        V(mt, {
          children:
            'Cleaning a short-term rental is an essential part of ensuring a comfortable and safe stay for your guests. Here are some best practices for cleaning a short-term rental:',
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Develop a cleaning checklist:' }),
            ' A cleaning checklist helps ensure that every part of your rental property is cleaned thoroughly and consistently. The checklist should include tasks such as wiping down surfaces, cleaning the bathroom, changing linens, and vacuuming or sweeping.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Use high-quality cleaning supplies:' }),
            ' High-quality cleaning supplies, including disinfectants and sanitizers, are essential for maintaining a clean and healthy rental property. Make sure to use products that are effective against a broad range of germs and viruses, and replace cleaning supplies regularly.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Pay attention to high-touch areas:' }),
            ' High-touch areas, such as doorknobs, light switches, and remote controls, are more likely to harbor germs and bacteria. Be sure to pay extra attention to these areas during your cleaning routine.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Change linens and towels:' }),
            ' Changing linens and towels between guests is essential for maintaining a fresh and hygienic rental property. Make sure to wash linens and towels in hot water with detergent and bleach to kill germs and bacteria.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Declutter and organize:' }),
            ' A clean and organized rental property is more appealing to guests. Make sure to declutter and organize the space regularly, including removing any personal items, and ensure that all items are placed in their proper location.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Hire professional cleaners:' }),
            ' If you’re unable to maintain a clean rental property on your own, consider hiring a professional cleaning service. Professional cleaners can provide deep cleaning services and help ensure that your rental property is always in top condition for your guests.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Communicate your cleaning standards with guests:' }),
            ' Be sure to communicate your cleaning standards and procedures with your guests. This can help reassure them that your rental property is clean and safe, and also set expectations for how they should leave the property upon check-out.',
          ],
        }),
        V(mt, {
          children:
            'By following these best practices for cleaning a short-term rental, you can ensure that your guests have a comfortable and enjoyable stay.',
        }),
      ],
    })
var BM = 'https://static.elfsight.com/platform/platform.js'
function hee() {
  R.useEffect(function () {
    mee() || yee()
  }, [])
}
function mee() {
  return vee() || gee()
}
function vee() {
  return 'eapps' in window
}
function gee() {
  return !!document.querySelector('script[src="' + BM + '"]')
}
function yee() {
  var t = document.createElement('script')
  ;(t.src = BM), (t.defer = !0), document.head.appendChild(t)
}
function bee(t) {
  var r = t.widgetID
  return hee(), ca.createElement('div', { className: 'elfsight-app-' + r })
}
var jM = R.memo(bee)
const See = () =>
    He(sv, {
      children: [
        V(Ud, { as: 'h1', size: 'lg', textAlign: 'center', children: 'Contact' }),
        V(jM, { widgetID: '1d6f76ef-e10d-4d99-b958-0a49cca41cb9' }),
      ],
    }),
  xee = () =>
    He(dc, {
      spacing: 5,
      children: [
        V(lp, { children: 'Area Regulations' }),
        V(mt, {
          children:
            'Sedona is located within Yavapai County, and short-term rental regulations vary by town or city. Here are some general rules and regulations for short-term rentals in Sedona and the surrounding areas:',
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Sedona:' }),
            ' In Sedona, short-term rentals are allowed in most residential areas. However, rental properties must be registered with the city, and the owner or manager must obtain a business license and a Transient Occupancy Tax (TOT) license. The TOT rate in Sedona is currently 3.5%. Additionally, Sedona requires that a responsible party, who must live within 30 miles of the rental property, be designated to address any issues or complaints that may arise during the guest’s stay.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Yavapai County:' }),
            ' In unincorporated areas of Yavapai County, short-term rentals are allowed in residential zones. Owners must obtain a permit and pay a transaction privilege tax (TPT) of 3%. Additionally, the county requires a responsible party to be available to address any issues that may arise during the guest’s stay.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Cottonwood:' }),
            ' In Cottonwood, short-term rentals are allowed in residential zones with a permit. Owners must obtain a business license and a TPT license, and the TPT rate is 3%. Additionally, Cottonwood requires a responsible party to be available to address any issues that may arise during the guest’s stay.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Clarkdale:' }),
            ' In Clarkdale, short-term rentals are allowed in residential zones with a permit. Owners must obtain a business license and a TPT license, and the TPT rate is 3%. Additionally, Clarkdale requires a responsible party to be available to address any issues that may arise during the guest’s stay.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Jerome:' }),
            'In Jerome, short-term rentals are allowed in residential zones with a permit. Owners must obtain a business license and a TPT license, and the TPT rate is 3%. Additionally, Jerome requires a responsible party to be available to address any issues that may arise during the guest’s stay.',
          ],
        }),
        V(mt, {
          children:
            'It’s important to note that these rules and regulations are subject to change, and it’s important to check with the local jurisdiction where the rental property is located for the most up-to-date information. Additionally, it’s important for owners to follow all applicable laws and regulations to avoid any potential fines or legal issues.',
        }),
      ],
    }),
  Cee = () =>
    He(sv, {
      children: [
        V(lp, { borderBottomRadius: 0, children: 'Reviews' }),
        V(jM, { widgetID: 'd254839d-abb3-4085-b4a1-59a38451e70f' }),
      ],
    }),
  wee = (t) =>
    V(oc, {
      as: 'section',
      bg: 'linkedin.500',
      boxShadow: 'sm',
      textAlign: 'center',
      ...t,
      children: V(Dv, {
        py: { base: '4', lg: '5' },
        maxW: '6xl',
        children: V(mt, { children: '© 2023 Sedona Guest Services LLC; All Rights Reserved. ' }),
      }),
    })
var UM = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 },
  ED = ca.createContext && ca.createContext(UM),
  _s =
    (globalThis && globalThis.__assign) ||
    function () {
      return (
        (_s =
          Object.assign ||
          function (t) {
            for (var r, a = 1, o = arguments.length; a < o; a++) {
              r = arguments[a]
              for (var l in r) Object.prototype.hasOwnProperty.call(r, l) && (t[l] = r[l])
            }
            return t
          }),
        _s.apply(this, arguments)
      )
    },
  Eee =
    (globalThis && globalThis.__rest) ||
    function (t, r) {
      var a = {}
      for (var o in t)
        Object.prototype.hasOwnProperty.call(t, o) && r.indexOf(o) < 0 && (a[o] = t[o])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var l = 0, o = Object.getOwnPropertySymbols(t); l < o.length; l++)
          r.indexOf(o[l]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, o[l]) &&
            (a[o[l]] = t[o[l]])
      return a
    }
function VM(t) {
  return (
    t &&
    t.map(function (r, a) {
      return ca.createElement(r.tag, _s({ key: a }, r.attr), VM(r.child))
    })
  )
}
function IM(t) {
  return function (r) {
    return ca.createElement(Tee, _s({ attr: _s({}, t.attr) }, r), VM(t.child))
  }
}
function Tee(t) {
  var r = function (a) {
    var o = t.attr,
      l = t.size,
      f = t.title,
      c = Eee(t, ['attr', 'size', 'title']),
      p = l || a.size || '1em',
      h
    return (
      a.className && (h = a.className),
      t.className && (h = (h ? h + ' ' : '') + t.className),
      ca.createElement(
        'svg',
        _s({ stroke: 'currentColor', fill: 'currentColor', strokeWidth: '0' }, a.attr, o, c, {
          className: h,
          style: _s(_s({ color: t.color || a.color }, a.style), t.style),
          height: p,
          width: p,
          xmlns: 'http://www.w3.org/2000/svg',
        }),
        f && ca.createElement('title', null, f),
        t.children
      )
    )
  }
  return ED !== void 0
    ? ca.createElement(ED.Consumer, null, function (a) {
        return r(a)
      })
    : r(UM)
}
function Ree(t) {
  return IM({
    tag: 'svg',
    attr: { viewBox: '0 0 24 24' },
    child: [
      { tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0z' } },
      {
        tag: 'path',
        attr: {
          d: 'M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z',
        },
      },
    ],
  })(t)
}
function _ee(t) {
  return IM({
    tag: 'svg',
    attr: { viewBox: '0 0 24 24' },
    child: [
      { tag: 'path', attr: { fill: 'none', d: 'M0 0h24v24H0z' } },
      { tag: 'path', attr: { d: 'M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z' } },
    ],
  })(t)
}
const kee = (t) => {
    const r = cK({ base: !1, lg: !0 })
    return V(oc, {
      as: 'section',
      bg: 'white',
      ...t,
      children: V(oc, {
        as: 'nav',
        bg: 'bg-surface',
        boxShadow: 'sm',
        children: r
          ? V(Dv, {
              py: { base: '4', lg: '5' },
              maxW: '6xl',
              children: He(ax, {
                spacing: '10',
                justify: 'space-between',
                children: [
                  V(Ud, { fontSize: 'lg', children: 'Sedona Guest Services' }),
                  He(Vd, {
                    justify: 'space-between',
                    flex: '1',
                    gap: 10,
                    children: [
                      He(GO, {
                        variant: 'link',
                        spacing: '8',
                        children: [
                          V(To, { variant: 'link', as: qr, to: '/about', children: 'About Us' }),
                          V(To, {
                            variant: 'link',
                            as: qr,
                            to: '/tips',
                            children: 'Tips for Owners',
                          }),
                          V(To, {
                            variant: 'link',
                            as: qr,
                            to: '/regulations',
                            children: 'Area Regulations',
                          }),
                          V(To, { variant: 'link', as: qr, to: '/cleaning', children: 'Cleaning' }),
                          V(To, { variant: 'link', as: qr, to: '/reviews', children: 'Reviews' }),
                        ],
                      }),
                      He(ax, {
                        spacing: '3',
                        children: [
                          V(To, {
                            leftIcon: V(Ree, {}),
                            onClick: () => window.open('tel:928.985.0575'),
                            children: '928.985.0575',
                          }),
                          V(To, {
                            colorScheme: 'linkedin',
                            as: qr,
                            to: '/contact',
                            children: 'Contact',
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            })
          : He(Vd, {
              px: 5,
              justify: 'space-between',
              align: 'center',
              children: [
                V(Ud, { fontSize: 'lg', children: 'Sedona Guest Services' }),
                He(vM, {
                  children: [
                    V(SM, {
                      'as': qO,
                      'aria-label': 'Mobile menu',
                      'icon': V(_ee, { fontSize: '3xl' }),
                      'colorScheme': 'linkedin',
                      'variant': 'ghost',
                      'borderRadius': 0,
                    }),
                    He(bM, {
                      children: [
                        V(xs, { as: qr, to: '/about', fontSize: '2xl', children: 'About Us' }),
                        V(xs, {
                          as: qr,
                          to: '/tips',
                          fontSize: '2xl',
                          children: 'Tips for Owners',
                        }),
                        V(xs, {
                          as: qr,
                          to: '/regulations',
                          fontSize: '2xl',
                          children: 'Area Regulations',
                        }),
                        V(xs, { as: qr, to: '/cleaning', fontSize: '2xl', children: 'Cleaning' }),
                        V(xs, { as: qr, to: '/reviews', fontSize: '2xl', children: 'Reviews' }),
                        V(xs, { as: qr, to: '/contact', fontSize: '2xl', children: 'Contact' }),
                        V(xs, {
                          as: qr,
                          to: 'tel:928.985.0575',
                          fontSize: '2xl',
                          children: 'Call Now',
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
      }),
    })
  },
  Dee = () =>
    He(sv, {
      children: [
        V(kee, {}),
        V(oc, {
          bg: 'linkedin.50',
          minH: '100vh',
          children: V(Dv, { maxW: '6xl', pt: 5, pb: 10, children: V(TZ, {}) }),
        }),
        V(wee, {}),
      ],
    }),
  Aee = () =>
    He(dc, {
      spacing: 5,
      children: [
        V(lp, { children: 'Tips for Owners' }),
        He(mt, {
          children: [
            V('strong', { children: 'Set Clear House Rules:' }),
            ' It’s important to have clear house rules that are easy to understand and follow for your guests. Consider including rules for noise levels, smoking, pets, and other potential issues. Make sure these rules are easily accessible to guests so they can refer to them if needed.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Provide Clear Check-In and Check-Out Instructions:' }),
            ' Provide guests with clear instructions on how to check in and out of the property. Include details on where to find the keys, how to use the lockbox, and any other important information. Make sure these instructions are easy to follow and communicate any potential issues, such as limited parking or difficult access.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Use Professional Photos:' }),
            ' High-quality, professional photos of your property are essential for attracting guests. Consider hiring a professional photographer or using a high-quality camera to capture the best angles and lighting. Make sure the photos showcase the best features of your property and accurately represent what guests can expect.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Price Your Rental Correctly:' }),
            ' Setting the right price for your rental is crucial for attracting guests and maximizing your profits. Research comparable properties in your area to get an idea of what similar rentals are charging. Consider factors such as location, amenities, and seasonality when setting your price.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Be Responsive:' }),
            " Guests expect quick and helpful communication from their hosts. Make sure you respond to all inquiries and messages promptly, and be available to answer any questions guests may have before and during their stay. This can help improve your guests' experience and lead to positive reviews and repeat business.",
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Consider Offering Amenities:' }),
            ' Providing amenities such as Wi-Fi, cable TV, and kitchen essentials can make your rental more attractive to guests. Consider offering additional amenities such as toiletries, snacks, or local guidebooks to enhance the guest experience.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Clean and Maintain Your Property:' }),
            ' Keeping your rental clean and well-maintained is crucial for guest satisfaction and positive reviews. Hire a professional cleaning service to clean between guest stays and regularly inspect the property for any maintenance issues.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Focus on Guest Experience:' }),
            ' Providing an exceptional guest experience should be a top priority for short-term rental owners. Consider personalizing the guest experience by providing welcome gifts, local recommendations, and other thoughtful touches. Respond to any guest feedback and work to improve your rental based on their suggestions.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Adhere to Local Regulations:' }),
            ' Make sure you understand and follow all local regulations and requirements for short-term rentals in your area. This may include obtaining permits, paying taxes, and following zoning laws. Failure to adhere to these regulations can result in fines or legal issues.',
          ],
        }),
        He(mt, {
          children: [
            V('strong', { children: 'Consider Working with a Management Company:' }),
            ' If managing your short-term rental is too time-consuming or overwhelming, consider working with a professional management company. A management company can handle all aspects of your rental, from marketing and booking to cleaning and maintenance, allowing you to focus on other priorities.',
          ],
        }),
        V(mt, {
          children:
            'In summary, owning a short-term rental can be a rewarding and profitable experience if managed properly. By following these tips and focusing on providing an exceptional guest experience, you can attract more guests, receive positive reviews, and build a successful rental business.',
        }),
      ],
    })
console.log('theme', NM)
const Oee = BZ([
  {
    path: '/',
    element: V(Dee, {}),
    children: [
      { path: '/about', element: V(dee, {}) },
      { path: '/tips', element: V(Aee, {}) },
      { path: '/regulations', element: V(xee, {}) },
      { path: '/cleaning', element: V(pee, {}) },
      { path: '/reviews', element: V(Cee, {}) },
      { path: '/contact', element: V(See, {}) },
      { path: '/', element: V(EZ, { to: '/about', replace: !0 }) },
    ],
  },
])
ux.createRoot(document.getElementById('root')).render(
  V(ca.StrictMode, { children: V(Mq, { theme: NM, children: V(wZ, { router: Oee }) }) })
)
